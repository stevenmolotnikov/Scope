<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TokenLens - Chat Interface</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@500&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='chat.css') }}">
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-header">
                <button class="new-chat-btn" onclick="createNewChat()">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M8 2V14M2 8H14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                    New Chat
                </button>
            </div>
            
            <div class="conversations-list" id="conversations-list">
                <!-- Conversations will be dynamically added here -->
            </div>
        </aside>

        <!-- Main Chat Area -->
        <div class="chat-container">
            <!-- Header -->
            <header class="chat-header">
                <div class="header-content">
                    <button class="sidebar-toggle-main" onclick="toggleSidebar()">
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                            <path d="M3 10H17M3 5H17M3 15H17" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                    </button>
                    <div class="logo">
                        <span class="logo-text">TokenLens</span>
                    </div>
                    <div class="mode-selector">
                        <select id="mode-select" onchange="switchMode()">
                            <option value="default">Default</option>
                            <option value="comparison">Model Comparison</option>
                            <option value="prefill">Prefilling</option>
                        </select>
                    </div>
                    <div class="model-selector">
                        <select id="model-select" onchange="saveCurrentConversation()">
                            <option value="meta-llama/Llama-3.1-8B-Instruct">Llama-3.1-8B-Instruct</option>
                            <option value="google/gemma-2-2b-it">Gemma-2-2B-IT</option>
                            <option value="google/gemma-3-1b-it">Gemma-3-1B-IT</option>
                        </select>
                    </div>
                    <button class="clear-btn" onclick="deleteCurrentChat()">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                            <path d="M2 4H14M6 4V2H10V4M3 4V14H13V4" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                        </svg>
                    </button>
                </div>
            </header>

            <!-- Messages Area -->
            <div class="messages-container" id="messages-container">
                <div class="welcome-message">
                    <h2>Welcome to TokenLens</h2>
                    <p>Chat with AI and see token probabilities in real-time</p>
                </div>
            </div>
            
            <!-- Comparison Mode Container (hidden by default) -->
            <div class="comparison-container hidden" id="comparison-container">
                <div class="comparison-header">
                    <div class="model-select-group">
                        <label>Model 1:</label>
                        <select id="model-select-1" class="comparison-model-select">
                            <option value="meta-llama/Llama-3.1-8B-Instruct">Llama-3.1-8B-Instruct</option>
                            <option value="google/gemma-2-2b-it">Gemma-2-2B-IT</option>
                            <option value="google/gemma-3-1b-it">Gemma-3-1B-IT</option>
                        </select>
                    </div>
                    <div class="diff-indicator">
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                            <path d="M4 10H16M10 4L16 10L10 16" stroke="currentColor" stroke-width="2"/>
                        </svg>
                    </div>
                    <div class="model-select-group">
                        <label>Model 2:</label>
                        <select id="model-select-2" class="comparison-model-select">
                            <option value="meta-llama/Llama-3.1-8B-Instruct">Llama-3.1-8B-Instruct</option>
                            <option value="google/gemma-2-2b-it" selected>Gemma-2-2B-IT</option>
                            <option value="google/gemma-3-1b-it">Gemma-3-1B-IT</option>
                        </select>
                    </div>
                </div>
                <div class="diff-messages" id="diff-messages">
                    <div class="welcome-message">
                        <p>Send a message to see model differences</p>
                    </div>
                </div>
            </div>

        <!-- Input Area -->
        <div class="input-container">
            <div class="prefill-input-wrapper hidden" id="prefill-wrapper">
                <label for="prefill-input" class="prefill-label">
                    <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
                        <path d="M7 2V12M2 7H12" stroke="currentColor" stroke-width="1.5"/>
                    </svg>
                    Prefill assistant response
                </label>
                <input 
                    type="text" 
                    id="prefill-input" 
                    placeholder='e.g., "Sure, " or "I cannot..."'
                    class="prefill-input"
                />
            </div>
            <div class="input-wrapper">
                <textarea 
                    id="user-input" 
                    placeholder="Type your message..." 
                    rows="1"
                    onkeydown="handleKeyDown(event)"
                ></textarea>
                <button id="send-btn" onclick="sendMessage()">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                        <path d="M2 10L18 2L10 18L8 11L2 10Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                </button>
            </div>
        </div>
        </div>
    </div>

    <!-- Token Context Menu -->
    <div id="token-context-menu" class="context-menu hidden">
        <div class="context-menu-section">
            <div class="context-menu-header">Choose Alternative Token</div>
            <div id="top-alternatives-list" class="alternatives-menu-list">
                <!-- Top 3 alternatives will be inserted here -->
            </div>
        </div>
        <div class="context-menu-section">
            <input type="text" id="token-search-input" placeholder="Search or type token..." class="token-search-input">
            <div id="token-search-results" class="token-search-results">
                <!-- Search results will appear here -->
            </div>
        </div>
        <div class="context-menu-section">
            <button class="context-menu-btn primary" id="inject-regenerate-btn">
                <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
                    <path d="M7 1V7M7 7H13M7 7L2 12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                </svg>
                Inject and Regenerate
            </button>
            <button class="context-menu-btn" id="branch-conversation-btn">
                <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
                    <path d="M7 3V11M7 3L4 6M7 3L10 6" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                </svg>
                Branch to New Chat
            </button>
        </div>
    </div>

    <script>
        let isGenerating = false;
        let conversationHistory = [];
        let currentConversationId = null;
        let conversations = {};
        let selectedTokenElement = null;
        let selectedAlternativeToken = null;
        let currentMode = 'default';
        
        // Get conversation ID from URL path
        function getConversationIdFromUrl() {
            const path = window.location.pathname;
            const match = path.match(/\/chat\/([^\/]+)/);
            const id = match ? match[1] : null;
            console.log('Parsed conversation ID from URL:', path, '=>', id);
            return id;
        }
        
        const urlConversationId = getConversationIdFromUrl();

        function handleKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                sendMessage();
            }
        }

        function clearChat() {
            const messagesContainer = document.getElementById('messages-container');
            messagesContainer.innerHTML = `
                <div class="welcome-message">
                    <h2>Welcome to TokenLens</h2>
                    <p>Chat with AI and see token probabilities in real-time</p>
                </div>
            `;
            conversationHistory = [];
            saveCurrentConversation();
        }

        function sendMessage() {
            if (isGenerating) return;
            
            const input = document.getElementById('user-input');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Get prefill text if in prefill mode
            let prefillText = null;
            if (currentMode === 'prefill') {
                const prefillInput = document.getElementById('prefill-input');
                prefillText = prefillInput.value.trim() || null;
            }
            
            // Clear inputs
            input.value = '';
            input.style.height = 'auto';
            
            // Remove welcome message if present
            const welcomeMsg = document.querySelector('.welcome-message');
            if (welcomeMsg) {
                welcomeMsg.remove();
            }
            
            // Add user message to history
            conversationHistory.push({
                role: 'user',
                content: message
            });
            
            // Handle based on current mode
            if (currentMode === 'comparison') {
                // Display user message in both panels
                addUserMessageToComparison(message);
                
                // Generate responses for both models
                generateComparisonResponses(message, prefillText);
            } else {
                // Display user message
                addUserMessage(message);
                
                // Start generating assistant response (with prefill if provided)
                generateResponse(prefillText);
            }
        }

        function addUserMessage(content, scroll = true) {
            const messagesContainer = document.getElementById('messages-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user-message';
            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-text">${escapeHtml(content)}</div>
                </div>
            `;
            messagesContainer.appendChild(messageDiv);
            if (scroll) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }
        
        function addUserMessageToComparison(content) {
            const diffMessages = document.getElementById('diff-messages');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user-message';
            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-text">${escapeHtml(content)}</div>
                </div>
            `;
            diffMessages.appendChild(messageDiv);
            diffMessages.scrollTop = diffMessages.scrollHeight;
        }

        async function generateResponse(prefillText = null) {
            isGenerating = true;
            const sendBtn = document.getElementById('send-btn');
            sendBtn.disabled = true;
            
            const messagesContainer = document.getElementById('messages-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant-message';
            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-tokens" id="streaming-tokens"></div>
                </div>
            `;
            messagesContainer.appendChild(messageDiv);
            
            const tokensContainer = document.getElementById('streaming-tokens');
            const modelName = document.getElementById('model-select').value;
            
            let assistantResponse = '';
            let responseTokens = [];
            
            // Show prefill text with yellow styling ONLY in prefill mode
            if (prefillText && currentMode === 'prefill') {
                const prefillSpan = document.createElement('span');
                prefillSpan.className = 'prefilled-text';
                prefillSpan.textContent = prefillText;
                tokensContainer.appendChild(prefillSpan);
                assistantResponse = prefillText;
            }
            
            try {
                // Use fetch with streaming for POST requests
                const requestBody = {
                    messages: conversationHistory,
                    model: modelName
                };
                
                if (prefillText) {
                    requestBody.prefill = prefillText;
                }
                
                const response = await fetch('/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody)
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    
                    // Decode the chunk
                    const chunk = decoder.decode(value, {stream: true});
                    
                    // Parse SSE format (data: {...}\n\n)
                    const lines = chunk.split('\n');
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const jsonStr = line.substring(6);
                            try {
                                const data = JSON.parse(jsonStr);
                                
                                if (data.type === 'token') {
                                    const isPromptToken = data.is_prompt_token || false;
                                    
                                    // Skip prompt tokens entirely
                                    if (isPromptToken) {
                                        continue;
                                    }
                                    
                                    assistantResponse += data.token;
                                    const tokenIdx = responseTokens.length;
                                    responseTokens.push({
                                        token: data.token,
                                        probability: data.probability,
                                        rank: data.rank,
                                        vocab_size: data.vocab_size,
                                        top_alternatives: data.top_alternatives
                                    });
                                    addToken(tokensContainer, data.token, data.probability, data.rank, data.vocab_size, data.top_alternatives, tokenIdx);
                                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                } else if (data.type === 'done') {
                                    // Add assistant response to conversation history
                                    conversationHistory.push({
                                        role: 'assistant',
                                        content: assistantResponse,
                                        tokens: responseTokens
                                    });
                                    saveCurrentConversation(true); // Update timestamp for new message
                                    isGenerating = false;
                                    sendBtn.disabled = false;
                                } else if (data.type === 'error') {
                                    console.error('Error:', data.message);
                                    tokensContainer.innerHTML += `<div class="error-message">Error: ${escapeHtml(data.message)}</div>`;
                                    isGenerating = false;
                                    sendBtn.disabled = false;
                                }
                            } catch (e) {
                                // Skip invalid JSON
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Fetch error:', error);
                tokensContainer.innerHTML += `<div class="error-message">Connection error. Please try again.</div>`;
                isGenerating = false;
                sendBtn.disabled = false;
            }
        }

        function addToken(container, token, probability, rank, vocabSize, topAlternatives, tokenIndex) {
            const tokenSpan = document.createElement('span');
            tokenSpan.className = 'token';
            
            // Store token data for context menu
            tokenSpan.dataset.token = token;
            tokenSpan.dataset.probability = probability;
            tokenSpan.dataset.rank = rank;
            tokenSpan.dataset.vocabSize = vocabSize;
            tokenSpan.dataset.topAlternatives = JSON.stringify(topAlternatives || []);
            tokenSpan.dataset.tokenIndex = tokenIndex;
            
            // Color based on probability
            const color = getColorForProb(probability || 0);
            tokenSpan.style.backgroundColor = color;
            
            // Handle special tokens - check for any whitespace, not just exact matches
            let displayToken = token;
            let isWhitespace = false;
            let isSpecialToken = false;
            
            // Check for special tokens (like <end_of_turn>, <start_of_turn>, <|eot_id|>, etc.)
            if (token.startsWith('<') && token.endsWith('>')) {
                tokenSpan.classList.add('special-token');
                isSpecialToken = true;
            }
            // Also check for pipe-delimited special tokens like <|eot_id|>
            else if (token.includes('<|') || token.includes('|>')) {
                tokenSpan.classList.add('special-token');
                isSpecialToken = true;
            }
            // Check if token contains newlines
            else if (token.includes('\n')) {
                // Count newlines
                const newlineCount = (token.match(/\n/g) || []).length;
                displayToken = newlineCount === 1 ? '↵' : `↵×${newlineCount}`;
                tokenSpan.classList.add('newline-token');
                isWhitespace = true;
            } 
            // Check if token is only spaces
            else if (token === ' ' || /^\s+$/.test(token)) {
                const spaceCount = token.length;
                displayToken = spaceCount === 1 ? '·' : `·×${spaceCount}`;
                tokenSpan.classList.add('space-token');
                isWhitespace = true;
            }
            // Check for tab characters
            else if (token.includes('\t')) {
                const tabCount = (token.match(/\t/g) || []).length;
                displayToken = tabCount === 1 ? '→' : `→×${tabCount}`;
                tokenSpan.classList.add('space-token');
                isWhitespace = true;
            }
            
            // Use textContent to prevent any HTML rendering issues
            tokenSpan.textContent = displayToken;
            
            // Add click handler for context menu
            tokenSpan.addEventListener('click', function(e) {
                e.stopPropagation();
                showTokenContextMenu(tokenSpan, e);
            });
            
            // Create tooltip with escaped/readable whitespace
            const tooltip = document.createElement('span');
            tooltip.className = 'custom-tooltip';
            
            // For tooltip, show escaped version of whitespace
            let displayTokenForTooltip = token
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r')
                .replace(/\t/g, '\\t')
                .replace(/ /g, '·');
            
            let tooltipHTML = `<strong>Token:</strong> "${escapeHtml(displayTokenForTooltip)}"<br>`;
            
            if (probability !== null && probability !== undefined && !isNaN(probability)) {
                tooltipHTML += `<strong>Probability:</strong> ${probability.toFixed(6)}<br>`;
            } else {
                tooltipHTML += `<strong>Probability:</strong> N/A<br>`;
            }
            
            if (rank !== null && rank !== undefined && vocabSize) {
                tooltipHTML += `<strong>Rank:</strong> ${rank} / ${vocabSize}`;
            } else {
                tooltipHTML += `<strong>Rank:</strong> N/A`;
            }
            
            if (topAlternatives && topAlternatives.length > 0 && topAlternatives[0].probability !== null) {
                tooltipHTML += '<br><br><strong>Top 3 Alternatives:</strong><ol class="alternatives-list">';
                topAlternatives.forEach(alt => {
                    // Also escape whitespace in alternatives
                    let altDisplay = alt.token
                        .replace(/\n/g, '\\n')
                        .replace(/\r/g, '\\r')
                        .replace(/\t/g, '\\t')
                        .replace(/ /g, '·');
                    tooltipHTML += `<li>${escapeHtml(altDisplay)}: ${(alt.probability * 100).toFixed(2)}%</li>`;
                });
                tooltipHTML += '</ol>';
            }
            
            tooltip.innerHTML = tooltipHTML;
            tokenSpan.appendChild(tooltip);
            
            // Add smart tooltip positioning on hover
            tokenSpan.addEventListener('mouseenter', function() {
                positionTooltip(tokenSpan, tooltip);
            });
            
            container.appendChild(tokenSpan);
            
            // Add actual newline break if token contains newlines
            if (token.includes('\n')) {
                const newlineCount = (token.match(/\n/g) || []).length;
                for (let i = 0; i < newlineCount; i++) {
                    container.appendChild(document.createElement('br'));
                }
            }
        }

        function positionTooltip(tokenElement, tooltip) {
            // Remove all positioning classes first
            tooltip.classList.remove('tooltip-below', 'tooltip-left', 'tooltip-right');
            
            // Get positions and dimensions
            const tokenRect = tokenElement.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();
            const viewportWidth = window.innerWidth;
            const viewportHeight = window.innerHeight;
            
            // Account for header and sidebar
            const header = document.querySelector('.chat-header');
            const sidebar = document.getElementById('sidebar');
            const headerHeight = header ? header.getBoundingClientRect().height : 0;
            const sidebarWidth = (sidebar && !sidebar.classList.contains('collapsed')) ? sidebar.getBoundingClientRect().width : 0;
            
            const margin = 10;
            const topBoundary = headerHeight + margin;
            const leftBoundary = sidebarWidth + margin;
            
            // Check vertical positioning
            // Default is above (bottom: calc(100% + 8px) in CSS)
            // Calculate where tooltip would be if positioned above
            const tooltipAboveTop = tokenRect.top - tooltipRect.height - 8;
            
            // If tooltip would go above header, position below instead
            if (tooltipAboveTop < topBoundary) {
                tooltip.classList.add('tooltip-below');
            }
            
            // Check horizontal positioning
            // Default is centered (left: 50%, transform: translateX(-50%) in CSS)
            // Calculate where tooltip edges would be if centered
            const tooltipCenterLeft = tokenRect.left + (tokenRect.width / 2) - (tooltipRect.width / 2);
            const tooltipCenterRight = tooltipCenterLeft + tooltipRect.width;
            
            // If tooltip would go behind sidebar or off left edge
            if (tooltipCenterLeft < leftBoundary) {
                tooltip.classList.add('tooltip-left');
            }
            // If tooltip would go off right edge, align to right of token
            else if (tooltipCenterRight > viewportWidth - margin) {
                tooltip.classList.add('tooltip-right');
            }
        }

        function getColorForProb(probability) {
            // Map probability to color: red (low) to green (high)
            const hue = 120 * probability;
            return `hsl(${hue}, 70%, 60%)`;
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // ===== MODE SWITCHING =====
        
        function switchMode() {
            const mode = document.getElementById('mode-select').value;
            currentMode = mode;
            
            const appContainer = document.querySelector('.app-container');
            const inputContainer = document.querySelector('.input-container');
            const modelSelector = document.querySelector('.model-selector');
            
            // Remove all mode classes
            appContainer.classList.remove('mode-default', 'mode-comparison', 'mode-prefill');
            
            // Apply new mode class
            appContainer.classList.add(`mode-${mode}`);
            
            // Show/hide elements based on mode
            if (mode === 'comparison') {
                // Show dual model selectors and comparison layout
                showComparisonMode();
            } else {
                hideComparisonMode();
            }
            
            if (mode === 'prefill') {
                // Show prefill input
                showPrefillMode();
            } else {
                hidePrefillMode();
            }
        }
        
        function showPrefillMode() {
            const prefillWrapper = document.getElementById('prefill-wrapper');
            prefillWrapper.classList.remove('hidden');
        }
        
        function hidePrefillMode() {
            const prefillWrapper = document.getElementById('prefill-wrapper');
            prefillWrapper.classList.add('hidden');
            // Clear prefill input when hiding
            document.getElementById('prefill-input').value = '';
        }
        
        function showComparisonMode() {
            const comparisonContainer = document.getElementById('comparison-container');
            comparisonContainer.classList.remove('hidden');
            
            // Set default models if not already set
            const model1Select = document.getElementById('model-select-1');
            const model2Select = document.getElementById('model-select-2');
            
            if (!model1Select.value) {
                model1Select.value = 'meta-llama/Llama-3.1-8B-Instruct';
            }
            if (!model2Select.value) {
                model2Select.value = 'google/gemma-2-2b-it';
            }
        }
        
        function hideComparisonMode() {
            const comparisonContainer = document.getElementById('comparison-container');
            comparisonContainer.classList.add('hidden');
        }
        
        async function generateComparisonResponses(message, prefillText = null) {
            isGenerating = true;
            const sendBtn = document.getElementById('send-btn');
            sendBtn.disabled = true;
            
            const model1Name = document.getElementById('model-select-1').value;
            const model2Name = document.getElementById('model-select-2').value;
            
            const diffMessages = document.getElementById('diff-messages');
            
            // Add assistant message placeholder for diff view
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant-message diff-message';
            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="diff-header">
                        <span class="model-label model-1-label">${model1Name.split('/').pop()}</span>
                        <span class="diff-separator">↔</span>
                        <span class="model-label model-2-label">${model2Name.split('/').pop()}</span>
                    </div>
                    <div class="message-tokens" id="diff-tokens">
                        <div class="generating-indicator">Generating from both models...</div>
                    </div>
                </div>
            `;
            diffMessages.appendChild(messageDiv);
            diffMessages.scrollTop = diffMessages.scrollHeight;
            
            // Generate from both models simultaneously (but don't display yet)
            const response1Promise = generateForModelSilent(model1Name, prefillText);
            const response2Promise = generateForModelSilent(model2Name, prefillText);
            
            // Wait for both to complete
            const [response1, response2] = await Promise.all([response1Promise, response2Promise]);
            
            // Build and display the diff
            buildDiffView('diff-tokens', response1, response2);
            
            // Save to conversation history
            conversationHistory.push({
                role: 'assistant',
                content: response1.text,
                tokens: response1.tokens,
                comparison: {
                    model1: model1Name,
                    model2: model2Name,
                    response1: response1,
                    response2: response2
                }
            });
            
            saveCurrentConversation(true); // Update timestamp for new message
            isGenerating = false;
            sendBtn.disabled = false;
        }
        
        function buildDiffView(containerId, response1, response2) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';
            
            // Filter out prompt tokens
            const tokens1 = response1.tokens.filter(t => !t.is_prompt_token);
            const tokens2 = response2.tokens.filter(t => !t.is_prompt_token);
            
            let i = 0;
            let j = 0;
            
            while (i < tokens1.length || j < tokens2.length) {
                // Check if tokens match
                if (i < tokens1.length && j < tokens2.length && tokens1[i].token === tokens2[j].token) {
                    // Tokens match - show as normal (use model 1's token data)
                    addToken(container, tokens1[i].token, tokens1[i].probability, tokens1[i].rank, tokens1[i].vocab_size, tokens1[i].top_alternatives, i);
                    
                    // Add newline if token contains newline
                    if (tokens1[i].token.includes('\n')) {
                        container.appendChild(document.createElement('br'));
                    }
                    
                    i++;
                    j++;
                } else {
                    // Tokens diverge - show diff
                    const diffGroup = document.createElement('span');
                    diffGroup.className = 'diff-group';
                    
                    // Add model 1 version
                    if (i < tokens1.length) {
                        const token1Span = document.createElement('span');
                        token1Span.className = 'diff-token model-1-token';
                        const color = getColorForProb(tokens1[i].probability);
                        token1Span.style.backgroundColor = color;
                        
                        let displayToken1 = tokens1[i].token;
                        if (tokens1[i].token.includes('\n')) {
                            displayToken1 = '↵';
                        } else if (tokens1[i].token === ' ') {
                            displayToken1 = '·';
                        }
                        token1Span.textContent = displayToken1;
                        
                        // Add tooltip
                        const tooltip1 = createTooltip(tokens1[i], i);
                        token1Span.appendChild(tooltip1);
                        token1Span.addEventListener('mouseenter', function() {
                            positionTooltip(token1Span, tooltip1);
                        });
                        
                        diffGroup.appendChild(token1Span);
                    }
                    
                    // Add separator
                    const separator = document.createElement('span');
                    separator.className = 'diff-separator-inline';
                    separator.textContent = ' | ';
                    diffGroup.appendChild(separator);
                    
                    // Add model 2 version
                    if (j < tokens2.length) {
                        const token2Span = document.createElement('span');
                        token2Span.className = 'diff-token model-2-token';
                        const color = getColorForProb(tokens2[j].probability);
                        token2Span.style.backgroundColor = color;
                        
                        let displayToken2 = tokens2[j].token;
                        if (tokens2[j].token.includes('\n')) {
                            displayToken2 = '↵';
                        } else if (tokens2[j].token === ' ') {
                            displayToken2 = '·';
                        }
                        token2Span.textContent = displayToken2;
                        
                        // Add tooltip
                        const tooltip2 = createTooltip(tokens2[j], j);
                        token2Span.appendChild(tooltip2);
                        token2Span.addEventListener('mouseenter', function() {
                            positionTooltip(token2Span, tooltip2);
                        });
                        
                        diffGroup.appendChild(token2Span);
                    }
                    
                    container.appendChild(diffGroup);
                    
                    // Add newline if either token contains newline
                    if ((i < tokens1.length && tokens1[i-1]?.token.includes('\n')) || 
                        (j < tokens2.length && tokens2[j-1]?.token.includes('\n'))) {
                        container.appendChild(document.createElement('br'));
                    }
                    
                    i++;
                    j++;
                }
            }
        }
        
        function createTooltip(tokenData, idx) {
            const tooltip = document.createElement('span');
            tooltip.className = 'custom-tooltip';
            
            let displayTokenForTooltip = tokenData.token
                .replace(/\n/g, '\\n')
                .replace(/\r/g, '\\r')
                .replace(/\t/g, '\\t')
                .replace(/ /g, '·');
            
            let tooltipHTML = `<strong>Token:</strong> "${escapeHtml(displayTokenForTooltip)}"<br>`;
            
            if (tokenData.probability !== null && tokenData.probability !== undefined && !isNaN(tokenData.probability)) {
                tooltipHTML += `<strong>Probability:</strong> ${tokenData.probability.toFixed(6)}<br>`;
            } else {
                tooltipHTML += `<strong>Probability:</strong> N/A<br>`;
            }
            
            if (tokenData.rank !== null && tokenData.rank !== undefined && tokenData.vocab_size) {
                tooltipHTML += `<strong>Rank:</strong> ${tokenData.rank} / ${tokenData.vocab_size}`;
            } else {
                tooltipHTML += `<strong>Rank:</strong> N/A`;
            }
            
            if (tokenData.top_alternatives && tokenData.top_alternatives.length > 0 && tokenData.top_alternatives[0].probability !== null) {
                tooltipHTML += '<br><br><strong>Top 3 Alternatives:</strong><ol class="alternatives-list">';
                tokenData.top_alternatives.forEach(alt => {
                    let altDisplay = alt.token
                        .replace(/\n/g, '\\n')
                        .replace(/\r/g, '\\r')
                        .replace(/\t/g, '\\t')
                        .replace(/ /g, '·');
                    tooltipHTML += `<li>${escapeHtml(altDisplay)}: ${(alt.probability * 100).toFixed(2)}%</li>`;
                });
                tooltipHTML += '</ol>';
            }
            
            tooltip.innerHTML = tooltipHTML;
            return tooltip;
        }
        
        async function generateForModelSilent(modelName, prefillText = null) {
            // Generate without displaying - used for comparison mode
            let assistantResponse = prefillText || '';
            let responseTokens = [];
            
            try {
                const requestBody = {
                    messages: conversationHistory,
                    model: modelName
                };
                
                if (prefillText) {
                    requestBody.prefill = prefillText;
                }
                
                const response = await fetch('/stream', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify(requestBody)
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value, {stream: true});
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const jsonStr = line.substring(6);
                            try {
                                const data = JSON.parse(jsonStr);
                                
                                if (data.type === 'token') {
                                    assistantResponse += data.token;
                                    responseTokens.push({
                                        token: data.token,
                                        probability: data.probability,
                                        rank: data.rank,
                                        vocab_size: data.vocab_size,
                                        top_alternatives: data.top_alternatives
                                    });
                                } else if (data.type === 'done') {
                                    break;
                                }
                            } catch (e) {
                                // Skip invalid JSON
                            }
                        }
                    }
                }
                
                return {
                    text: assistantResponse,
                    tokens: responseTokens,
                    model: modelName
                };
                
            } catch (error) {
                console.error('Generation failed:', error);
                return {
                    text: '',
                    tokens: [],
                    model: modelName
                };
            }
        }
        

        // ===== TOKEN CONTEXT MENU =====
        
        function showTokenContextMenu(tokenElement, event) {
            const menu = document.getElementById('token-context-menu');
            const alternativesList = document.getElementById('top-alternatives-list');
            const searchInput = document.getElementById('token-search-input');
            const searchResults = document.getElementById('token-search-results');
            
            // Store reference to clicked token
            selectedTokenElement = tokenElement;
            selectedAlternativeToken = null;
            
            // Get token data
            const topAlternatives = JSON.parse(tokenElement.dataset.topAlternatives);
            
            // Populate top 3 alternatives
            alternativesList.innerHTML = '';
            topAlternatives.forEach((alt, idx) => {
                const altItem = document.createElement('div');
                altItem.className = 'alternative-item';
                altItem.onclick = () => selectAlternativeToken(alt.token, altItem);
                
                let displayToken = alt.token;
                if (alt.token.includes('\n')) {
                    displayToken = '↵';
                } else if (alt.token === ' ') {
                    displayToken = '·';
                }
                
                altItem.innerHTML = `
                    <span class="alt-token">${escapeHtml(displayToken)}</span>
                    <span class="alt-prob">${(alt.probability * 100).toFixed(1)}%</span>
                `;
                alternativesList.appendChild(altItem);
            });
            
            // Clear search
            searchInput.value = '';
            searchResults.innerHTML = '';
            
            // Position menu near the token
            const rect = tokenElement.getBoundingClientRect();
            menu.style.top = `${rect.bottom + 5}px`;
            menu.style.left = `${rect.left}px`;
            
            // Show menu
            menu.classList.remove('hidden');
            
            // Focus search input
            setTimeout(() => searchInput.focus(), 0);
        }
        
        let searchListenerSetup = false;
        function setupTokenSearchListener() {
            if (searchListenerSetup) return;
            
            const searchInput = document.getElementById('token-search-input');
            if (!searchInput) return;
            
            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                const query = this.value.trim();
                
                console.log('Search input changed:', query);
                
                const resultsDiv = document.getElementById('token-search-results');
                
                if (query.length < 1) {
                    resultsDiv.innerHTML = '';
                    return;
                }
                
                // Show searching indicator
                resultsDiv.innerHTML = '<div class="search-no-results">Searching...</div>';
                
                searchTimeout = setTimeout(() => searchTokens(query), 300);
            });
            
            searchListenerSetup = true;
            console.log('Token search listener set up');
        }
        
        function selectAlternativeToken(token, element) {
            selectedAlternativeToken = token;
            
            // Update UI to show selection
            document.querySelectorAll('.alternative-item').forEach(item => {
                item.classList.remove('selected');
            });
            document.querySelectorAll('.search-result-item').forEach(item => {
                item.classList.remove('selected');
            });
            element.classList.add('selected');
        }
        
        function hideContextMenu() {
            const menu = document.getElementById('token-context-menu');
            menu.classList.add('hidden');
            selectedTokenElement = null;
            selectedAlternativeToken = null;
        }
        
        // Close context menu when clicking outside (setup after DOM loads)
        function setupContextMenuHandlers() {
            document.addEventListener('click', function(e) {
                const menu = document.getElementById('token-context-menu');
                if (menu && !menu.classList.contains('hidden') && !menu.contains(e.target) && !e.target.classList.contains('token')) {
                    hideContextMenu();
                }
            });
            
            // Prevent context menu from closing when clicking inside it
            const menu = document.getElementById('token-context-menu');
            if (menu) {
                menu.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
            }
        }
        
        // Token search with debouncing
        let searchTimeout = null;
        
        document.addEventListener('DOMContentLoaded', function() {
            // Setup context menu handlers
            setupContextMenuHandlers();
            
            // Setup token search
            setupTokenSearchListener();
            
            // Setup button handlers
            const injectBtn = document.getElementById('inject-regenerate-btn');
            if (injectBtn) {
                injectBtn.onclick = () => injectAndRegenerate();
            }
            
            const branchBtn = document.getElementById('branch-conversation-btn');
            if (branchBtn) {
                branchBtn.onclick = () => branchConversation();
            }
        });
        
        async function searchTokens(query) {
            const modelName = document.getElementById('model-select').value;
            const resultsDiv = document.getElementById('token-search-results');
            
            console.log('Searching tokens for:', query, 'with model:', modelName);
            
            try {
                const response = await fetch('/api/search-tokens', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({query: query, model: modelName})
                });
                
                if (!response.ok) {
                    console.error('Search request failed:', response.status);
                    resultsDiv.innerHTML = '<div class="search-error">Search failed</div>';
                    return;
                }
                
                const results = await response.json();
                console.log('Search results:', results.length, 'tokens found');
                
                resultsDiv.innerHTML = '';
                
                if (results.length === 0) {
                    resultsDiv.innerHTML = '<div class="search-no-results">No matches found</div>';
                    return;
                }
                
                results.forEach((result, idx) => {
                    const item = document.createElement('div');
                    item.className = 'search-result-item';
                    item.onclick = () => selectAlternativeToken(result.token, item);
                    
                    let displayToken = result.token;
                    if (result.token.includes('\n')) {
                        displayToken = '↵';
                    } else if (result.token === ' ') {
                        displayToken = '·';
                    } else if (result.token.includes('\t')) {
                        displayToken = '→';
                    }
                    
                    // Show raw token string if different from decoded
                    let rawInfo = '';
                    if (result.raw && result.raw !== result.token) {
                        rawInfo = ` <span class="token-raw">(${escapeHtml(result.raw)})</span>`;
                    }
                    
                    item.innerHTML = `<span class="alt-token">${escapeHtml(displayToken)}</span>${rawInfo}`;
                    resultsDiv.appendChild(item);
                    
                    console.log(`Search result ${idx}:`, result.token);
                });
            } catch (error) {
                console.error('Token search failed:', error);
                resultsDiv.innerHTML = '<div class="search-error">Search error: ' + error.message + '</div>';
            }
        }
        
        async function injectAndRegenerate() {
            if (!selectedTokenElement || !selectedAlternativeToken) {
                alert('Please select a token first');
                return;
            }
            
            const tokenIndex = parseInt(selectedTokenElement.dataset.tokenIndex);
            
            // Get the last assistant message
            const lastAssistantIndex = conversationHistory.length - 1;
            if (lastAssistantIndex < 0 || conversationHistory[lastAssistantIndex].role !== 'assistant') {
                alert('Cannot inject: no assistant message found');
                return;
            }
            
            const lastMessage = conversationHistory[lastAssistantIndex];
            
            // Get the original token's alternatives to find the probability of the injected token
            const originalToken = lastMessage.tokens[tokenIndex];
            const topAlternatives = originalToken.top_alternatives || [];
            
            // Find the probability of the selected alternative
            const altData = topAlternatives.find(alt => alt.token === selectedAlternativeToken);
            const injectedTokenProb = altData ? altData.probability : null;
            
            // Truncate the response up to the selected token and inject the alternative
            const tokensBeforeInjection = lastMessage.tokens.slice(0, tokenIndex);
            const textBeforeInjection = tokensBeforeInjection.map(t => t.token).join('');
            const injectedText = textBeforeInjection + selectedAlternativeToken;
            
            // Remove the last assistant message
            conversationHistory.pop();
            
            // Clear the visual message
            const messagesContainer = document.getElementById('messages-container');
            const lastMsgElement = messagesContainer.querySelector('.message.assistant-message:last-child');
            if (lastMsgElement) {
                lastMsgElement.remove();
            }
            
            // Create new message with the injected tokens displayed normally
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant-message';
            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-tokens" id="streaming-tokens"></div>
                </div>
            `;
            messagesContainer.appendChild(messageDiv);
            
            const tokensContainer = document.getElementById('streaming-tokens');
            
            // Display the tokens before injection normally (not as prefill)
            tokensBeforeInjection.forEach((tokenData, idx) => {
                addToken(tokensContainer, tokenData.token, tokenData.probability, tokenData.rank, tokenData.vocab_size, tokenData.top_alternatives, idx);
            });
            
            // Display the injected token with its probability data and special styling
            const injectedTokenData = {
                token: selectedAlternativeToken,
                probability: injectedTokenProb,
                rank: altData ? topAlternatives.indexOf(altData) + 1 : null,
                vocab_size: originalToken.vocab_size,
                top_alternatives: topAlternatives
            };
            
            const injectedIdx = tokensBeforeInjection.length;
            addToken(tokensContainer, injectedTokenData.token, injectedTokenData.probability, injectedTokenData.rank, injectedTokenData.vocab_size, injectedTokenData.top_alternatives, injectedIdx);
            
            // Add injected styling to the token we just created
            const lastToken = tokensContainer.lastElementChild;
            if (lastToken && lastToken.classList.contains('token')) {
                lastToken.classList.add('injected-token');
            }
            
            // Now continue generation from this point
            const startingTokenIndex = tokensBeforeInjection.length + 1;
            await continueGenerationFromPoint(tokensContainer, injectedText, tokensBeforeInjection, injectedTokenData, startingTokenIndex);
            
            hideContextMenu();
        }
        
        async function continueGenerationFromPoint(tokensContainer, prefillText, tokensBeforeInjection, injectedTokenData, startingIndex) {
            isGenerating = true;
            const sendBtn = document.getElementById('send-btn');
            sendBtn.disabled = true;
            const modelName = document.getElementById('model-select').value;
            const messagesContainer = document.getElementById('messages-container');
            
            let assistantResponse = prefillText;
            let allTokens = [...tokensBeforeInjection];  // Include pre-injection tokens
            
            // Add the injected token to the list with its probability data
            allTokens.push(injectedTokenData);
            
            try {
                const response = await fetch('/stream', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        messages: conversationHistory,
                        model: modelName,
                        prefill: prefillText
                    })
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value, {stream: true});
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const jsonStr = line.substring(6);
                            try {
                                const data = JSON.parse(jsonStr);
                                
                                if (data.type === 'token') {
                                    const isPromptToken = data.is_prompt_token || false;
                                    if (isPromptToken) continue;
                                    
                                    assistantResponse += data.token;
                                    const tokenIdx = allTokens.length;
                                    allTokens.push({
                                        token: data.token,
                                        probability: data.probability,
                                        rank: data.rank,
                                        vocab_size: data.vocab_size,
                                        top_alternatives: data.top_alternatives
                                    });
                                    addToken(tokensContainer, data.token, data.probability, data.rank, data.vocab_size, data.top_alternatives, tokenIdx);
                                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                } else if (data.type === 'done') {
                                    // Save complete message to conversation
                                    conversationHistory.push({
                                        role: 'assistant',
                                        content: assistantResponse,
                                        tokens: allTokens
                                    });
                                    saveCurrentConversation(true);
                                    isGenerating = false;
                                    sendBtn.disabled = false;
                                    break;
                                }
                            } catch (e) {
                                // Skip invalid JSON
                            }
                        }
                    }
                }
            } catch (error) {
                console.error('Continuation failed:', error);
                tokensContainer.innerHTML += `<div class="error-message">Error: ${error.message}</div>`;
                isGenerating = false;
                sendBtn.disabled = false;
            }
        }
        
        async function branchConversation() {
            if (!selectedTokenElement || !selectedAlternativeToken) {
                alert('Please select a token first');
                return;
            }
            
            // Create a new conversation as a branch
            createNewChat();
            
            // TODO: Copy conversation up to this point and inject the alternative token
            console.log('Branch conversation with token', selectedAlternativeToken);
            
            hideContextMenu();
        }

        // ===== CONVERSATION MANAGEMENT =====
        
        async function initializeConversations() {
            console.log('Initializing conversations...');
            console.log('URL conversation ID:', urlConversationId);
            
            // Load conversations from server
            try {
                const response = await fetch('/api/conversations');
                const serverConvs = JSON.parse(await response.text());
                conversations = serverConvs;
                console.log('Loaded conversations from server:', Object.keys(conversations));
            } catch (error) {
                console.error('Failed to load conversations from server:', error);
                // Fallback to localStorage
                const saved = localStorage.getItem('tokenlens_conversations');
                if (saved) {
                    conversations = JSON.parse(saved);
                    console.log('Loaded conversations from localStorage:', Object.keys(conversations));
                }
            }
            
            // Priority 1: Load conversation from URL if provided
            if (urlConversationId) {
                console.log('Attempting to load conversation from URL:', urlConversationId);
                if (conversations[urlConversationId]) {
                    console.log('Found conversation in loaded data, loading...');
                    loadConversation(urlConversationId, false); // false = don't update URL
                    updateSidebar();
                    return;
                } else {
                    console.warn('Conversation', urlConversationId, 'not found in loaded conversations');
                    console.log('Available conversations:', Object.keys(conversations));
                    // Show error message to user
                    alert(`Conversation not found. It may have been deleted or doesn't exist.`);
                    // Redirect to home
                    window.location.href = '/';
                    return;
                }
            }
            
            // Priority 2: Load active conversation from localStorage
            currentConversationId = localStorage.getItem('tokenlens_active_conversation');
            
            // If no conversations exist, create a new one
            if (Object.keys(conversations).length === 0) {
                console.log('No conversations found, creating new one');
                createNewChat();
            } else {
                // Load the active conversation or the most recent one
                if (!currentConversationId || !conversations[currentConversationId]) {
                    const conversationIds = Object.keys(conversations).sort((a, b) => 
                        conversations[b].timestamp - conversations[a].timestamp
                    );
                    currentConversationId = conversationIds[0];
                    console.log('Loading most recent conversation:', currentConversationId);
                } else {
                    console.log('Loading active conversation:', currentConversationId);
                }
                loadConversation(currentConversationId);
            }
            
            updateSidebar();
        }
        
        function createNewChat() {
            // Save current conversation before creating new one
            if (currentConversationId) {
                saveCurrentConversation();
            }
            
            // Create new conversation
            const id = 'conv_' + Date.now();
            conversations[id] = {
                id: id,
                title: 'New Chat',
                timestamp: Date.now(),
                messages: [],
                model: document.getElementById('model-select').value
            };
            
            currentConversationId = id;
            conversationHistory = [];
            
            // Clear UI
            clearChat();
            
            // Update URL
            updateUrl(id);
            
            // Save and update sidebar
            saveConversations();
            updateSidebar();
        }
        
        function saveCurrentConversation(updateTimestamp = false) {
            if (!currentConversationId) return;
            
            const conversation = conversations[currentConversationId];
            if (!conversation) return;
            
            conversation.messages = conversationHistory;
            conversation.model = document.getElementById('model-select').value;
            
            // Only update timestamp when new content is added, not when just switching
            if (updateTimestamp) {
                conversation.timestamp = Date.now();
            }
            
            // Generate title from first user message
            if (conversationHistory.length > 0 && conversation.title === 'New Chat') {
                const firstUserMsg = conversationHistory.find(msg => msg.role === 'user');
                if (firstUserMsg) {
                    conversation.title = firstUserMsg.content.substring(0, 50);
                    if (firstUserMsg.content.length > 50) {
                        conversation.title += '...';
                    }
                }
            }
            
            saveConversations();
            updateSidebar();
        }
        
        async function saveConversations() {
            // Save to server
            if (currentConversationId && conversations[currentConversationId]) {
                try {
                    await fetch(`/api/conversations/${currentConversationId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(conversations[currentConversationId])
                    });
                } catch (error) {
                    console.error('Failed to save conversation to server:', error);
                }
            }
            
            // Also save to localStorage as backup
            localStorage.setItem('tokenlens_conversations', JSON.stringify(conversations));
            localStorage.setItem('tokenlens_active_conversation', currentConversationId);
        }
        
        function loadConversation(id, updateUrlFlag = true) {
            // Save current conversation first
            if (currentConversationId && currentConversationId !== id) {
                saveCurrentConversation();
            }
            
            const conversation = conversations[id];
            if (!conversation) return;
            
            currentConversationId = id;
            conversationHistory = conversation.messages || [];
            
            // Set model
            document.getElementById('model-select').value = conversation.model || 'meta-llama/Llama-3.1-8B-Instruct';
            
            // Render messages
            const messagesContainer = document.getElementById('messages-container');
            messagesContainer.innerHTML = '';
            
            if (conversationHistory.length === 0) {
                messagesContainer.innerHTML = `
                    <div class="welcome-message">
                        <h2>Welcome to TokenLens</h2>
                        <p>Chat with AI and see token probabilities in real-time</p>
                    </div>
                `;
            } else {
                conversationHistory.forEach(msg => {
                    if (msg.role === 'user') {
                        addUserMessage(msg.content, false);
                    } else if (msg.role === 'assistant') {
                        addAssistantMessage(msg.content, msg.tokens || []);
                    }
                });
            }
            
            // Update URL if requested
            if (updateUrlFlag) {
                updateUrl(id);
            }
            
            saveConversations();
            updateSidebar();
        }
        
        async function deleteCurrentChat() {
            if (!currentConversationId) return;
            
            if (!confirm('Delete this conversation?')) return;
            
            const idToDelete = currentConversationId;
            
            // Delete from conversations object
            delete conversations[idToDelete];
            
            // Delete from server
            try {
                await fetch(`/api/conversations/${idToDelete}`, {
                    method: 'DELETE'
                });
            } catch (error) {
                console.error('Failed to delete conversation from server:', error);
            }
            
            // Load another conversation or create new one
            const remainingIds = Object.keys(conversations);
            if (remainingIds.length > 0) {
                loadConversation(remainingIds[0]);
            } else {
                createNewChat();
            }
            
            // Save remaining conversations
            localStorage.setItem('tokenlens_conversations', JSON.stringify(conversations));
            updateSidebar();
        }
        
        function updateSidebar() {
            const list = document.getElementById('conversations-list');
            list.innerHTML = '';
            
            // Sort conversations by timestamp (newest first)
            const sortedIds = Object.keys(conversations).sort((a, b) => 
                conversations[b].timestamp - conversations[a].timestamp
            );
            
            sortedIds.forEach(id => {
                const conv = conversations[id];
                const item = document.createElement('div');
                item.className = 'conversation-item' + (id === currentConversationId ? ' active' : '');
                item.onclick = () => loadConversation(id);
                
                const date = new Date(conv.timestamp);
                const timeStr = formatDate(date);
                
                item.innerHTML = `
                    <div class="conversation-content">
                        <div class="conversation-title">${escapeHtml(conv.title)}</div>
                        <div class="conversation-meta">${timeStr}</div>
                    </div>
                    <button class="copy-link-btn" onclick="copyConversationLink('${id}', event)" title="Copy link">
                        <svg width="12" height="12" viewBox="0 0 12 12" fill="none">
                            <path d="M5 7L7 5M4 3H3C2.44772 3 2 3.44772 2 4V9C2 9.55228 2.44772 10 3 10H8C8.55228 10 9 9.55228 9 9V8M7 2H10V5M10 2L5.5 6.5" stroke="currentColor" stroke-width="1.2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                `;
                
                list.appendChild(item);
            });
        }
        
        function formatDate(date) {
            const now = new Date();
            const diff = now - date;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (minutes < 1) return 'Just now';
            if (minutes < 60) return `${minutes}m ago`;
            if (hours < 24) return `${hours}h ago`;
            if (days < 7) return `${days}d ago`;
            
            return date.toLocaleDateString();
        }
        
        function updateUrl(conversationId) {
            const newUrl = `/chat/${conversationId}`;
            window.history.pushState({ conversationId: conversationId }, '', newUrl);
        }
        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('collapsed');
            
            // Save sidebar state
            const isCollapsed = sidebar.classList.contains('collapsed');
            localStorage.setItem('tokenlens_sidebar_collapsed', isCollapsed);
        }
        
        function initializeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const savedState = localStorage.getItem('tokenlens_sidebar_collapsed');
            
            // If saved state exists and is 'true', collapse the sidebar
            if (savedState === 'true') {
                sidebar.classList.add('collapsed');
            }
        }
        
        function copyConversationLink(conversationId, event) {
            event.stopPropagation(); // Prevent loading the conversation
            
            const url = `${window.location.origin}/chat/${conversationId}`;
            navigator.clipboard.writeText(url).then(() => {
                // Show temporary success message
                const button = event.target.closest('button');
                const originalHTML = button.innerHTML;
                button.innerHTML = `<svg width="12" height="12" viewBox="0 0 12 12" fill="none"><path d="M2 6L5 9L10 3" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/></svg>`;
                button.style.color = 'var(--success)';
                
                setTimeout(() => {
                    button.innerHTML = originalHTML;
                    button.style.color = '';
                }, 1500);
            }).catch(err => {
                console.error('Failed to copy link:', err);
                alert('Failed to copy link');
            });
        }
        
        // Handle browser back/forward buttons
        window.addEventListener('popstate', function(event) {
            if (event.state && event.state.conversationId) {
                // Load the conversation without updating the URL (it's already updated by popstate)
                loadConversation(event.state.conversationId, false);
            } else {
                // No state, redirect to home which will load default conversation
                window.location.href = '/';
            }
        });
        
        function addAssistantMessage(content, tokens) {
            const messagesContainer = document.getElementById('messages-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant-message';
            
            const tokensContainer = document.createElement('div');
            tokensContainer.className = 'message-tokens';
            
            if (tokens && tokens.length > 0) {
                // Render with token data using the same addToken function for consistency
                tokens.forEach((tokenData, idx) => {
                    // Skip prompt tokens
                    if (tokenData.is_prompt_token) {
                        return;
                    }
                    addToken(tokensContainer, tokenData.token, tokenData.probability, tokenData.rank, tokenData.vocab_size, tokenData.top_alternatives, idx);
                });
            } else {
                // Plain text rendering
                tokensContainer.textContent = content;
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            contentDiv.appendChild(tokensContainer);
            messageDiv.appendChild(contentDiv);
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Auto-resize textarea
        const textarea = document.getElementById('user-input');
        textarea.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 200) + 'px';
        });
        
        // Initialize on page load
        initializeSidebar();
        initializeConversations().then(() => {
            // Set initial history state after conversations are loaded
            if (currentConversationId) {
                const currentPath = window.location.pathname;
                const expectedPath = `/chat/${currentConversationId}`;
                
                // Only update if paths don't match
                if (currentPath !== expectedPath) {
                    window.history.replaceState(
                        { conversationId: currentConversationId }, 
                        '', 
                        expectedPath
                    );
                    console.log('Updated URL to match loaded conversation:', expectedPath);
                } else {
                    // Just set the state without changing URL
                    window.history.replaceState(
                        { conversationId: currentConversationId }, 
                        '', 
                        currentPath
                    );
                }
            }
        });
    </script>
</body>
</html>
