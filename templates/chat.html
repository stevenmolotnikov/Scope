<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scope - Chat Interface</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@500&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='chat.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
    <!-- Top Menu Bar -->
    <nav class="top-menu-bar">
        <div class="menu-brand">
            <span class="brand-title">Scope</span>
            <span class="brand-subtitle">by NDIF</span>
        </div>
        <div class="menu-items">
            <div class="menu-item">
                <button class="menu-btn" onclick="toggleMenu('file-menu')">File</button>
                <div class="menu-dropdown" id="file-menu">
                    <button class="menu-option" onclick="createNewChat(); closeAllMenus();">
                        <svg width="14" height="14" viewBox="0 0 16 16" fill="none">
                            <path d="M8 2V14M2 8H14" stroke="currentColor" stroke-width="2"/>
                        </svg>
                        New Chat
                    </button>
                    <button class="menu-option" onclick="saveCurrentConversation(); closeAllMenus();">Save Conversation</button>
                </div>
            </div>
            <div class="menu-item">
                <button class="menu-btn" onclick="toggleMenu('view-menu')">View</button>
                <div class="menu-dropdown" id="view-menu">
                    <div class="menu-option-group">
                        <label class="menu-label">Active View</label>
                        <select id="view-select-menu" onchange="syncViewSelect(this); switchView(); closeAllMenus();" class="menu-select">
                            <option value="token">Token View</option>
                            <option value="text">Text View</option>
                            <option value="diff">Diff View</option>
                        </select>
                    </div>
                    <div class="menu-option-group">
                        <label class="menu-label">Highlight By</label>
                        <select id="highlight-mode-select-menu" onchange="switchHighlightMode(); closeAllMenus();" class="menu-select">
                            <option value="probability">Probability</option>
                            <option value="rank">Rank</option>
                        </select>
                    </div>
                </div>
            </div>
            <div class="menu-item">
                <button class="menu-btn" onclick="toggleMenu('generation-menu')">Generation</button>
                <div class="menu-dropdown" id="generation-menu">
                    <button class="menu-option" onclick="openSystemPromptModal(); closeAllMenus();">System Prompt</button>
                    <button class="menu-option" onclick="openSamplingModal(); closeAllMenus();">Sampling</button>
                    <button class="menu-option" onclick="openRulesModal(); closeAllMenus();">
                        Automation Rules
                        <span id="rules-count-badge-menu" class="rules-count-badge" style="display: none; margin-left: 8px;"></span>
                    </button>
                </div>
            </div>
            <div class="menu-item">
                <button class="menu-btn" onclick="toggleMenu('analysis-menu')">Analysis</button>
                <div class="menu-dropdown" id="analysis-menu">
                    <div class="menu-option-group">
                        <label class="menu-checkbox-label">
                            <input 
                                type="checkbox" 
                                id="enable-difflens-checkbox"
                                onchange="toggleDiffLensInput()"
                            />
                            <span>Enable DiffLens</span>
                        </label>
                        <p class="menu-help">Compare generation across models</p>
                    </div>
                    <div class="menu-divider"></div>
                    <div class="menu-option-group">
                        <label class="menu-checkbox-label">
                            <input 
                                type="checkbox" 
                                id="enable-prefill-checkbox"
                                onchange="togglePrefillInput()"
                            />
                            <span>Enable Prefilling</span>
                        </label>
                        <p class="menu-help">Adds a prefill input in the chatbox</p>
                    </div>
                </div>
            </div>
        </div>
        <button class="sidebar-toggle-btn" onclick="toggleRightSidebar()" title="Toggle Inspector">
            <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                <rect x="3" y="3" width="6" height="14" stroke="currentColor" stroke-width="1.5"/>
                <rect x="11" y="3" width="6" height="14" stroke="currentColor" stroke-width="1.5"/>
            </svg>
        </button>
    </nav>

    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-content">
            <div class="sidebar-header">
                    <button class="sidebar-close-btn" onclick="toggleSidebar()" title="Close sidebar">
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                            <path d="M12 5L7 10L12 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                </div>
                
                <button class="new-chat-btn-sidebar" onclick="createNewChat()">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M8 2V14M2 8H14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                    <span>New chat</span>
                </button>
            
            <div class="conversations-list" id="conversations-list">
                <!-- Conversations will be dynamically added here -->
            </div>
            </div>
            
            <button class="sidebar-toggle-collapsed" onclick="toggleSidebar()" title="Open sidebar">
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                            <path d="M3 10H17M3 5H17M3 15H17" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                    </button>
            
            <button class="new-chat-btn-collapsed" onclick="createNewChat()" title="New chat">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                    <path d="M8 2V14M2 8H14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                    </button>
        </aside>

        <!-- Main Chat Area -->
        <div class="chat-container">
            <!-- Header -->
            <header class="main-header">
            </header>

            <!-- Messages Area -->
            <div class="messages-container" id="messages-container">
                <!-- System Prompt Bubble (hidden by default) -->
                <div class="system-prompt-bubble" id="system-prompt-bubble" style="display: none;">
                    <div class="system-prompt-header" onclick="toggleSystemPromptBubble()">
                        <span class="system-prompt-label">System</span>
                        <span class="system-prompt-toggle" id="system-prompt-toggle">▼</span>
                    </div>
                    <div class="system-prompt-content" id="system-prompt-content">
                        <!-- System prompt text will be inserted here -->
                    </div>
                </div>
                
                <div class="welcome-message">
                    <h2>Welcome to Scope</h2>
                    <p>Chat with AI and see token probabilities in real-time</p>
                </div>
            </div>
            
        <!-- Input Area -->
        <div class="input-container">
            <div class="input-wrapper">
                <textarea 
                    id="user-input" 
                    placeholder="Type your message..." 
                    rows="1"
                    onkeydown="handleKeyDown(event)"
                ></textarea>
                <div class="input-controls">
                    <div id="prefill-input-container" class="prefill-input-container" style="display: none;">
                        <label for="prefill-input" class="prefill-label">Prefill:</label>
                        <input 
                            type="text" 
                            id="prefill-input" 
                            class="prefill-input-field"
                            placeholder='e.g., "Sure, " or "I cannot..."'
                        />
                    </div>
                    <div id="difflens-input-container" class="difflens-input-container" style="display: none;">
                        <label for="analysis-model-input" class="difflens-label">Diff Model:</label>
                        <select id="analysis-model-input" class="difflens-model-select">
                            <option value="">None</option>
                            <option value="meta-llama/Llama-3.1-8B-Instruct">Llama-3.1-8B-Instruct</option>
                            <option value="google/gemma-2-2b-it">Gemma-2-2B-IT</option>
                            <option value="google/gemma-3-1b-it">Gemma-3-1B-IT</option>
                        </select>
                        <button class="difflens-apply-btn" onclick="triggerDiffLensAnalysis()">Apply Diff</button>
                    </div>
                </div>
                <button id="send-btn" onclick="handleSendButton()">
                    <svg id="send-icon" width="20" height="20" viewBox="0 0 20 20" fill="none">
                        <path d="M2 10L18 2L10 18L8 11L2 10Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <svg id="stop-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" style="display: none;">
                        <rect x="5" y="5" width="10" height="10" fill="currentColor" stroke="none"/>
                    </svg>
                </button>
                <div class="model-selector-inline">
                    <select id="model-select" onchange="saveCurrentConversation()">
                            <option value="meta-llama/Llama-3.1-8B-Instruct">Llama-3.1-8B-Instruct</option>
                            <option value="google/gemma-2-2b-it">Gemma-2-2B-IT</option>
                            <option value="google/gemma-3-1b-it">Gemma-3-1B-IT</option>
                        </select>
                    <input type="number" id="temperature-input" min="0" max="2" step="0.1" value="1.0" title="Temperature">
                    </div>
                    </div>
                    </div>
                </div>

        <!-- Right Sidebar (Token Inspector) -->
        <aside class="inspector-sidebar" id="inspector-sidebar">
            <div class="inspector-header">
                <h3>Token Inspector</h3>
                <button class="inspector-close-btn" onclick="toggleRightSidebar()" title="Close">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M12 4L4 12M4 4L12 12" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                </button>
                    </div>
            
            <div class="inspector-content" id="inspector-content">
                <!-- Empty state -->
                <div class="inspector-empty" id="inspector-empty">
                    <svg width="48" height="48" viewBox="0 0 48 48" fill="none">
                        <circle cx="24" cy="24" r="20" stroke="currentColor" stroke-width="2" opacity="0.3"/>
                        <path d="M24 16V24M24 32H24.02" stroke="currentColor" stroke-width="3" stroke-linecap="round"/>
                    </svg>
                    <p>Click any token to inspect</p>
                </div>

                <!-- Token details (shown when token is selected) -->
                <div class="inspector-token-details hidden" id="inspector-token-details">
                    <div class="inspector-section">
                        <h4>Selected Token</h4>
                    <div class="rule-info-banner" id="inspector-rule-banner" style="display: none;"></div>
                        <div class="inspector-token-display" id="inspector-current-token"></div>
            </div>

                    <div class="inspector-section">
                        <h4>Top Alternatives</h4>
                        <div class="inspector-alternatives" id="inspector-alternatives"></div>
            </div>
                    
                    <div class="inspector-section">
                        <h4>Inject Text at Position</h4>
                        <textarea
                            id="inspector-inject-input"
                            class="inspector-inject-input"
                            rows="3"
                            placeholder="Type text to inject at this position..."
                        ></textarea>
                        <p style="font-size: 0.75rem; color: var(--text-secondary); margin-top: 4px;">Text will be inserted here and generation will continue from this point.</p>
            </div>
                    
                    <div class="inspector-actions">
                        <button class="inspector-btn primary" id="inspector-inject-btn">
                            <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
                                <path d="M7 1V7M7 7H13M7 7L2 12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                            </svg>
                            Inject and Regenerate
                        </button>
                        <button class="inspector-btn secondary" id="inspector-logit-lens-btn">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M2 14L2 2L14 2" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                                <path d="M4 10L6.5 7L9 9.5L12 5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                                <circle cx="12" cy="5" r="1.2" fill="currentColor"/>
                            </svg>
                            Open Logit Lens
                        </button>
                    </div>
                </div>
            </div>
            
            <!-- Hidden sync fields for backward compatibility -->
            <input type="hidden" id="view-select" value="token">
            <input type="hidden" id="highlight-mode-select" value="probability">
            <input type="hidden" id="analysis-model-select" value="">
            <input type="hidden" id="system-prompt-input" value="">
        </aside>
    </div>

    <!-- Simplified Hover-Only Tooltip -->
    <div id="token-tooltip" class="token-tooltip-hover hidden">
            <div id="tooltip-current-token"></div>
        <div class="tooltip-alternatives-mini" id="tooltip-alternatives">
            <!-- Top 2 alternatives will be inserted here -->
            </div>
        <div class="tooltip-hint">Click for details →</div>
    </div>

    <!-- System Prompt Modal -->
    <div id="system-prompt-modal" class="modal-overlay" style="display: none;" onclick="if(event.target === this) closeSystemPromptModal()">
        <div class="modal-content">
            <div class="modal-header">
                <h3>System Prompt</h3>
                <button class="modal-close-btn" onclick="closeSystemPromptModal()">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                        <path d="M15 5L5 15M5 5L15 15" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                </button>
            </div>
            <div class="modal-body">
                <textarea 
                    id="system-prompt-modal-textarea" 
                    placeholder="e.g., You are a helpful assistant..."
                    rows="8"
                ></textarea>
            </div>
            <div class="modal-footer">
                <button class="modal-btn-secondary" onclick="closeSystemPromptModal()">Cancel</button>
                <button class="modal-btn-primary" onclick="saveSystemPromptFromModal()">Save</button>
                <button class="modal-btn-primary" onclick="saveSystemPromptAsDefault()">Save as Default</button>
            </div>
        </div>
    </div>
    
    <!-- Sampling Settings Modal -->
    <div id="sampling-modal" class="modal-overlay" style="display: none;" onclick="if(event.target === this) closeSamplingModal()">
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header">
                <h3>Sampling Settings</h3>
                <button class="modal-close-btn" onclick="closeSamplingModal()">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                        <path d="M15 5L5 15M5 5L15 15" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                </button>
            </div>
            <div class="modal-body" style="padding: 20px;">
                <div style="margin-bottom: 20px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px;">Top-K Filtering</label>
                    <input 
                        type="number" 
                        id="sampling-top-k" 
                        min="0" 
                        max="1000" 
                        step="1" 
                        value="0"
                        style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-primary); color: var(--text-primary);"
                    />
                    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 4px;">Keep only top K tokens (0 = disabled)</p>
                </div>
                
                <div style="margin-bottom: 20px;">
                    <label style="display: block; font-weight: 600; margin-bottom: 8px;">Top-P (Nucleus Sampling)</label>
                    <input 
                        type="number" 
                        id="sampling-top-p" 
                        min="0" 
                        max="1" 
                        step="0.01" 
                        value="1.0"
                        style="width: 100%; padding: 8px; border: 1px solid var(--border-color); border-radius: 4px; background: var(--bg-primary); color: var(--text-primary);"
                    />
                    <p style="font-size: 0.85rem; color: var(--text-secondary); margin-top: 4px;">Cumulative probability threshold (1.0 = disabled)</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="modal-btn-secondary" onclick="resetSamplingSettings()">Reset to Defaults</button>
                <button class="modal-btn-primary" onclick="saveSamplingSettings()">Save</button>
            </div>
        </div>
    </div>
    
    <!-- Automation Rules Modal -->
    <div id="rules-modal" class="modal-overlay" style="display: none;" onclick="if(event.target === this) closeRulesModal()">
        <div class="modal-content rules-modal-content">
            <div class="modal-header">
                <h3>Auto Rules</h3>
                <button class="modal-close-btn" onclick="closeRulesModal()">
                    <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                        <path d="M15 5L5 15M5 5L15 15" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                </button>
            </div>
            <div class="modal-body rules-modal-body">
                <div class="rules-toolbar">
                    <div class="rules-copy">
                        <h4>Automate resampling and replacements</h4>
                        <p>Create rules that watch tokens during generation and react when they match your criteria.</p>
                    </div>
                    <button class="modal-btn-primary" onclick="addNewRule()">Add Rule</button>
                </div>
                <div id="rules-list" class="rules-list"></div>
            </div>
            <div class="modal-footer rules-modal-footer">
                <button class="modal-btn-secondary" onclick="resetRules()">Clear All</button>
                <button class="modal-btn-primary" onclick="closeRulesModal()">Done</button>
            </div>
        </div>
    </div>
        
    <!-- Logit Lens Modal -->
    <div id="logit-lens-modal" class="logit-lens-modal hidden">
        <div class="logit-lens-overlay" onclick="closeLogitLensModal()"></div>
        <div class="logit-lens-content">
            <div class="logit-lens-header">
                <h2>Logit Lens Analysis: <span id="logit-lens-token"></span></h2>
                <div class="logit-lens-controls">
                    <div class="view-toggle">
                        <button class="toggle-btn active" data-view="heatmap" onclick="switchLogitLensView('heatmap')">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <rect x="2" y="2" width="3" height="3" fill="currentColor"/>
                                <rect x="6" y="2" width="3" height="3" fill="currentColor"/>
                                <rect x="10" y="2" width="3" height="3" fill="currentColor"/>
                                <rect x="2" y="6" width="3" height="3" fill="currentColor"/>
                                <rect x="6" y="6" width="3" height="3" fill="currentColor"/>
                                <rect x="10" y="6" width="3" height="3" fill="currentColor"/>
                                <rect x="2" y="10" width="3" height="3" fill="currentColor"/>
                                <rect x="6" y="10" width="3" height="3" fill="currentColor"/>
                                <rect x="10" y="10" width="3" height="3" fill="currentColor"/>
                            </svg>
                            Heatmap
                        </button>
                        <button class="toggle-btn" data-view="chart" onclick="switchLogitLensView('chart')">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M2 12L5 8L8 10L14 2" stroke="currentColor" stroke-width="2" fill="none"/>
                            </svg>
                            Chart
                        </button>
            </div>
                    <button class="close-btn" onclick="closeLogitLensModal()">
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                            <path d="M5 5L15 15M5 15L15 5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                </svg>
            </button>
            </div>
        </div>
            <div class="logit-lens-body">
                <div class="logit-lens-loading">
                    <div class="spinner"></div>
                    <p>Analyzing layers...</p>
                </div>
                <div class="logit-lens-viz hidden">
                    <!-- Heatmap View -->
                    <div id="logit-lens-heatmap" class="viz-container active">
                        <div class="heatmap-scroll">
                            <div id="heatmap-canvas-container"></div>
                        </div>
                    </div>
                    <!-- Chart View -->
                    <div id="logit-lens-chart" class="viz-container">
                        <div class="chart-content-scroll">
                            <div class="chart-controls">
                                <div class="token-search-container">
                                    <input type="text" 
                                           id="chart-token-search" 
                                           class="token-search-input-chart" 
                                           placeholder="Search for tokens to add..."
                                           autocomplete="off">
                                    <div id="chart-search-results" class="token-search-results-chart"></div>
                                </div>
                                <div class="active-tokens" id="active-chart-tokens">
                                    <!-- Active token chips will be added here -->
                                </div>
                            </div>
                            <div class="chart-canvas-container">
                                <canvas id="probability-chart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Custom Tooltip for Logit Lens -->
    <div id="logit-lens-tooltip" class="logit-lens-tooltip">
        <div class="tooltip-header" id="tooltip-header"></div>
        <div id="tooltip-body"></div>
    </div>

    <script>
        let isGenerating = false;
        let currentAbortController = null;
        // conversationHistory is now derived from messageTree
        let messageTree = {}; 
        let currentLeafId = null;
        let currentConversationId = null;
        let conversations = {};
        let selectedTokenElement = null;
        let currentView = 'token';
        let currentHighlightMode = 'probability';  // 'probability' or 'rank'
        let generationRules = [];
        let currentSystemPrompt = '';  // Current conversation's system prompt
        let systemPromptExpanded = true;  // Track bubble collapse state
        let samplingSettings = {
            top_k: 0,
            top_p: 1.0
        };
        
        // Helper to generate UUIDs
        function uuidv4() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        // System Prompt Functions
        function updateSystemPrompt() {
            const systemPromptInput = document.getElementById('system-prompt-input');
            currentSystemPrompt = systemPromptInput.value.trim();
            
            // Update the bubble display
            updateSystemPromptBubble();
            
            // Save to conversation
            saveCurrentConversation();
        }
        
        function openSystemPromptModal() {
            const modal = document.getElementById('system-prompt-modal');
            const textarea = document.getElementById('system-prompt-modal-textarea');
            
            // Load current system prompt into modal
            textarea.value = currentSystemPrompt;
            
            // Show modal
            modal.style.display = 'flex';
        }
        
        function closeSystemPromptModal() {
            const modal = document.getElementById('system-prompt-modal');
            modal.style.display = 'none';
        }
        
        function openSamplingModal() {
            // Load current settings into the modal
            document.getElementById('sampling-top-k').value = samplingSettings.top_k;
            document.getElementById('sampling-top-p').value = samplingSettings.top_p;
            
            const modal = document.getElementById('sampling-modal');
            modal.style.display = 'flex';
        }
        
        function closeSamplingModal() {
            const modal = document.getElementById('sampling-modal');
            modal.style.display = 'none';
        }
        
        function saveSamplingSettings() {
            samplingSettings.top_k = parseInt(document.getElementById('sampling-top-k').value) || 0;
            samplingSettings.top_p = parseFloat(document.getElementById('sampling-top-p').value) || 1.0;
            
            // Persist to localStorage
            localStorage.setItem('tokenlens_sampling_settings', JSON.stringify(samplingSettings));
            
            closeSamplingModal();
        }
        
        function resetSamplingSettings() {
            samplingSettings = {
                top_k: 0,
                top_p: 1.0
            };
            
            // Update UI
            document.getElementById('sampling-top-k').value = 0;
            document.getElementById('sampling-top-p').value = 1.0;
            
            // Persist
            localStorage.setItem('tokenlens_sampling_settings', JSON.stringify(samplingSettings));
        }
        
        function loadSamplingSettings() {
            try {
                const stored = localStorage.getItem('tokenlens_sampling_settings');
                if (stored) {
                    samplingSettings = JSON.parse(stored);
                }
            } catch (error) {
                console.error('Failed to load sampling settings:', error);
            }
        }
        
        function saveSystemPromptFromModal() {
            const textarea = document.getElementById('system-prompt-modal-textarea');
            currentSystemPrompt = textarea.value.trim();
            
            // Update hidden sync field
            const systemPromptInput = document.getElementById('system-prompt-input');
            if (systemPromptInput) {
                systemPromptInput.value = currentSystemPrompt;
            }
            
            // Update the bubble display
            updateSystemPromptBubble();
            
            // Save to conversation
            saveCurrentConversation();
            
            // Close modal
            closeSystemPromptModal();
        }
        
        function saveSystemPromptAsDefault() {
            const textarea = document.getElementById('system-prompt-modal-textarea');
            const promptValue = textarea.value.trim();
            
            // Save to localStorage as default
            localStorage.setItem('tokenlens_default_system_prompt', promptValue);
            
            // Also save as current
            currentSystemPrompt = promptValue;
            
            // Update hidden sync field
            const systemPromptInput = document.getElementById('system-prompt-input');
            if (systemPromptInput) {
                systemPromptInput.value = currentSystemPrompt;
            }
            
            // Update the bubble display
            updateSystemPromptBubble();
            
            // Save to conversation
            saveCurrentConversation();
            
            // Close modal
            closeSystemPromptModal();
        }
        
        function updateSystemPromptBubble() {
            const bubble = document.getElementById('system-prompt-bubble');
            const content = document.getElementById('system-prompt-content');
            
            if (currentSystemPrompt) {
                bubble.style.display = 'block';
                content.textContent = currentSystemPrompt;
            } else {
                bubble.style.display = 'none';
            }
        }
        
        function toggleSystemPromptBubble() {
            const content = document.getElementById('system-prompt-content');
            const toggle = document.getElementById('system-prompt-toggle');
            
            systemPromptExpanded = !systemPromptExpanded;
            
            if (systemPromptExpanded) {
                content.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                toggle.textContent = '▼';
            } else {
                content.classList.add('collapsed');
                toggle.classList.add('collapsed');
                toggle.textContent = '▶';
            }
        }
        
        function saveDefaultSystemPrompt() {
            const systemPromptInput = document.getElementById('system-prompt-input');
            const prompt = systemPromptInput.value.trim();
            
            if (prompt) {
                localStorage.setItem('tokenlens_default_system_prompt', prompt);
                alert('Default system prompt saved!');
            } else {
                localStorage.removeItem('tokenlens_default_system_prompt');
                alert('Default system prompt cleared!');
            }
        }
        
        function loadDefaultSystemPrompt() {
            const defaultPrompt = localStorage.getItem('tokenlens_default_system_prompt');
            if (defaultPrompt) {
                const systemPromptInput = document.getElementById('system-prompt-input');
                systemPromptInput.value = defaultPrompt;
                currentSystemPrompt = defaultPrompt;
                updateSystemPromptBubble();
            }
        }

        // Get linear thread from root to current leaf
        function getActiveThread() {
            if (!currentLeafId || !messageTree[currentLeafId]) return [];
            
            const thread = [];
            let currentNodeId = currentLeafId;
            
            while (currentNodeId && messageTree[currentNodeId]) {
                thread.unshift(messageTree[currentNodeId]);
                currentNodeId = messageTree[currentNodeId].parentId;
            }
            
            return thread;
        }
        
        // Get conversation ID from URL path
        function getConversationIdFromUrl() {
            const path = window.location.pathname;
            const match = path.match(/\/chat\/([^\/]+)/);
            const id = match ? match[1] : null;
            console.log('Parsed conversation ID from URL:', path, '=>', id);
            return id;
        }
        
        const urlConversationId = getConversationIdFromUrl();

        function handleKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                if (!isGenerating) {
                sendMessage();
                }
            }
        }
        
        function handleSendButton() {
            if (isGenerating) {
                stopGeneration();
            } else {
                sendMessage();
            }
        }
        
        function updateSendButton() {
            const sendIcon = document.getElementById('send-icon');
            const stopIcon = document.getElementById('stop-icon');
            
            if (isGenerating) {
                sendIcon.style.display = 'none';
                stopIcon.style.display = 'block';
            } else {
                sendIcon.style.display = 'block';
                stopIcon.style.display = 'none';
            }
        }
        
        function stopGeneration() {
            if (currentAbortController) {
                currentAbortController.abort();
                currentAbortController = null;
            }
            isGenerating = false;
            const sendBtn = document.getElementById('send-btn');
            sendBtn.disabled = false;
            updateSendButton();
        }

        function clearChat() {
            const messagesContainer = document.getElementById('messages-container');
            messagesContainer.innerHTML = `
                <!-- System Prompt Bubble (hidden by default) -->
                <div class="system-prompt-bubble" id="system-prompt-bubble" style="display: none;">
                    <div class="system-prompt-header" onclick="toggleSystemPromptBubble()">
                        <span class="system-prompt-label">System</span>
                        <span class="system-prompt-toggle" id="system-prompt-toggle">▼</span>
                    </div>
                    <div class="system-prompt-content" id="system-prompt-content">
                        <!-- System prompt text will be inserted here -->
                    </div>
                </div>
                
                <div class="welcome-message">
                    <h2>Welcome to Scope</h2>
                    <p>Chat with AI and see token probabilities in real-time</p>
                </div>
            `;
            messageTree = {};
            currentLeafId = null;
            
            // Clear inspector content
            localStorage.removeItem('tokenlens_inspector_content');
            localStorage.removeItem('tokenlens_selected_token');
            const inspectorEmpty = document.getElementById('inspector-empty');
            const inspectorDetails = document.getElementById('inspector-token-details');
            if (inspectorEmpty && inspectorDetails) {
                inspectorEmpty.style.display = 'flex';
                inspectorDetails.classList.add('hidden');
            }
            if (selectedTokenElement) {
                selectedTokenElement.classList.remove('token-selected');
                selectedTokenElement = null;
            }
            
            // Load default system prompt for new conversation
            loadDefaultSystemPrompt();
            
            saveCurrentConversation();
        }

        function sendMessage() {
            if (isGenerating) return;
            
            const input = document.getElementById('user-input');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Get prefill text if provided
            const prefillInput = document.getElementById('prefill-input');
            const prefillText = prefillInput ? (prefillInput.value.trim() || null) : null;
            
            // Clear inputs
            input.value = '';
            input.style.height = 'auto';
            if (prefillInput) {
                prefillInput.value = '';
                localStorage.setItem('tokenlens_prefill_text', '');
            }
            
            // Remove welcome message if present
            const welcomeMsg = document.querySelector('.welcome-message');
            if (welcomeMsg) {
                welcomeMsg.remove();
            }
            
            // Create User Node
            const nodeId = uuidv4();
            const newNode = {
                id: nodeId,
                parentId: currentLeafId,
                childrenIds: [],
                role: 'user',
                content: message,
                timestamp: Date.now()
            };
            
            // Update parent's children
            if (currentLeafId && messageTree[currentLeafId]) {
                messageTree[currentLeafId].childrenIds.push(nodeId);
            }
            
            // Add to tree and update leaf
            messageTree[nodeId] = newNode;
            currentLeafId = nodeId;
            
                // Display user message
            // We need to pass the node to enable navigation UI later
            addUserMessage(newNode);
                
                // Start generating assistant response (with prefill if provided)
                generateResponse(prefillText);
        }

        function addUserMessage(nodeOrContent, scroll = true) {
            const content = typeof nodeOrContent === 'object' ? nodeOrContent.content : nodeOrContent;
            const node = typeof nodeOrContent === 'object' ? nodeOrContent : null;
            
            const messagesContainer = document.getElementById('messages-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user-message';
            if (node) {
                messageDiv.dataset.nodeId = node.id;
            }
            
            // Add navigation and edit controls if node exists
            let controlsHtml = '';
            if (node) {
                // Check if parent has multiple children (siblings of this node)
                const parent = node.parentId ? messageTree[node.parentId] : null;
                // If it's a root node (no parent), we check roots (we need to track roots or iterate)
                // For simplicity, let's assume we can find siblings via parent. 
                // If no parent, find all nodes with no parent.
                
                let siblings = [];
                if (parent) {
                    siblings = parent.childrenIds;
                } else {
                    // Find all root nodes
                    siblings = Object.values(messageTree).filter(n => !n.parentId).map(n => n.id);
                }
                
                const currentIndex = siblings.indexOf(node.id);
                const siblingsCount = siblings.length;
                
                // Edit button first
                controlsHtml += `
                    <button class="edit-msg-btn" onclick="enableEditMode('${node.id}')" title="Edit message">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                        </svg>
                    </button>
                `;
                
                if (siblingsCount > 1) {
                    controlsHtml += `
                        <div class="message-nav">
                            <button class="nav-btn prev" ${currentIndex === 0 ? 'disabled' : ''} onclick="navigateSibling('${node.id}', -1)">❮</button>
                            <span class="nav-count">${currentIndex + 1}/${siblingsCount}</span>
                            <button class="nav-btn next" ${currentIndex === siblingsCount - 1 ? 'disabled' : ''} onclick="navigateSibling('${node.id}', 1)">❯</button>
                </div>
            `;
            }
        }
        
            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-text">${escapeHtml(content)}</div>
                    ${controlsHtml ? `<div class="message-controls">${controlsHtml}</div>` : ''}
                </div>
            `;
            messagesContainer.appendChild(messageDiv);
            if (scroll) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }

        async function generateResponse(prefillText = null, injectedTokenIndex = null) {
            console.log('generateResponse started', {prefillText, injectedTokenIndex, currentLeafId});
            isGenerating = true;
            updateSendButton();
            
            // Clear preRenderTokens if this is not an injection
            if (injectedTokenIndex === null) {
                window.preRenderTokens = null;
            }
            
            const messagesContainer = document.getElementById('messages-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant-message';
            
            // Create Assistant Node
            const nodeId = uuidv4();
            messageDiv.dataset.nodeId = nodeId;
            console.log('Created new node ID:', nodeId);
            
            const newNode = {
                id: nodeId,
                parentId: currentLeafId,
                childrenIds: [],
                role: 'assistant',
                content: '',
                tokens: [],
                model: document.getElementById('model-select').value,
                temperature: parseFloat(document.getElementById('temperature-input')?.value) || 1.0,
                timestamp: Date.now()
            };
            
            // Update parent
            if (currentLeafId && messageTree[currentLeafId]) {
                messageTree[currentLeafId].childrenIds.push(nodeId);
                messageTree[currentLeafId].lastSelectedChildId = nodeId; // Make this the active path
            }
            
            // Add to tree and update leaf
            messageTree[nodeId] = newNode;
            currentLeafId = nodeId;
            
            // Add navigation controls
            const controlsHtml = `
                <div class="message-controls">
                    <button class="regenerate-btn" onclick="regenerateFromNode('${newNode.parentId}')" title="Regenerate response">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.3"/>
                        </svg>
                    </button>
                    <div class="message-nav" style="display:none">
                        <button class="nav-btn prev">❮</button>
                        <span class="nav-count">1/1</span>
                        <button class="nav-btn next">❯</button>
                    </div>
                </div>
            `;

            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-tokens"></div>
                    ${controlsHtml}
                </div>
            `;
            messagesContainer.appendChild(messageDiv);
            
            const tokensContainer = messageDiv.querySelector('.message-tokens');
            const modelName = newNode.model;
            
            let assistantResponse = '';
            let responseTokens = [];
            let prefillTokenCount = 0;
            
            console.log('=== GENERATION SETUP ===');
            console.log('Has prefillText:', !!prefillText, 'length:', prefillText?.length);
            console.log('Injected token index:', injectedTokenIndex);
            console.log('Has preRenderTokens:', !!window.preRenderTokens);
            
            // If we have pre-render tokens (from injection), render them immediately with original colors
            if (window.preRenderTokens && window.preRenderTokens.length > 0) {
                console.log('Pre-rendering', window.preRenderTokens.length, 'tokens before injection');
                for (const tokenData of window.preRenderTokens) {
                    assistantResponse += tokenData.token;
                    responseTokens.push(tokenData);
                    
                    // Add token to UI immediately with original styling (no gray placeholder)
                    const tokenSpan = addToken(
                        tokensContainer,
                        tokenData.token,
                        tokenData.probability,
                        tokenData.rank,
                        tokenData.vocab_size,
                        tokenData.top_alternatives,
                        responseTokens.length - 1,
                        null,
                        tokenData.model,
                        tokenData.temperature,
                        tokenData.token_id,
                        tokenData.rule_applied || null
                    );
                    tokenSpan.dataset.nodeId = nodeId;
                }
                
                // Clear the pre-render tokens
                window.preRenderTokens = null;
            }
            
            // If we have prefill text, show a placeholder for the remaining part only
            if (prefillText) {
                const remainingPrefillText = prefillText.substring(assistantResponse.length);
                
                console.log('Prefill setup:', {
                    fullPrefillLength: prefillText.length,
                    alreadyRendered: assistantResponse.length,
                    remainingLength: remainingPrefillText.length,
                    isInjection: injectedTokenIndex !== null
                });
                
                if (remainingPrefillText.length > 0) {
                    // Show placeholder for the remaining prefill part
                    const placeholderSpan = document.createElement('span');
                    placeholderSpan.className = 'token prefill-placeholder';
                    placeholderSpan.textContent = remainingPrefillText;
                    placeholderSpan.style.backgroundColor = 'hsl(0, 0%, 80%)';
                    tokensContainer.appendChild(placeholderSpan);
                    console.log('Created prefill placeholder for', remainingPrefillText.length, 'chars');
                }
                
                assistantResponse = prefillText; // Full prefill is in response
            }
            
            try {
                // Create abort controller for this generation
                currentAbortController = new AbortController();
                
                // Use fetch with streaming for POST requests
                const temperature = newNode.temperature;
                
                // Get conversation history from tree
                const threadNodes = getActiveThread();
                console.log('Active thread nodes:', threadNodes.length);
                
                // The API expects [ {role, content}, ... ].
                // The last node in threadNodes is our new assistant node (empty).
                // We should send everything *before* it.
                const messagesToSend = threadNodes.slice(0, -1).map(n => ({
                    role: n.role,
                    content: n.content
                }));
                
                // Prepend system prompt if set
                if (currentSystemPrompt) {
                    messagesToSend.unshift({
                        role: 'system',
                        content: currentSystemPrompt
                    });
                }
                
                console.log('Messages to send:', messagesToSend);

                const requestBody = {
                    messages: messagesToSend,
                    model: modelName,
                    temperature: temperature
                };
                
                if (generationRules && generationRules.length > 0) {
                    requestBody.rules = generationRules;
                }
                
                if (prefillText) {
                    requestBody.prefill = prefillText;
                }
                
                // Add sampling settings
                if (samplingSettings) {
                    requestBody.sampling = samplingSettings;
                }
                
                console.log('Sending request...', requestBody);
                const response = await fetch('/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody),
                    signal: currentAbortController.signal
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                let streamTokenIndex = 0; // Track position in the stream (not responseTokens.length)
                
                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    
                    // Decode the chunk
                    const chunk = decoder.decode(value, {stream: true});
                    
                    // Parse SSE format (data: {...}\n\n)
                    const lines = chunk.split('\n');
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const jsonStr = line.substring(6);
                            try {
                                const data = JSON.parse(jsonStr);
                                
                                if (data.type === 'token') {
                                    const isPromptToken = data.is_prompt_token || false;
                                    const isPrefillToken = data.is_prefill_token || false;
                                    
                                    // Skip prompt tokens entirely
                                    if (isPromptToken) {
                                        continue;
                                    }
                                    
                                    console.log('Stream token:', {
                                        streamTokenIndex,
                                        token: data.token.substring(0, 10),
                                        isPrefillToken,
                                        injectedTokenIndex,
                                        willSkip: injectedTokenIndex !== null && streamTokenIndex < injectedTokenIndex
                                    });
                                    
                                    // Check if this token was already pre-rendered (for injection)
                                    // injectedTokenIndex tells us where the injected token is
                                    // Tokens before that index in the STREAM are already rendered
                                    const isPreRendered = injectedTokenIndex !== null && streamTokenIndex < injectedTokenIndex;
                                    
                                    if (isPreRendered) {
                                        console.log('Skipping pre-rendered token at stream index', streamTokenIndex);
                                        streamTokenIndex++; // Increment even though we skip
                                        continue;
                                    }
                                    
                                    // This token will be added to the UI
                                    // Use responseTokens.length for its index in the final array
                                    const tokenIdx = responseTokens.length;
                                    
                                    // For prefill tokens (not pre-rendered), they're already in assistantResponse
                                    // For generated tokens, add them to response
                                    if (!isPrefillToken) {
                                        assistantResponse += data.token;
                                    }
                                    
                                    const tokenData = {
                                        token: data.token,
                                        token_id: data.token_id,
                                        probability: data.probability,
                                        rank: data.rank,
                                        vocab_size: data.vocab_size,
                                        top_alternatives: data.top_alternatives,
                                        model: modelName,
                                        temperature: temperature,
                                        is_prefill_token: isPrefillToken,
                                        is_prompt_token: isPromptToken,
                                        is_injected: injectedTokenIndex !== null && streamTokenIndex === injectedTokenIndex,
                                        rule_applied: data.rule_applied || null
                                    };
                                    
                                    responseTokens.push(tokenData);
                                    newNode.content = assistantResponse;
                                    newNode.tokens = responseTokens;
                                    
                                    // On first prefill token, remove placeholder
                                    // For injection: remove when we reach the injected token
                                    // For regular prefill: remove on first prefill token
                                    const shouldRemovePlaceholder = isPrefillToken && (
                                        (injectedTokenIndex !== null && streamTokenIndex === injectedTokenIndex) ||
                                        (injectedTokenIndex === null && prefillTokenCount === 0)
                                    );
                                    
                                    console.log('Placeholder removal check:', {
                                        isPrefillToken,
                                        streamTokenIndex,
                                        injectedTokenIndex,
                                        prefillTokenCount,
                                        shouldRemovePlaceholder
                                    });
                                    
                                    if (shouldRemovePlaceholder) {
                                        const placeholder = tokensContainer.querySelector('.prefill-placeholder');
                                        if (placeholder) {
                                            placeholder.remove();
                                            console.log('✓ Removed prefill placeholder at stream index', streamTokenIndex);
                                        } else {
                                            console.log('✗ No placeholder found to remove');
                                        }
                                    }
                                    
                                    // Add token to UI
                                    const tokenSpan = addToken(
                                        tokensContainer,
                                        data.token,
                                        data.probability,
                                        data.rank,
                                        data.vocab_size,
                                        data.top_alternatives,
                                        tokenIdx,
                                        null,
                                        modelName,
                                        temperature,
                                        data.token_id,
                                        data.rule_applied || null
                                    );
                                    tokenSpan.dataset.nodeId = nodeId;
                                    
                                    // Apply border styling to injected tokens only
                                    if (isPrefillToken) {
                                        // For injection: tokens from injectedTokenIndex onward get the border
                                        // For regular prefill (no injection): all prefill tokens get borders
                                        if (injectedTokenIndex === null || streamTokenIndex >= injectedTokenIndex) {
                                            tokenSpan.classList.add('prefilled-token');
                                            console.log('Applied border to prefill token at stream index', streamTokenIndex);
                                        }
                                        prefillTokenCount++;
                                    }
                                    
                                    streamTokenIndex++; // Increment for next token
                                    
                                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                } else if (data.type === 'done') {
                                    console.log('Generation done');
                                    // Finalize node update
                                    newNode.content = assistantResponse;
                                    newNode.tokens = responseTokens;
                                    
                                    saveCurrentConversation(true); // Update timestamp for new message
                                    isGenerating = false;
                                    currentAbortController = null;
                                    window.preRenderTokens = null; // Clean up
                                    updateSendButton();
                                    
                                    // Only update navigation controls if there are actual siblings
                                    // (Skip for injection to avoid refresh effect)
                                    const parentNode = newNode.parentId ? messageTree[newNode.parentId] : null;
                                    const hasSiblings = parentNode && parentNode.childrenIds && parentNode.childrenIds.length > 1;
                                    if (hasSiblings) {
                                    updateMessageControls(nodeId);
                                    }
                                    
                                } else if (data.type === 'error') {
                                    console.error('Server Error:', data.message);
                                    tokensContainer.innerHTML += `<div class="error-message">Error: ${escapeHtml(data.message)}</div>`;
                                    isGenerating = false;
                                    currentAbortController = null;
                                    updateSendButton();
                                }
                            } catch (e) {
                                // Skip invalid JSON
                                console.warn('JSON parse error in chunk:', e);
                            }
                        }
                    }
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('Generation stopped by user');
                    // Save partial response
                    newNode.content = assistantResponse;
                    newNode.tokens = responseTokens;
                    saveCurrentConversation(true);
                } else {
                console.error('Fetch/Stream error:', error);
                tokensContainer.innerHTML += `<div class="error-message">Connection error: ${error.message}. Please try again.</div>`;
                }
                isGenerating = false;
                currentAbortController = null;
                window.preRenderTokens = null; // Clean up
                updateSendButton();
            }
        }

        function addToken(container, token, probability, rank, vocabSize, topAlternatives, tokenIndex, messageIndex = null, model = null, temperature = null, tokenId = null, ruleApplied = null) {
            const tokenSpan = document.createElement('span');
            tokenSpan.className = 'token';
            
            // Store token data for context menu
            tokenSpan.dataset.token = token;
            tokenSpan.dataset.probability = probability;
            tokenSpan.dataset.rank = rank;
            tokenSpan.dataset.vocabSize = vocabSize;
            tokenSpan.dataset.topAlternatives = JSON.stringify(topAlternatives || []);
            tokenSpan.dataset.tokenIndex = tokenIndex;
            // tokenSpan.dataset.messageIndex = messageIndex !== null ? messageIndex : conversationHistory.length; // Deprecated
            tokenSpan.dataset.model = model || document.getElementById('model-select')?.value || 'Unknown';
            tokenSpan.dataset.temperature = temperature !== null ? temperature : (parseFloat(document.getElementById('temperature-input')?.value) || 1.0);
            tokenSpan.dataset.tokenId = (tokenId !== null && tokenId !== undefined) ? tokenId : '';
            if (ruleApplied) {
                tokenSpan.dataset.ruleApplied = JSON.stringify(ruleApplied);
            } else {
                delete tokenSpan.dataset.ruleApplied;
            }
            
            // Color based on probability or rank (or gray if in DiffLens mode)
            if (currentView === 'diff') {
                // In DiffLens mode, new tokens should be gray until analyzed
                tokenSpan.style.backgroundColor = 'hsl(0, 0%, 75%)';
                tokenSpan.style.color = 'hsl(0, 0%, 30%)';
                tokenSpan.classList.add('difflens-neutral');
            } else {
            const color = getColorForProb(probability || 0, rank, vocabSize);
            tokenSpan.style.backgroundColor = color;
            }
            
            // Handle special tokens - check for any whitespace, not just exact matches
            let displayToken = token;
            let isWhitespace = false;
            let isSpecialToken = false;
            
            // Check for special tokens (like <end_of_turn>, <start_of_turn>, <|eot_id|>, etc.)
            if (token.startsWith('<') && token.endsWith('>')) {
                tokenSpan.classList.add('special-token');
                isSpecialToken = true;
            }
            // Also check for pipe-delimited special tokens like <|eot_id|>
            else if (token.includes('<|') || token.includes('|>')) {
                tokenSpan.classList.add('special-token');
                isSpecialToken = true;
            }
            // Check if token contains newlines
            else if (token.includes('\n')) {
                // Count newlines
                const newlineCount = (token.match(/\n/g) || []).length;
                displayToken = newlineCount === 1 ? '↵' : `↵×${newlineCount}`;
                tokenSpan.classList.add('newline-token');
                isWhitespace = true;
            } 
            // Check if token is only spaces
            else if (token === ' ' || /^\s+$/.test(token)) {
                tokenSpan.classList.add('space-token');
                isWhitespace = true;
            }
            // Check for tab characters
            else if (token.includes('\t')) {
                const tabCount = (token.match(/\t/g) || []).length;
                displayToken = tabCount === 1 ? '→' : `→×${tabCount}`;
                tokenSpan.classList.add('space-token');
                isWhitespace = true;
            }
            
            // Use textContent to prevent any HTML rendering issues
            tokenSpan.textContent = displayToken;
            
            // Add hover handler for simplified tooltip
            tokenSpan.addEventListener('mouseenter', function(e) {
                showSimplifiedTooltip(tokenSpan);
            });
            
            tokenSpan.addEventListener('mouseleave', function(e) {
                hideSimplifiedTooltip();
            });
            
            // Add click handler to open inspector
            tokenSpan.addEventListener('click', function(e) {
                e.stopPropagation();
                openInspector(tokenSpan);
            });
            
            if (ruleApplied) {
                tokenSpan.classList.add('token-rule-adjusted');
            }
            
            container.appendChild(tokenSpan);
            
            // Add actual newline break if token contains newlines
            if (token.includes('\n')) {
                const newlineCount = (token.match(/\n/g) || []).length;
                for (let i = 0; i < newlineCount; i++) {
                    container.appendChild(document.createElement('br'));
                }
            }
            
            if (currentView === 'text') {
                updateTokenForView(tokenSpan, 'text');
            }
            
            return tokenSpan;
        }

        function getColorForProb(probability, rank = null, vocabSize = null) {
            // Color based on current highlight mode
            if (currentHighlightMode === 'rank' && rank !== null && vocabSize !== null) {
                // Rank-based coloring: lower rank (1 = best) = greener, higher rank = redder
                // Cap at rank 5 - anything worse than top 5 is red
                const cappedRank = Math.min(rank, 5);
                // Normalize rank to 0-1 scale (inverted so rank 1 = 1.0, rank 5+ = 0.0)
                const normalizedRank = 1 - (cappedRank - 1) / 4; // (5-1)/4 = 1.0, (1-1)/4 = 0.0
                const hue = 120 * normalizedRank;
                return `hsl(${hue}, 70%, 60%)`;
            } else {
                // Probability-based coloring: red (low) to green (high)
                const hue = 120 * (probability || 0);
            return `hsl(${hue}, 70%, 60%)`;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function loadGenerationRules() {
            try {
                const stored = localStorage.getItem('tokenlens_generation_rules');
                generationRules = stored ? JSON.parse(stored) : [];
            } catch (error) {
                console.warn('Failed to load rules from storage:', error);
                generationRules = [];
            }
            updateRulesBadge();
        }

        function persistGenerationRules() {
            localStorage.setItem('tokenlens_generation_rules', JSON.stringify(generationRules));
            updateRulesBadge();
        }

        function updateRulesBadge() {
            const badge = document.getElementById('rules-count-badge');
            const badgeMenu = document.getElementById('rules-count-badge-menu');
            const enabledCount = generationRules.filter(rule => rule?.enabled !== false).length;
            
            // Update both badge locations
            [badge, badgeMenu].forEach(b => {
                if (b) {
                    if (enabledCount > 0) {
                        b.textContent = enabledCount;
                        b.style.display = 'inline-flex';
                    } else {
                        b.style.display = 'none';
                    }
                }
            });
        }

        function openRulesModal() {
            renderRulesModal();
            const modal = document.getElementById('rules-modal');
            if (modal) {
                modal.style.display = 'flex';
            }
        }

        function closeRulesModal() {
            const modal = document.getElementById('rules-modal');
            if (modal) {
                modal.style.display = 'none';
            }
        }

        function generateRuleId() {
            if (window.crypto && window.crypto.randomUUID) {
                return window.crypto.randomUUID();
            }
            return `rule_${Math.random().toString(36).slice(2, 10)}`;
        }

        function addNewRule() {
            const newRule = {
                id: generateRuleId(),
                name: 'Low probability guard',
                enabled: true,
                criteria: { type: 'probability_below', threshold: 0.05 },
                action: { type: 'resample_same', strategy: 'sample', top_k: 5, max_attempts: 3 }
            };
            generationRules.push(newRule);
            persistGenerationRules();
            renderRulesModal();
        }

        function resetRules() {
            if (!confirm('Clear all automation rules?')) {
                return;
            }
            generationRules = [];
            persistGenerationRules();
            renderRulesModal();
        }

        function removeRule(ruleId) {
            generationRules = generationRules.filter(rule => rule.id !== ruleId);
            persistGenerationRules();
            renderRulesModal();
        }

        function updateRuleValue(ruleId, path, value, options = {}) {
            const targetRule = generationRules.find(rule => rule.id === ruleId);
            if (!targetRule) return;
            const keys = path.split('.');
            let target = targetRule;
            for (let i = 0; i < keys.length - 1; i++) {
                const key = keys[i];
                if (target[key] === undefined) {
                    target[key] = {};
                }
                target = target[key];
            }
            const finalKey = keys[keys.length - 1];
            if (options.number && value !== '') {
                const parsed = parseFloat(value);
                if (!isNaN(parsed)) {
                    target[finalKey] = parsed;
                }
            } else if (options.integer && value !== '') {
                const parsedInt = parseInt(value, 10);
                if (!isNaN(parsedInt)) {
                    target[finalKey] = parsedInt;
                }
            } else if (options.boolean) {
                target[finalKey] = !!value;
            } else {
                target[finalKey] = value;
            }
            persistGenerationRules();
            if (options.refresh) {
                renderRulesModal();
            }
        }

        function toggleRuleEnabled(ruleId, checked) {
            updateRuleValue(ruleId, 'enabled', checked, { boolean: true });
        }

        function renderRulesModal() {
            const list = document.getElementById('rules-list');
            if (!list) return;
            if (!generationRules.length) {
                list.innerHTML = `
                    <div class="rules-empty-state">
                        <p>No automation rules yet.</p>
                        <button class="modal-btn-primary" onclick="addNewRule()">Create your first rule</button>
                    </div>
                `;
                return;
            }
            list.innerHTML = generationRules.map(rule => buildRuleCard(rule)).join('');
        }

        function buildRuleCard(rule) {
            const criteriaType = rule?.criteria?.type || 'probability_below';
            const actionType = rule?.action?.type || 'resample_same';
            const name = escapeHtml(rule?.name || 'Untitled rule');
            const threshold = rule?.criteria?.threshold ?? 0.05;
            const count = rule?.criteria?.count ?? 2;
            const matchValue = escapeHtml(rule?.criteria?.value || '');
            const matchType = rule?.criteria?.match_type || 'contains';
            const windowSize = rule?.criteria?.window ?? 3;
            const actionStrategy = rule?.action?.strategy || 'sample';
            const actionTopK = rule?.action?.top_k ?? 5;
            const actionAttempts = rule?.action?.max_attempts ?? 3;
            const actionModel = rule?.action?.model || '';
            const actionTemp = rule?.action?.temperature ?? 0.7;
            const actionText = escapeHtml(rule?.action?.text || '');
            
            const criteriaFields = {
                probability_below: `
                    <label class="rule-field">
                        <span>Probability below</span>
                        <input type="number" step="0.001" min="0" max="1" value="${threshold}"
                            oninput="updateRuleValue('${rule.id}', 'criteria.threshold', this.value, { number: true })">
                    </label>
                `,
                consecutive_probability_below: `
                    <label class="rule-field">
                        <span>Probability below</span>
                        <input type="number" step="0.001" min="0" max="1" value="${threshold}"
                            oninput="updateRuleValue('${rule.id}', 'criteria.threshold', this.value, { number: true })">
                    </label>
                    <label class="rule-field">
                        <span>Times in a row</span>
                        <input type="number" min="2" value="${count}"
                            oninput="updateRuleValue('${rule.id}', 'criteria.count', this.value, { integer: true })">
                    </label>
                `,
                text_match: `
                    <label class="rule-field">
                        <span>Match text</span>
                        <input type="text" value="${matchValue}"
                            oninput="updateRuleValue('${rule.id}', 'criteria.value', this.value)">
                    </label>
                    <label class="rule-field">
                        <span>Match type</span>
                        <select onchange="updateRuleValue('${rule.id}', 'criteria.match_type', this.value)">
                            <option value="contains" ${matchType === 'contains' ? 'selected' : ''}>Contains</option>
                            <option value="exact" ${matchType === 'exact' ? 'selected' : ''}>Exact</option>
                            <option value="regex" ${matchType === 'regex' ? 'selected' : ''}>Regex</option>
                        </select>
                    </label>
                    <label class="rule-field">
                        <span>Window (tokens)</span>
                        <input type="number" min="1" value="${windowSize}"
                            oninput="updateRuleValue('${rule.id}', 'criteria.window', this.value, { integer: true })">
                    </label>
                `
            }[criteriaType];

            const actionFields = {
                resample_same: `
                    <label class="rule-field">
                        <span>Strategy</span>
                        <select onchange="updateRuleValue('${rule.id}', 'action.strategy', this.value)">
                            <option value="sample" ${actionStrategy === 'sample' ? 'selected' : ''}>Sample</option>
                            <option value="greedy" ${actionStrategy === 'greedy' ? 'selected' : ''}>Greedy</option>
                        </select>
                    </label>
                    <label class="rule-field">
                        <span>Top K focus</span>
                        <input type="number" min="0" value="${actionTopK}"
                            oninput="updateRuleValue('${rule.id}', 'action.top_k', this.value, { integer: true })">
                    </label>
                    <label class="rule-field">
                        <span>Max attempts</span>
                        <input type="number" min="1" max="10" value="${actionAttempts}"
                            oninput="updateRuleValue('${rule.id}', 'action.max_attempts', this.value, { integer: true })">
                    </label>
                `,
                resample_other_model: `
                    <label class="rule-field">
                        <span>Model</span>
                        <select onchange="updateRuleValue('${rule.id}', 'action.model', this.value)">
                            <option value="">Select model</option>
                            <option value="meta-llama/Llama-3.1-8B-Instruct" ${actionModel === 'meta-llama/Llama-3.1-8B-Instruct' ? 'selected' : ''}>Llama-3.1-8B-Instruct</option>
                            <option value="google/gemma-2-2b-it" ${actionModel === 'google/gemma-2-2b-it' ? 'selected' : ''}>Gemma-2-2B-IT</option>
                            <option value="google/gemma-3-1b-it" ${actionModel === 'google/gemma-3-1b-it' ? 'selected' : ''}>Gemma-3-1B-IT</option>
                        </select>
                    </label>
                    <label class="rule-field">
                        <span>Strategy</span>
                        <select onchange="updateRuleValue('${rule.id}', 'action.strategy', this.value)">
                            <option value="greedy" ${actionStrategy === 'greedy' ? 'selected' : ''}>Greedy</option>
                            <option value="sample" ${actionStrategy === 'sample' ? 'selected' : ''}>Sample</option>
                        </select>
                    </label>
                    <label class="rule-field">
                        <span>Temperature</span>
                        <input type="number" step="0.05" min="0" max="2" value="${actionTemp}"
                            oninput="updateRuleValue('${rule.id}', 'action.temperature', this.value, { number: true })">
                    </label>
                    <label class="rule-field">
                        <span>Top K focus</span>
                        <input type="number" min="0" value="${actionTopK}"
                            oninput="updateRuleValue('${rule.id}', 'action.top_k', this.value, { integer: true })">
                    </label>
                `,
                replace_text: `
                    <label class="rule-field">
                        <span>Replacement text</span>
                        <textarea rows="2" oninput="updateRuleValue('${rule.id}', 'action.text', this.value)">${actionText}</textarea>
                    </label>
                `
            }[actionType];

            return `
                <div class="rule-card ${rule.enabled === false ? 'rule-card-disabled' : ''}">
                    <div class="rule-card-header">
                        <input type="text" value="${name}" placeholder="Rule name"
                            oninput="updateRuleValue('${rule.id}', 'name', this.value)">
                        <label class="switch">
                            <input type="checkbox" ${rule.enabled !== false ? 'checked' : ''} onchange="toggleRuleEnabled('${rule.id}', this.checked)">
                            <span class="slider round"></span>
                        </label>
                        <button class="rule-delete-btn" onclick="removeRule('${rule.id}')" title="Delete rule">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M3 4H13M6 4V3C6 2.44772 6.44772 2 7 2H9C9.55228 2 10 2.44772 10 3V4M12 4V13C12 13.5523 11.5523 14 11 14H5C4.44772 14 4 13.5523 4 13V4H12Z" stroke="currentColor" stroke-width="1.5"/>
                            </svg>
                        </button>
                    </div>
                    <div class="rule-section">
                        <div class="rule-section-title">When</div>
                        <div class="rule-grid">
                            <label class="rule-field">
                                <span>Criteria</span>
                                <select onchange="updateRuleValue('${rule.id}', 'criteria.type', this.value, { refresh: true })">
                                    <option value="probability_below" ${criteriaType === 'probability_below' ? 'selected' : ''}>Probability below</option>
                                    <option value="consecutive_probability_below" ${criteriaType === 'consecutive_probability_below' ? 'selected' : ''}>Multiple low probs</option>
                                    <option value="text_match" ${criteriaType === 'text_match' ? 'selected' : ''}>Text match</option>
                                </select>
                            </label>
                            ${criteriaFields}
                        </div>
                    </div>
                    <div class="rule-section">
                        <div class="rule-section-title">Then</div>
                        <div class="rule-grid">
                            <label class="rule-field">
                                <span>Action</span>
                                <select onchange="updateRuleValue('${rule.id}', 'action.type', this.value, { refresh: true })">
                                    <option value="resample_same" ${actionType === 'resample_same' ? 'selected' : ''}>Resample with same model</option>
                                    <option value="resample_other_model" ${actionType === 'resample_other_model' ? 'selected' : ''}>Borrow from other model</option>
                                    <option value="replace_text" ${actionType === 'replace_text' ? 'selected' : ''}>Inject text</option>
                                </select>
                            </label>
                            ${actionFields}
                        </div>
                    </div>
                </div>
            `;
        }

        // Helper function to format tokens for display consistently
        function formatTokenForDisplay(token, options = {}) {
            if (!token) return token;
            
            const { replaceAllSpaces = false, useSpaceSymbol = true, showLeadingSpace = true } = options;
            
            // Check for newlines
            if (token.includes('\n')) {
                const newlineCount = (token.match(/\n/g) || []).length;
                return newlineCount === 1 ? '↵' : `↵×${newlineCount}`;
            }
            
            // Check for tabs
            if (token.includes('\t')) {
                const tabCount = (token.match(/\t/g) || []).length;
                return tabCount === 1 ? '→' : `→×${tabCount}`;
            }
            
            // Check if token is only whitespace (spaces, not tabs)
            if (/^\s+$/.test(token) && !token.includes('\t')) {
                if (useSpaceSymbol) {
                    const spaceCount = token.length;
                    return spaceCount === 1 ? '␣' : `␣×${spaceCount}`;
                }
                // Otherwise keep as-is
                return token;
            }
            
            // For tokens with leading spaces, make them visible
            if (showLeadingSpace && token.startsWith(' ')) {
                const leadingSpaces = token.match(/^ +/)[0].length;
                const rest = token.slice(leadingSpaces);
                const spaceSymbol = leadingSpaces === 1 ? '␣' : `␣×${leadingSpaces}`;
                return spaceSymbol + rest;
            }
            
            // For mixed content, optionally replace spaces with middle dot
            if (replaceAllSpaces) {
                return token.replace(/ /g, '·');
            }
            
            // Return as-is for normal tokens
            return token;
        }

        // ===== VIEW SWITCHING =====
        
        function updateTokenForView(tokenElement, targetView) {
            if (!tokenElement || !tokenElement.dataset) return;
            const rawToken = tokenElement.dataset.token;
            if (rawToken === undefined) return;
            
            if (targetView === 'text') {
                if (rawToken.includes('\n')) {
                    const newlineCount = (rawToken.match(/\n/g) || []).length;
                    tokenElement.textContent = newlineCount === 1 ? '↵' : `↵×${newlineCount}`;
                } else if (rawToken.includes('\t')) {
                    const tabCount = (rawToken.match(/\t/g) || []).length;
                    tokenElement.textContent = tabCount === 1 ? '→' : `→×${tabCount}`;
                } else if (rawToken === ' ' || /^\s+$/.test(rawToken)) {
                    const spaceCount = rawToken.length;
                    tokenElement.textContent = spaceCount === 1 ? '␣' : `␣×${spaceCount}`;
                } else {
                    tokenElement.textContent = rawToken;
                }
                tokenElement.style.backgroundColor = 'transparent';
                tokenElement.style.color = '';
                tokenElement.style.borderColor = '';
                tokenElement.style.boxShadow = '';
                tokenElement.style.padding = '';
                tokenElement.style.cursor = 'text';
                tokenElement.style.whiteSpace = 'pre';
            } else {
                tokenElement.textContent = formatTokenForDisplay(rawToken, { useSpaceSymbol: true });
                
                const probability = parseFloat(tokenElement.dataset.probability);
                const rank = tokenElement.dataset.rank !== undefined && tokenElement.dataset.rank !== '' 
                    ? parseInt(tokenElement.dataset.rank, 10) 
                    : null;
                const vocabSize = tokenElement.dataset.vocabSize !== undefined && tokenElement.dataset.vocabSize !== '' 
                    ? parseInt(tokenElement.dataset.vocabSize, 10) 
                    : null;
                
                if (!isNaN(probability)) {
                    const color = getColorForProb(probability, rank, vocabSize);
                    tokenElement.style.backgroundColor = color;
                }
                
                tokenElement.style.color = '';
                tokenElement.style.borderColor = '';
                tokenElement.style.boxShadow = '';
                tokenElement.style.padding = '';
                tokenElement.style.cursor = '';
                tokenElement.style.whiteSpace = '';
            }
        }
        
        function refreshTokensForView(targetView) {
            document.querySelectorAll('.token').forEach(token => updateTokenForView(token, targetView));
        }
        
        function switchView() {
            const viewSelect = document.getElementById('view-select');
            const viewSelectMenu = document.getElementById('view-select-menu');
            const view = viewSelect ? viewSelect.value : 'token';
            currentView = view;
            
            if (viewSelectMenu && viewSelectMenu.value !== view) {
                viewSelectMenu.value = view;
            }
            
            // Save to localStorage (global default)
            localStorage.setItem('tokenlens_current_view', view);
            
            // Save to current conversation
            if (currentConversationId && conversations[currentConversationId]) {
                conversations[currentConversationId].viewMode = view;
                saveConversations();
            }
            
            const appContainer = document.querySelector('.app-container');
            if (appContainer) {
                appContainer.classList.remove('view-token', 'view-text', 'view-diff');
                if (view === 'diff') {
                    appContainer.classList.add('view-diff');
                } else if (view === 'text') {
                    appContainer.classList.add('view-text');
                } else {
                    appContainer.classList.add('view-token');
                }
            }
            
            if (view === 'diff') {
                restoreTokenView();
                applyDiffLensView();
            } else if (view === 'text') {
                applyTextView();
            } else {
                restoreTokenView();
                resetDiffLensView();
            }
        }
        
        function applyTextView() {
            refreshTokensForView('text');
        }
        
        function restoreTokenView() {
            refreshTokensForView('token');
        }
        
        function switchHighlightMode() {
            const highlightModeSelect = document.getElementById('highlight-mode-select');
            const mode = highlightModeSelect ? highlightModeSelect.value : 'probability';
            currentHighlightMode = mode;
            
            // Save to localStorage
            localStorage.setItem('tokenlens_highlight_mode', mode);
            
            // Re-apply current view to update colors
            if (currentView === 'diff') {
                restoreTokenView();
                applyDiffLensView();
            } else if (currentView === 'text') {
                applyTextView();
            } else {
                restoreTokenView();
            }
        }
        
        function applyDiffLensView() {
            // Restore saved analysis model selection
            const savedAnalysisModel = localStorage.getItem('tokenlens_analysis_model');
            if (savedAnalysisModel) {
                const analysisSelect = document.getElementById('analysis-model-select');
                if (analysisSelect) {
                    analysisSelect.value = savedAnalysisModel;
                }
            }
            
            // Apply colors to tokens based on DiffLens data (or neutral if missing)
            const messagesContainer = document.getElementById('messages-container');
            const assistantMessages = messagesContainer.querySelectorAll('.assistant-message');
            
            assistantMessages.forEach(messageDiv => {
                const tokens = messageDiv.querySelectorAll('.token');
                tokens.forEach(token => {
                    if (token.dataset.difflensProbDiff) {
                        const diff = parseFloat(token.dataset.difflensProbDiff);
                        const rankDiff = token.dataset.difflensRankDiff ? parseFloat(token.dataset.difflensRankDiff) : null;
                        const color = getDiffLensColor(diff, rankDiff);
                        token.style.backgroundColor = color;
                        
                        if (Math.abs(diff) < 2) {
                            token.style.color = 'hsl(0, 0%, 30%)';
                            token.classList.remove('difflens-gen-prefers', 'difflens-analysis-prefers');
                            token.classList.add('difflens-neutral');
                        } else if (diff > 0) {
                            token.style.color = 'hsl(120, 50%, 20%)';
                            token.classList.remove('difflens-analysis-prefers', 'difflens-neutral');
                            token.classList.add('difflens-gen-prefers');
                        } else {
                            token.style.color = 'hsl(0, 50%, 25%)';
                            token.classList.remove('difflens-gen-prefers', 'difflens-neutral');
                            token.classList.add('difflens-analysis-prefers');
                        }
                    } else {
                        token.style.backgroundColor = 'hsl(0, 0%, 75%)';
                        token.style.color = 'hsl(0, 0%, 30%)';
                        token.classList.remove('difflens-gen-prefers', 'difflens-analysis-prefers');
                        token.classList.add('difflens-neutral');
                    }
                });
            });
        }
        
        function resetDiffLensView() {
            clearDiffLensAnalysis();
        }
        
        function clearDiffLensAnalysis() {
            // Reset all tokens to their original probability/rank-based colors
            const allTokens = document.querySelectorAll('.token');
            allTokens.forEach(token => {
                const prob = parseFloat(token.dataset.probability);
                const rank = parseInt(token.dataset.rank);
                const vocabSize = parseInt(token.dataset.vocabSize);
                if (!isNaN(prob)) {
                    const color = getColorForProb(prob, rank, vocabSize);
                    token.style.backgroundColor = color;
                }
                token.style.color = '';
                token.classList.remove('difflens-gen-prefers', 'difflens-analysis-prefers', 'difflens-neutral');
            });
        }
        
        async function triggerDiffLensAnalysis() {
            const analysisModel = document.getElementById('analysis-model-input')?.value || 
                                   document.getElementById('analysis-model-select-menu')?.value || '';
            if (!analysisModel) {
                clearDiffLensAnalysis();
                return;
            }
            
            // Get apply button and set loading state
            const applyBtn = document.querySelector('.difflens-apply-btn');
            if (!applyBtn) return;
            const originalText = applyBtn.textContent;
            applyBtn.disabled = true;
            applyBtn.textContent = 'Analyzing...';
            
            try {
                // Save analysis model selection
                localStorage.setItem('tokenlens_analysis_model', analysisModel);
                
                const generationModel = document.getElementById('model-select').value;
                const messagesContainer = document.getElementById('messages-container');
                const assistantMessages = messagesContainer.querySelectorAll('.assistant-message');
                
                for (const messageDiv of assistantMessages) {
                const tokensContainer = messageDiv.querySelector('.message-tokens');
                if (!tokensContainer) continue;
                
                const tokens = tokensContainer.querySelectorAll('.token');
                if (tokens.length === 0) continue;
                
                // Build context up to this message using active thread (approximate)
                // Since we are iterating over visible messages, they correspond to active thread
                const thread = getActiveThread();
                const messageIndex = Array.from(assistantMessages).indexOf(messageDiv);
                // We need context messages. 
                // Active thread contains {role, content, ...} nodes.
                // Assistant messages in thread are at index 1, 3, 5... (assuming User-Assistant-User...)
                // Actually, we can just find the node corresponding to this message in the thread.
                const nodeId = messageDiv.dataset.nodeId;
                const nodeIndex = thread.findIndex(n => n.id === nodeId);
                
                if (nodeIndex === -1) continue;
                
                // Context is everything before this node
                const contextMessages = thread.slice(0, nodeIndex).map(n => ({
                    role: n.role,
                    content: n.content
                }));
                
                // Prepend system prompt if set
                if (currentSystemPrompt) {
                    contextMessages.unshift({
                        role: 'system',
                        content: currentSystemPrompt
                    });
                }
                
                // Get token data including rank and top alternatives
                const tokenData = Array.from(tokens).map(token => {
                    const tokenIdAttr = token.dataset.tokenId;
                    const parsedTokenId = (tokenIdAttr !== undefined && tokenIdAttr !== '') ? parseInt(tokenIdAttr, 10) : null;
                    return {
                    token: token.dataset.token,
                        token_id: Number.isNaN(parsedTokenId) ? null : parsedTokenId,
                    gen_prob: parseFloat(token.dataset.probability),
                    gen_rank: parseInt(token.dataset.rank),
                    gen_top_alternatives: JSON.parse(token.dataset.topAlternatives || '[]')
                    };
                });
                
                try {
                    // Use the temperature from generation (stored in first token)
                    const temperature = tokens.length > 0 ? parseFloat(tokens[0].dataset.temperature) || 1.0 : 1.0;
                    
                    const response = await fetch('/api/analyze-difflens', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            generation_model: generationModel,
                            analysis_model: analysisModel,
                            context: contextMessages,
                            tokens: tokenData,
                            temperature: temperature
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.token_data && result.token_data.length > 0) {
                        // Store DiffLens data in node
                        const node = messageTree[nodeId];
                        if (node) {
                            node.difflens_data = {
                                generation_model: result.generation_model,
                                analysis_model: result.analysis_model,
                                token_data: result.token_data
                            };
                        }
                        
                        // Apply diff lens colors and update token data
                        tokens.forEach((token, idx) => {
                            if (result.token_data[idx]) {
                                const tokenInfo = result.token_data[idx];
                                const diff = tokenInfo.prob_diff;
                                const rankDiff = tokenInfo.rank_diff;
                                const color = getDiffLensColor(diff, rankDiff);
                                token.style.backgroundColor = color;
                                
                                // Set text color based on difference
                                if (Math.abs(diff) < 0.5) {
                                    token.style.color = 'hsl(0, 0%, 30%)';
                                } else if (diff > 0) {
                                    token.style.color = 'hsl(120, 50%, 20%)';
                                } else {
                                    token.style.color = 'hsl(0, 50%, 25%)';
                                }
                                
                                // Store DiffLens data in token element
                                token.dataset.difflensGenProb = tokenInfo.gen_prob;
                                token.dataset.difflensGenRank = tokenInfo.gen_rank;
                                token.dataset.difflensGenTopAlternatives = JSON.stringify(tokenInfo.gen_top_alternatives);
                                token.dataset.difflensAnalysisProb = tokenInfo.analysis_prob;
                                token.dataset.difflensAnalysisRank = tokenInfo.analysis_rank;
                                token.dataset.difflensAnalysisTopAlternatives = JSON.stringify(tokenInfo.analysis_top_alternatives);
                                token.dataset.difflensProbDiff = tokenInfo.prob_diff;
                                token.dataset.difflensRankDiff = tokenInfo.rank_diff;
                                token.dataset.difflensGenModel = result.generation_model;
                                token.dataset.difflensAnalysisModel = result.analysis_model;
                                
                                // Add class for styling
                                token.classList.remove('difflens-gen-prefers', 'difflens-analysis-prefers', 'difflens-neutral');
                                if (Math.abs(diff) < 0.5) {
                                    token.classList.add('difflens-neutral');
                                } else if (diff > 0) {
                                    token.classList.add('difflens-gen-prefers');
                                } else {
                                    token.classList.add('difflens-analysis-prefers');
                                }
                            }
                        });
                        
                        // Save conversation with DiffLens data
                        saveCurrentConversation();
                    }
                } catch (error) {
                    console.error('DiffLens analysis error:', error);
                }
            }
                
                // Auto-switch to Diff view after applying analysis
                const viewSelectMenu = document.getElementById('view-select-menu');
                const viewSelect = document.getElementById('view-select');
                if (viewSelectMenu) viewSelectMenu.value = 'diff';
                if (viewSelect) viewSelect.value = 'diff';
                currentView = 'diff';
                localStorage.setItem('tokenlens_current_view', 'diff');
                switchView();
                
            } finally {
                // Reset button state
                applyBtn.disabled = false;
                applyBtn.textContent = originalText;
            }
        }
        
        function getDiffLensColor(percentageDiff, rankDiff = null) {
            // Color based on current highlight mode
            if (currentHighlightMode === 'rank' && rankDiff !== null) {
                // rankDiff = analysis_rank - gen_rank
                // Negative = generation model ranked higher (green)
                // Positive = analysis model ranked higher (red)
                // Near zero = similar (gray)
                
                // Clamp to reasonable range [-5, 5] (since individual ranks are capped at 5)
                const clamped = Math.max(-5, Math.min(5, rankDiff));
                const normalized = clamped / 5; // Now in [-1, 1]
                
                if (Math.abs(rankDiff) < 1) {
                    // Small rank difference (less than 1 rank) - gray
                    return 'hsl(0, 0%, 75%)';
                } else if (normalized < 0) {
                    // Generation model ranked higher (lower rank number) - green
                    const intensity = Math.abs(normalized);
                    const lightness = 85 - (intensity * 35); // 85% to 50%
                    return `hsl(120, 60%, ${lightness}%)`;
                } else {
                    // Analysis model ranked higher (lower rank number) - red
                    const intensity = Math.abs(normalized);
                    const lightness = 85 - (intensity * 35); // 85% to 50%
                    return `hsl(0, 60%, ${lightness}%)`;
                }
            } else {
                // Probability diff coloring
            // percentageDiff = (gen_prob - analysis_prob) * 100
            // Positive = generation model prefers (green)
            // Negative = analysis model prefers (red)
            // Near zero = similar (gray)
            
            // Clamp to reasonable range [-50, 50] (percentage points)
            const clamped = Math.max(-50, Math.min(50, percentageDiff));
            const normalized = clamped / 50; // Now in [-1, 1]
            
            if (Math.abs(percentageDiff) < 2) {
                // Low difference (< 2 percentage points) - gray
                return 'hsl(0, 0%, 75%)';
            } else if (normalized > 0) {
                // Generation model prefers - green
                const intensity = Math.abs(normalized);
                const lightness = 85 - (intensity * 35); // 85% to 50%
                return `hsl(120, 60%, ${lightness}%)`;
            } else {
                // Analysis model prefers - red
                const intensity = Math.abs(normalized);
                const lightness = 85 - (intensity * 35); // 85% to 50%
                return `hsl(0, 60%, ${lightness}%)`;
                }
            }
        }

        // ===== TOKEN CONTEXT MENU =====
        
        function showUnifiedTooltip(tokenElement, mode) {
            const tooltip = document.getElementById('token-tooltip');
            const currentTokenDiv = document.getElementById('tooltip-current-token');
            const alternativesDiv = document.getElementById('tooltip-alternatives');
            const searchInput = document.getElementById('token-search-input');
            const searchResults = document.getElementById('token-search-results');
            
            // Check if we're in DiffLens mode and have DiffLens data
            const inDiffLensMode = currentView === 'diff';
            const hasDiffLensData = tokenElement.dataset.difflensProbDiff !== undefined;
            
            // Get token data
            const token = tokenElement.dataset.token;
            const probability = parseFloat(tokenElement.dataset.probability);
            const rank = parseInt(tokenElement.dataset.rank);
            const vocabSize = parseInt(tokenElement.dataset.vocabSize);
            const topAlternatives = JSON.parse(tokenElement.dataset.topAlternatives);
            
            // Get DiffLens data if available
            let difflensData = null;
            if (inDiffLensMode && hasDiffLensData) {
                difflensData = {
                    genProb: parseFloat(tokenElement.dataset.difflensGenProb),
                    genRank: parseInt(tokenElement.dataset.difflensGenRank),
                    genTopAlternatives: JSON.parse(tokenElement.dataset.difflensGenTopAlternatives || '[]'),
                    analysisProb: parseFloat(tokenElement.dataset.difflensAnalysisProb),
                    analysisRank: parseInt(tokenElement.dataset.difflensAnalysisRank),
                    analysisTopAlternatives: JSON.parse(tokenElement.dataset.difflensAnalysisTopAlternatives || '[]'),
                    probDiff: parseFloat(tokenElement.dataset.difflensProbDiff),
                    rankDiff: parseInt(tokenElement.dataset.difflensRankDiff),
                    genModel: tokenElement.dataset.difflensGenModel,
                    analysisModel: tokenElement.dataset.difflensAnalysisModel
                };
            }
            
            const displayToken = formatTokenForDisplay(token, { useSpaceSymbol: true });
            
            // DiffLens mode: show comparison header and two-column layout
            if (inDiffLensMode) {
                // Show diff info at top if we have analysis data
                if (difflensData) {
                    currentTokenDiv.innerHTML = `
                        <div style="padding: 8px 12px; border-bottom: 1px solid var(--border-color); font-size: 0.9em;">
                            <strong>Prob Diff:</strong> ${difflensData.probDiff >= 0 ? '+' : ''}${difflensData.probDiff.toFixed(2)}% &nbsp;&nbsp;
                            <strong>Rank Diff:</strong> ${difflensData.rankDiff >= 0 ? '+' : ''}${difflensData.rankDiff}
                        </div>
                    `;
                } else {
                    currentTokenDiv.innerHTML = `
                        <div style="padding: 8px 12px; border-bottom: 1px solid var(--border-color); font-size: 0.9em; color: var(--text-secondary);">
                            Click "Apply" to analyze with analysis model
                        </div>
                    `;
                }
                
                // Two-column layout for models
                alternativesDiv.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1px 1fr; gap: 0; padding: 12px; min-width: 500px;">
                        <div class="model-column" style="padding-right: 12px; min-width: 0; overflow: hidden;">
                            <div style="font-weight: 600; margin-bottom: 8px; font-size: 0.875em; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${difflensData?.genModel || document.getElementById('model-select')?.value || 'Generation'}</div>
                            <div class="tooltip-current-token" style="margin-bottom: 8px; min-width: 0;">
                                <div class="current-left" style="min-width: 0; overflow: hidden;">
                                    ${rank ? `<span class="current-rank" style="flex-shrink: 0;">#${rank}</span>` : ''}
                                    <span class="current-token-text" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></span>
                                </div>
                                ${probability ? `<span class="current-prob" style="flex-shrink: 0;">${(probability * 100).toFixed(1)}%</span>` : ''}
                            </div>
                            <div class="alternatives-list">
                                ${topAlternatives && topAlternatives.length > 0 ? 
                                    topAlternatives
                                        .map((alt, i) => ({...alt, originalRank: i + 1}))
                                        .filter(alt => alt.token !== token)
                                        .slice(0, 2)
                                        .map((alt) => {
                                        const displayAlt = formatTokenForDisplay(alt.token, { useSpaceSymbol: true });
                                        return `
                                            <div class="tooltip-alternative-item" style="margin-bottom: 4px; min-width: 0;">
                                                <div class="alt-left" style="min-width: 0; overflow: hidden;">
                                                    <span class="alt-rank">#${alt.originalRank}</span>
                                                    <span class="alt-token" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${displayAlt}</span>
                                                </div>
                                                <span class="alt-prob" style="flex-shrink: 0;">${(alt.probability * 100).toFixed(1)}%</span>
                                            </div>
                                        `;
                                    }).join('') : '<div style="color: var(--text-secondary); font-size: 0.85em;">No alternatives</div>'}
                            </div>
                        </div>
                        <div style="background: var(--border-color); width: 1px;"></div>
                        <div class="model-column" style="padding-left: 12px; min-width: 0; overflow: hidden;">
                            <div style="font-weight: 600; margin-bottom: 8px; font-size: 0.875em; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${difflensData?.analysisModel || document.getElementById('analysis-model-select')?.value || 'Analysis'}</div>
                            ${difflensData ? `
                                <div class="tooltip-current-token" style="margin-bottom: 8px; min-width: 0;">
                                    <div class="current-left" style="min-width: 0; overflow: hidden;">
                                        ${difflensData.analysisRank ? `<span class="current-rank" style="flex-shrink: 0;">#${difflensData.analysisRank}</span>` : ''}
                                        <span class="current-token-text" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></span>
                                    </div>
                                    ${difflensData.analysisProb ? `<span class="current-prob" style="flex-shrink: 0;">${(difflensData.analysisProb * 100).toFixed(1)}%</span>` : ''}
                                </div>
                                <div class="alternatives-list">
                                    ${difflensData.analysisTopAlternatives && difflensData.analysisTopAlternatives.length > 0 ? 
                                        difflensData.analysisTopAlternatives
                                            .map((alt, i) => ({...alt, originalRank: i + 1}))
                                            .filter(alt => alt.token !== token)
                                            .slice(0, 2)
                                            .map((alt) => {
                                            const displayAlt = formatTokenForDisplay(alt.token, { useSpaceSymbol: true });
                                            return `
                                                <div class="tooltip-alternative-item" style="margin-bottom: 4px; min-width: 0;">
                                                    <div class="alt-left" style="min-width: 0; overflow: hidden;">
                                                        <span class="alt-rank">#${alt.originalRank}</span>
                                                        <span class="alt-token" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${displayAlt}</span>
                                                    </div>
                                                    <span class="alt-prob" style="flex-shrink: 0;">${(alt.probability * 100).toFixed(1)}%</span>
                                                </div>
                                            `;
                                        }).join('') : '<div style="color: var(--text-secondary); font-size: 0.85em;">No alternatives</div>'}
                                </div>
                            ` : '<div style="color: var(--text-secondary); font-size: 0.85em; padding: 8px;">Not analyzed yet</div>'}
                        </div>
                    </div>
                `;
                
                // Set token text for both columns
                const tokenTextEls = alternativesDiv.querySelectorAll('.current-token-text');
                tokenTextEls.forEach(el => el.textContent = displayToken);
                
            } else {
                // Normal mode tooltip (existing implementation)
                const modelName = tokenElement.dataset.model || 'Unknown';
                const temperature = parseFloat(tokenElement.dataset.temperature) || 1.0;
                
                currentTokenDiv.innerHTML = `
                    <div style="padding: 8px 12px; border-bottom: 1px solid var(--border-color); font-size: 0.85em; color: var(--text-secondary);">
                        <strong>Model:</strong> ${modelName} &nbsp;&nbsp; <strong>Temp:</strong> ${temperature.toFixed(1)}
                    </div>
                    <div class="tooltip-current-token ${mode === 'click' ? 'clickable' : ''}">
                    <div class="current-left">
                        ${rank !== null && rank !== undefined && vocabSize ? `<span class="current-rank">#${rank}</span>` : '<span class="current-rank"></span>'}
                        <span class="current-token-text"></span>
                    </div>
                    ${probability !== null && probability !== undefined && !isNaN(probability) ? `<span class="current-prob">${(probability * 100).toFixed(1)}%</span>` : '<span class="current-prob"></span>'}
                </div>`;
                
                // Set token text directly to preserve all characters (including special tokens)
                const tokenTextEl = currentTokenDiv.querySelector('.current-token-text');
                tokenTextEl.textContent = displayToken;
                
                // Make current token clickable in click mode
                if (mode === 'click') {
                    const currentTokenRow = currentTokenDiv.querySelector('.tooltip-current-token');
                    currentTokenRow.onclick = () => selectAlternativeToken(token, currentTokenRow);
                }
                
                // Build alternatives list (exclude current token and show next 3)
                alternativesDiv.innerHTML = '';
                if (topAlternatives && topAlternatives.length > 0 && topAlternatives[0].probability !== null) {
                    // Filter out the current token, preserve original indices for rank calculation
                    const filteredAlts = topAlternatives
                        .map((alt, originalIdx) => ({ ...alt, originalRank: originalIdx + 1 }))
                        .filter(alt => alt.token !== token)
                        .slice(0, 2);
                    
                    filteredAlts.forEach((alt) => {
                const altItem = document.createElement('div');
                        altItem.className = 'tooltip-alternative-item';
                        
                        // Only clickable in click mode
                        if (mode === 'click') {
                            altItem.classList.add('clickable');
                altItem.onclick = () => selectAlternativeToken(alt.token, altItem);
                        }
                
                        const altRank = alt.originalRank;
                        const displayAltToken = formatTokenForDisplay(alt.token, { useSpaceSymbol: true });
                
                altItem.innerHTML = `
                            <div class="alt-left">
                                <span class="alt-rank">#${altRank}</span>
                                <span class="alt-token"></span>
                            </div>
                    <span class="alt-prob">${(alt.probability * 100).toFixed(1)}%</span>
                `;
                        
                        // Set token text directly to preserve all characters
                        const altTokenEl = altItem.querySelector('.alt-token');
                        altTokenEl.textContent = displayAltToken;
                        
                        alternativesDiv.appendChild(altItem);
                    });
                }
            }
            
            // Set mode FIRST so dimensions are correct
            tooltip.className = 'token-tooltip';
            if (mode === 'hover') {
                tooltip.classList.add('hover-mode');
            } else if (mode === 'click') {
            tooltip.classList.add('click-mode');
            selectedTokenElement = tokenElement;
            
            // Highlight current token row
                const currentTokenRow = tooltip.querySelector('.tooltip-current-token');
                if (currentTokenRow) {
                    currentTokenRow.classList.add('selected');
                }
            
            // Clear search
            searchInput.value = '';
            searchResults.innerHTML = '';
            }
            
            // Position tooltip smartly (after mode is set so dimensions are accurate)
            const rect = tokenElement.getBoundingClientRect();
            
            // Show tooltip temporarily to get its dimensions
            tooltip.style.visibility = 'hidden';
            tooltip.classList.remove('hidden');
            const tooltipRect = tooltip.getBoundingClientRect();
            tooltip.classList.add('hidden');
            tooltip.style.visibility = 'visible';
            
            const viewportHeight = window.innerHeight;
            const viewportWidth = window.innerWidth;
            const padding = 8;
            
            // Vertical positioning: prefer below, but flip above if not enough space
            let top;
            const spaceBelow = viewportHeight - rect.bottom;
            const spaceAbove = rect.top;
            
            if (spaceBelow >= tooltipRect.height + padding || spaceBelow > spaceAbove) {
                // Position below
                top = rect.bottom + padding;
            } else {
                // Position above
                top = rect.top - tooltipRect.height - padding;
            }
            
            // Horizontal positioning: keep within viewport bounds
            let left = rect.left;
            if (left + tooltipRect.width > viewportWidth - padding) {
                left = viewportWidth - tooltipRect.width - padding;
            }
            if (left < padding) {
                left = padding;
            }
            
            tooltip.style.top = `${top}px`;
            tooltip.style.left = `${left}px`;
            
            // Show tooltip
            tooltip.classList.remove('hidden');
            
            // Focus search input if in click mode
            if (mode === 'click') {
                setTimeout(() => searchInput.focus(), 0);
            }
        }
        
        function hideUnifiedTooltip(mode) {
            const tooltip = document.getElementById('token-tooltip');
            
            // Only hide if in the specified mode
            if (mode === 'hover' && tooltip.classList.contains('hover-mode')) {
                tooltip.classList.add('hidden');
                tooltip.classList.remove('hover-mode');
            } else if (mode === 'click' && tooltip.classList.contains('click-mode')) {
                // Clear all selections
                const currentTokenRow = tooltip.querySelector('.tooltip-current-token');
                if (currentTokenRow) {
                    currentTokenRow.classList.remove('selected');
                }
                tooltip.querySelectorAll('.tooltip-alternative-item').forEach(item => {
                    item.classList.remove('selected');
                });
                tooltip.querySelectorAll('.search-result-item').forEach(item => {
                    item.classList.remove('selected');
                });
                
                tooltip.classList.add('hidden');
            tooltip.classList.remove('click-mode');
            selectedTokenElement = null;
        }
        }
        
        let searchListenerSetup = false;
        function setupTokenSearchListener() {
            if (searchListenerSetup) return;
            
            const searchInput = document.getElementById('token-search-input');
            if (!searchInput) return;
            
            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                const query = this.value.trim();
                
                console.log('Search input changed:', query);
                
                const resultsDiv = document.getElementById('token-search-results');
                
                if (query.length < 1) {
                    resultsDiv.innerHTML = '';
                    return;
                }
                
                // Show searching indicator
                resultsDiv.innerHTML = '<div class="search-no-results">Searching...</div>';
                
                searchTimeout = setTimeout(() => searchTokens(query), 300);
            });
            
            searchListenerSetup = true;
            console.log('Token search listener set up');
        }
        
        function selectAlternativeToken(token, element) {
            // Update inject input with selected token
            const injectInput = document.getElementById('inspector-inject-input');
            if (injectInput) {
                injectInput.value = token;
                injectInput.focus();
            }
            
            // Update UI to show selection
            const tooltip = document.getElementById('token-tooltip');
            const currentTokenRow = tooltip.querySelector('.tooltip-current-token');
            if (currentTokenRow) {
                currentTokenRow.classList.remove('selected');
            }
            tooltip.querySelectorAll('.tooltip-alternative-item').forEach(item => {
                item.classList.remove('selected');
            });
            tooltip.querySelectorAll('.search-result-item').forEach(item => {
                item.classList.remove('selected');
            });
            element.classList.add('selected');
        }
        
        // Setup unified tooltip handlers
        function setupTooltipHandlers() {
            // Close click tooltip when clicking outside
            document.addEventListener('click', function(e) {
                const tooltip = document.getElementById('token-tooltip');
                if (tooltip && tooltip.classList.contains('click-mode') && !tooltip.contains(e.target) && !e.target.classList.contains('token')) {
                    hideUnifiedTooltip('click');
                }
            });
            
            // Prevent tooltip from closing when clicking inside it
            const tooltip = document.getElementById('token-tooltip');
            if (tooltip) {
                tooltip.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
            }
            
            // Close on Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    hideUnifiedTooltip('click');
                }
            });
        }
        
        // Token search with debouncing
        let searchTimeout = null;
        
        // === NEW: Menu and Inspector Functions ===
        
        // Menu toggling
        function toggleMenu(menuId) {
            const menu = document.getElementById(menuId);
            const btn = menu.previousElementSibling;
            
            // Close all other menus
            document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                if (dropdown.id !== menuId) {
                    dropdown.classList.remove('active');
                }
            });
            document.querySelectorAll('.menu-btn').forEach(button => {
                if (button !== btn) {
                    button.classList.remove('active');
                }
            });
            
            // Toggle this menu
            menu.classList.toggle('active');
            btn.classList.toggle('active');
        }
        
        function closeAllMenus() {
            document.querySelectorAll('.menu-dropdown').forEach(dropdown => {
                dropdown.classList.remove('active');
            });
            document.querySelectorAll('.menu-btn').forEach(button => {
                button.classList.remove('active');
            });
        }
        
        // Close menus when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.menu-item')) {
                closeAllMenus();
            }
        });
        
        function setInspectorCollapsedState(isCollapsed) {
            const sidebar = document.getElementById('inspector-sidebar');
            if (!sidebar) return;
            if (isCollapsed) {
                sidebar.classList.add('collapsed');
            } else {
                sidebar.classList.remove('collapsed');
            }
            localStorage.setItem('tokenlens_inspector_collapsed', String(isCollapsed));
        }
        
        // Right sidebar (inspector) toggling
        function toggleRightSidebar() {
            const sidebar = document.getElementById('inspector-sidebar');
            if (!sidebar) return;
            const willCollapse = !sidebar.classList.contains('collapsed');
            setInspectorCollapsedState(willCollapse);
        }
        
        // Sync menu controls with hidden fields (for backward compatibility)
        function syncViewSelect(sourceElement) {
            // Sync view select between menu and hidden field
            const viewSelectMenu = document.getElementById('view-select-menu');
            const viewSelect = document.getElementById('view-select');
            
            if (sourceElement === viewSelectMenu && viewSelect) {
                viewSelect.value = viewSelectMenu.value;
            } else if (sourceElement === viewSelect && viewSelectMenu) {
                viewSelectMenu.value = viewSelect.value;
            }
        }
        
        function syncMenuFields() {
            // Sync view select
            const viewSelectMenu = document.getElementById('view-select-menu');
            const viewSelect = document.getElementById('view-select');
            if (viewSelectMenu && viewSelect) {
                viewSelect.value = viewSelectMenu.value;
            }
            
            // Sync highlight mode
            const highlightSelectMenu = document.getElementById('highlight-mode-select-menu');
            const highlightSelect = document.getElementById('highlight-mode-select');
            if (highlightSelectMenu && highlightSelect) {
                highlightSelect.value = highlightSelectMenu.value;
            }
        }
        
        // Add event listeners to menu fields
        function setupMenuSyncing() {
            const viewSelect = document.getElementById('view-select-menu');
            if (viewSelect) {
                viewSelect.addEventListener('change', syncMenuFields);
            }
            
            const highlightSelect = document.getElementById('highlight-mode-select-menu');
            if (highlightSelect) {
                highlightSelect.addEventListener('change', syncMenuFields);
            }
        }
        
        function escapeAttr(value) {
            const str = String(value);
            if (typeof CSS !== 'undefined' && CSS.escape) {
                return CSS.escape(str);
            }
            return str.replace(/"/g, '\\"');
        }
        
        function findTokenElementByInfo(info) {
            if (!info) return null;
            let selector = '.token';
            if (info.nodeId) {
                selector += `[data-node-id="${escapeAttr(info.nodeId)}"]`;
            }
            if (info.tokenIndex !== undefined && info.tokenIndex !== null && info.tokenIndex !== '') {
                selector += `[data-token-index="${escapeAttr(info.tokenIndex)}"]`;
            }
            try {
                return document.querySelector(selector);
            } catch (error) {
                console.error('Failed to query selector for token restore:', selector, error);
                return null;
            }
        }
        
        function setSelectedTokenElement(tokenElement) {
            if (selectedTokenElement && selectedTokenElement !== tokenElement) {
                selectedTokenElement.classList.remove('token-selected');
            }
            if (tokenElement && tokenElement.classList && tokenElement.classList.contains('token')) {
                selectedTokenElement = tokenElement;
                selectedTokenElement.classList.add('token-selected');
            } else {
                selectedTokenElement = null;
            }
        }
        
        function persistSelectedToken(tokenElement) {
            if (!tokenElement || !tokenElement.classList || !tokenElement.classList.contains('token')) {
                localStorage.removeItem('tokenlens_selected_token');
                return;
            }
            const info = {
                nodeId: tokenElement.dataset.nodeId || null,
                tokenIndex: tokenElement.dataset.tokenIndex ?? null
            };
            localStorage.setItem('tokenlens_selected_token', JSON.stringify(info));
        }
        
        function restoreSelectedTokenHighlight(options = {}) {
            const { retry = 0, maxRetries = 5 } = options;
            const stored = localStorage.getItem('tokenlens_selected_token');
            if (!stored) return false;
            try {
                const info = JSON.parse(stored);
                const tokenElement = findTokenElementByInfo(info);
                if (tokenElement) {
                    const inspectorCollapsed = localStorage.getItem('tokenlens_inspector_collapsed') === 'true';
                    openInspector(tokenElement, inspectorCollapsed);
                    return true;
                }
                if (retry < maxRetries) {
                    setTimeout(() => restoreSelectedTokenHighlight({ retry: retry + 1, maxRetries }), 200);
                }
            } catch (error) {
                console.error('Failed to restore selected token highlight:', error);
            }
            return false;
        }
        
        // Inspector: Open with token data
        function openInspector(tokenElement, skipOpen = false) {
            const empty = document.getElementById('inspector-empty');
            const details = document.getElementById('inspector-token-details');
            
            // Show sidebar if collapsed (unless restoring from localStorage)
            if (!skipOpen) {
                setInspectorCollapsedState(false);
            }
            
            // Show details, hide empty state
            empty.style.display = 'none';
            details.classList.remove('hidden');
            
            // Populate token info
            const token = tokenElement.dataset.token;
            const probability = parseFloat(tokenElement.dataset.probability) * 100;
            const rank = tokenElement.dataset.rank;
            const vocabSize = tokenElement.dataset.vocabSize;
            const topAlternatives = tokenElement.dataset.topAlternatives ? JSON.parse(tokenElement.dataset.topAlternatives) : [];
            
            // Check if we're in Diff view and have DiffLens data
            const inDiffView = currentView === 'diff';
            const hasDiffLensData = tokenElement.dataset.difflensGenProb !== undefined;
            
            const currentTokenDiv = document.getElementById('inspector-current-token');
            currentTokenDiv.innerHTML = ''; // Clear existing
            
            let ruleAppliedInfo = null;
            if (tokenElement.dataset.ruleApplied) {
                try {
                    ruleAppliedInfo = JSON.parse(tokenElement.dataset.ruleApplied);
                } catch (error) {
                    console.warn('Failed to parse rule info:', error);
                }
            }
            const ruleBannerContainer = document.getElementById('inspector-rule-banner');
            if (ruleBannerContainer) {
                if (ruleAppliedInfo) {
                    ruleBannerContainer.style.display = 'block';
                    
                    // Build a friendly description of what happened
                    let description = '';
                    const actionType = ruleAppliedInfo.action || '';
                    const reason = ruleAppliedInfo.reason || '';
                    
                    // Extract what was actually changed - the token we're looking at
                    const currentToken = formatTokenForDisplay(token);
                    const originalToken = ruleAppliedInfo.original_token ? formatTokenForDisplay(ruleAppliedInfo.original_token) : null;
                    const resamplingChain = ruleAppliedInfo.resampling_chain || [];
                    
                    if (actionType === 'replace_text') {
                        description = originalToken 
                            ? `Replaced "${originalToken}" with "${currentToken}"`
                            : `Replaced original token with "${currentToken}"`;
                    } else if (actionType === 'resample_same') {
                        // Build chain visualization
                        if (resamplingChain.length > 0) {
                            const chainTokens = resamplingChain.map(c => formatTokenForDisplay(c.token));
                            const chainWithProbs = resamplingChain.map((c, idx) => {
                                const tkn = formatTokenForDisplay(c.token);
                                const prob = (c.probability * 100).toFixed(2);
                                const status = c.matched_rule ? '❌' : '✓';
                                return `${status} "${tkn}" (${prob}%)`;
                            }).join(' → ');
                            
                            description = originalToken
                                ? `Resampled "${originalToken}" through: ${chainWithProbs}`
                                : `Resampling chain: ${chainWithProbs}`;
                        } else {
                            const attemptMatch = reason.match(/attempt (\d+)/);
                            const attemptInfo = attemptMatch ? ` (attempt ${attemptMatch[1]})` : '';
                            description = originalToken
                                ? `Resampled "${originalToken}" → "${currentToken}"${attemptInfo}`
                                : `Resampled to "${currentToken}"${attemptInfo}`;
                        }
                    } else if (actionType === 'resample_other_model') {
                        // Extract model name from reason if present
                        const modelMatch = reason.match(/from (.+)/);
                        const modelInfo = modelMatch ? ` from ${modelMatch[1]}` : ' from another model';
                        description = originalToken
                            ? `Replaced "${originalToken}" with "${currentToken}"${modelInfo}`
                            : `Borrowed "${currentToken}"${modelInfo}`;
                    } else {
                        description = originalToken
                            ? `Changed "${originalToken}" to "${currentToken}"`
                            : reason || `Token changed to "${currentToken}"`;
                    }
                    
                    ruleBannerContainer.innerHTML = `
                        <div style="display: flex; align-items: center; gap: 8px;">
                            <svg width="14" height="14" viewBox="0 0 14 14" fill="none" style="flex-shrink: 0;">
                                <circle cx="7" cy="7" r="6" stroke="currentColor" stroke-width="1.5"/>
                                <path d="M7 4v3M7 9h.01" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                            </svg>
                            <div style="flex: 1; min-width: 0;">
                                <div style="font-weight: 600; margin-bottom: 2px;">${escapeHtml(ruleAppliedInfo.name || 'Auto Rule')}</div>
                                <div style="font-size: 0.8rem; opacity: 0.8;">${escapeHtml(description)}</div>
                            </div>
                        </div>
                    `;
                } else {
                    ruleBannerContainer.style.display = 'none';
                    ruleBannerContainer.innerHTML = '';
                }
            }
            
            if (inDiffView && hasDiffLensData) {
                // DiffLens mode: Show comparative view
                const difflensData = {
                    genProb: parseFloat(tokenElement.dataset.difflensGenProb),
                    genRank: parseInt(tokenElement.dataset.difflensGenRank),
                    genTopAlternatives: JSON.parse(tokenElement.dataset.difflensGenTopAlternatives || '[]'),
                    analysisProb: parseFloat(tokenElement.dataset.difflensAnalysisProb),
                    analysisRank: parseInt(tokenElement.dataset.difflensAnalysisRank),
                    analysisTopAlternatives: JSON.parse(tokenElement.dataset.difflensAnalysisTopAlternatives || '[]'),
                    probDiff: parseFloat(tokenElement.dataset.difflensProbDiff),
                    rankDiff: parseInt(tokenElement.dataset.difflensRankDiff),
                    genModel: tokenElement.dataset.difflensGenModel,
                    analysisModel: tokenElement.dataset.difflensAnalysisModel
                };
                
                // Token name at top
                const tokenNameDiv = document.createElement('div');
                tokenNameDiv.style.cssText = 'font-weight: 600; font-size: 1.125rem; margin-bottom: 12px; padding-bottom: 12px; border-bottom: 1px solid var(--border-color);';
                tokenNameDiv.textContent = formatTokenForDisplay(token);
                currentTokenDiv.appendChild(tokenNameDiv);
                
                // Diff stats
                const diffStatsDiv = document.createElement('div');
                diffStatsDiv.style.cssText = 'display: flex; gap: 16px; margin-bottom: 16px; padding: 8px; background: var(--bg-secondary); border-radius: 6px; font-size: 0.875rem;';
                diffStatsDiv.innerHTML = `
                    <div><strong>Prob Diff:</strong> <span style="color: ${difflensData.probDiff >= 0 ? 'green' : 'red'};">${difflensData.probDiff >= 0 ? '+' : ''}${difflensData.probDiff.toFixed(2)}%</span></div>
                    <div><strong>Rank Diff:</strong> <span style="color: ${difflensData.rankDiff <= 0 ? 'green' : 'red'};">${difflensData.rankDiff >= 0 ? '+' : ''}${difflensData.rankDiff}</span></div>
                `;
                currentTokenDiv.appendChild(diffStatsDiv);
                
                // Two-column comparison
                const comparisonDiv = document.createElement('div');
                comparisonDiv.style.cssText = 'display: grid; grid-template-columns: 1fr 1fr; gap: 12px;';
                
                // Generation model column
                const genCol = document.createElement('div');
                genCol.innerHTML = `
                    <div style="font-weight: 600; font-size: 0.75rem; text-transform: uppercase; color: var(--text-secondary); margin-bottom: 8px;">${difflensData.genModel || 'Generation'}</div>
                    <div style="font-size: 0.875rem; margin-bottom: 4px;"><strong>Prob:</strong> ${(difflensData.genProb * 100).toFixed(2)}%</div>
                    <div style="font-size: 0.875rem;"><strong>Rank:</strong> #${difflensData.genRank}</div>
                `;
                
                // Analysis model column
                const analysisCol = document.createElement('div');
                analysisCol.innerHTML = `
                    <div style="font-weight: 600; font-size: 0.75rem; text-transform: uppercase; color: var(--text-secondary); margin-bottom: 8px;">${difflensData.analysisModel || 'Analysis'}</div>
                    <div style="font-size: 0.875rem; margin-bottom: 4px;"><strong>Prob:</strong> ${(difflensData.analysisProb * 100).toFixed(2)}%</div>
                    <div style="font-size: 0.875rem;"><strong>Rank:</strong> #${difflensData.analysisRank}</div>
                `;
                
                comparisonDiv.appendChild(genCol);
                comparisonDiv.appendChild(analysisCol);
                currentTokenDiv.appendChild(comparisonDiv);
                
                // Show alternatives from both models
                const alternativesDiv = document.getElementById('inspector-alternatives');
                alternativesDiv.innerHTML = '';
                
                // Create two-column grid for alternatives
                const altComparisonDiv = document.createElement('div');
                altComparisonDiv.style.cssText = 'display: grid; grid-template-columns: 1fr 1fr; gap: 12px;';
                
                // Generation alternatives column
                const genAltCol = document.createElement('div');
                const genAltHeader = document.createElement('h4');
                genAltHeader.style.cssText = 'margin-bottom: 8px; font-size: 0.75rem; text-transform: uppercase; color: var(--text-secondary); font-weight: 600;';
                genAltHeader.textContent = 'Generation';
                genAltCol.appendChild(genAltHeader);
                
                difflensData.genTopAlternatives
                    .filter(alt => alt.token !== token)
                    .slice(0, 3)
                    .forEach((alt, idx) => {
                        const altDiv = document.createElement('div');
                        altDiv.style.cssText = 'padding: 8px; background: var(--bg-secondary); border-radius: 4px; margin-bottom: 4px; font-size: 0.8125rem; overflow-wrap: break-word; word-break: break-word;';
                        
                        const contentDiv = document.createElement('div');
                        contentDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; gap: 8px; min-width: 0;';
                        
                        const infoDiv = document.createElement('div');
                        infoDiv.style.cssText = 'display: flex; align-items: center; gap: 6px; flex: 1; min-width: 0;';
                        
                        const rankBadge = document.createElement('span');
                        rankBadge.className = 'alt-rank-badge';
                        rankBadge.style.cssText = 'flex-shrink: 0;';
                        rankBadge.textContent = `#${alt.rank ?? (idx + 1)}`;
                        
                        const tokenSpan = document.createElement('span');
                        tokenSpan.style.cssText = 'font-family: var(--font-mono); overflow-wrap: break-word; word-break: break-word; flex: 1; min-width: 0;';
                        tokenSpan.textContent = formatTokenForDisplay(alt.token);
                        
                        infoDiv.appendChild(rankBadge);
                        infoDiv.appendChild(tokenSpan);
                        
                        const probSpan = document.createElement('span');
                        probSpan.style.cssText = 'font-size: 0.7rem; color: var(--text-secondary); font-weight: 600; flex-shrink: 0;';
                        probSpan.textContent = `${(alt.probability * 100).toFixed(1)}%`;
                        
                        contentDiv.appendChild(infoDiv);
                        contentDiv.appendChild(probSpan);
                        altDiv.appendChild(contentDiv);
                        genAltCol.appendChild(altDiv);
                    });
                
                // Analysis alternatives column
                const analysisAltCol = document.createElement('div');
                const analysisAltHeader = document.createElement('h4');
                analysisAltHeader.style.cssText = 'margin-bottom: 8px; font-size: 0.75rem; text-transform: uppercase; color: var(--text-secondary); font-weight: 600;';
                analysisAltHeader.textContent = 'Analysis';
                analysisAltCol.appendChild(analysisAltHeader);
                
                difflensData.analysisTopAlternatives
                    .filter(alt => alt.token !== token)
                    .slice(0, 3)
                    .forEach((alt, idx) => {
                        const altDiv = document.createElement('div');
                        altDiv.style.cssText = 'padding: 8px; background: var(--bg-secondary); border-radius: 4px; cursor: pointer; transition: all 0.15s ease; margin-bottom: 4px; font-size: 0.8125rem; overflow-wrap: break-word; word-break: break-word;';
                        
                        const contentDiv = document.createElement('div');
                        contentDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; gap: 8px; min-width: 0;';
                        
                        const infoDiv = document.createElement('div');
                        infoDiv.style.cssText = 'display: flex; align-items: center; gap: 6px; flex: 1; min-width: 0;';
                        
                        const rankBadge = document.createElement('span');
                        rankBadge.className = 'alt-rank-badge';
                        rankBadge.style.cssText = 'flex-shrink: 0;';
                        rankBadge.textContent = `#${alt.rank ?? (idx + 1)}`;
                        
                        const tokenSpan = document.createElement('span');
                        tokenSpan.style.cssText = 'font-family: var(--font-mono); overflow-wrap: break-word; word-break: break-word; flex: 1; min-width: 0;';
                        tokenSpan.textContent = formatTokenForDisplay(alt.token);
                        
                        infoDiv.appendChild(rankBadge);
                        infoDiv.appendChild(tokenSpan);
                        
                        const probSpan = document.createElement('span');
                        probSpan.style.cssText = 'font-size: 0.7rem; color: var(--text-secondary); font-weight: 600; flex-shrink: 0;';
                        probSpan.textContent = `${(alt.probability * 100).toFixed(1)}%`;
                        
                        contentDiv.appendChild(infoDiv);
                        contentDiv.appendChild(probSpan);
                        altDiv.appendChild(contentDiv);
                        
                        altDiv.addEventListener('click', () => selectInspectorToken(alt.token, altDiv));
                        altDiv.addEventListener('mouseenter', () => altDiv.style.background = 'var(--bg-color)');
                        altDiv.addEventListener('mouseleave', () => altDiv.style.background = 'var(--bg-secondary)');
                        
                        analysisAltCol.appendChild(altDiv);
                    });
                
                altComparisonDiv.appendChild(genAltCol);
                altComparisonDiv.appendChild(analysisAltCol);
                alternativesDiv.appendChild(altComparisonDiv);
            } else {
                // Token view mode: Show normal view
                const tokenRow = document.createElement('div');
                tokenRow.style.cssText = 'display: flex; align-items: center; justify-content: space-between; margin-bottom: 8px;';
                const tokenSpan = document.createElement('span');
                tokenSpan.style.cssText = 'font-weight: 600; font-size: 1.125rem;';
                tokenSpan.textContent = formatTokenForDisplay(token);
                tokenRow.appendChild(tokenSpan);
                
                // Stats row
                const statsRow = document.createElement('div');
                statsRow.style.cssText = 'display: flex; gap: 16px; font-size: 0.875rem; color: var(--text-secondary);';
                
                const probDiv = document.createElement('div');
                probDiv.innerHTML = `<strong>Probability:</strong> ${probability.toFixed(2)}%`;
                
                const rankDiv = document.createElement('div');
                rankDiv.innerHTML = `<strong>Rank:</strong> #${rank}`;
                
                statsRow.appendChild(probDiv);
                statsRow.appendChild(rankDiv);
                
                currentTokenDiv.appendChild(tokenRow);
                currentTokenDiv.appendChild(statsRow);
                
                // Display alternatives
                const alternativesDiv = document.getElementById('inspector-alternatives');
                alternativesDiv.innerHTML = ''; // Clear existing
                
                topAlternatives
                    .filter(alt => alt.token !== token)
                    .forEach((alt, idx) => {
                        const altDiv = document.createElement('div');
                        altDiv.style.cssText = 'padding: 10px; background: var(--bg-secondary); border-radius: 6px; cursor: pointer; transition: all 0.15s ease; overflow-wrap: break-word; word-break: break-word;';
                        
                        const contentDiv = document.createElement('div');
                        contentDiv.style.cssText = 'display: flex; justify-content: space-between; align-items: center; gap: 8px; min-width: 0;';
                        
                    const infoDiv = document.createElement('div');
                    infoDiv.style.cssText = 'display: flex; align-items: center; gap: 6px; flex: 1; min-width: 0;';
                    
                    const rankBadge = document.createElement('span');
                    rankBadge.className = 'alt-rank-badge';
                    rankBadge.style.cssText = 'flex-shrink: 0;';
                    rankBadge.textContent = `#${alt.rank ?? (idx + 1)}`;
                    
                        const tokenSpan = document.createElement('span');
                        tokenSpan.style.cssText = 'font-family: var(--font-mono); font-size: 0.875rem; overflow-wrap: break-word; word-break: break-word; flex: 1; min-width: 0;';
                        tokenSpan.textContent = formatTokenForDisplay(alt.token);
                        
                    infoDiv.appendChild(rankBadge);
                    infoDiv.appendChild(tokenSpan);
                    
                        const probSpan = document.createElement('span');
                        probSpan.style.cssText = 'font-size: 0.75rem; color: var(--text-secondary); font-weight: 600; flex-shrink: 0;';
                        probSpan.textContent = `${(alt.probability * 100).toFixed(2)}%`;
                        
                    contentDiv.appendChild(infoDiv);
                        contentDiv.appendChild(probSpan);
                        altDiv.appendChild(contentDiv);
                        
                        // Add event listeners
                        altDiv.addEventListener('click', () => selectInspectorToken(alt.token, altDiv));
                        altDiv.addEventListener('mouseenter', () => altDiv.style.background = 'var(--bg-color)');
                        altDiv.addEventListener('mouseleave', () => altDiv.style.background = 'var(--bg-secondary)');
                        
                        alternativesDiv.appendChild(altDiv);
                    });
            }
            
            // Clear inject input
            const injectInput = document.getElementById('inspector-inject-input');
            if (injectInput) {
                injectInput.value = '';
            }
            
            const isRealToken = tokenElement.classList && tokenElement.classList.contains('token');
            if (isRealToken) {
                setSelectedTokenElement(tokenElement);
                persistSelectedToken(tokenElement);
            }
            
            // Setup action buttons
            setupInspectorButtons();
            
            // Save inspector content to localStorage for persistence
            const inspectorData = {
                token: tokenElement.dataset.token,
                probability: tokenElement.dataset.probability,
                rank: tokenElement.dataset.rank,
                vocabSize: tokenElement.dataset.vocabSize,
                topAlternatives: tokenElement.dataset.topAlternatives,
                tokenId: tokenElement.dataset.tokenId,
                temperature: tokenElement.dataset.temperature,
                isPrefillToken: tokenElement.dataset.isPrefillToken,
                isInjected: tokenElement.dataset.isInjected,
                nodeId: tokenElement.dataset.nodeId || null,
                tokenIndex: tokenElement.dataset.tokenIndex ?? null,
                ruleApplied: tokenElement.dataset.ruleApplied || null,
                // DiffLens data if available
                difflensGenProb: tokenElement.dataset.difflensGenProb,
                difflensGenRank: tokenElement.dataset.difflensGenRank,
                difflensGenTopAlternatives: tokenElement.dataset.difflensGenTopAlternatives,
                difflensAnalysisProb: tokenElement.dataset.difflensAnalysisProb,
                difflensAnalysisRank: tokenElement.dataset.difflensAnalysisRank,
                difflensAnalysisTopAlternatives: tokenElement.dataset.difflensAnalysisTopAlternatives,
                difflensProbDiff: tokenElement.dataset.difflensProbDiff,
                difflensRankDiff: tokenElement.dataset.difflensRankDiff,
                difflensGenModel: tokenElement.dataset.difflensGenModel,
                difflensAnalysisModel: tokenElement.dataset.difflensAnalysisModel
            };
            localStorage.setItem('tokenlens_inspector_content', JSON.stringify(inspectorData));
        }
        
        function restoreInspectorContent() {
            const savedContent = localStorage.getItem('tokenlens_inspector_content');
            if (!savedContent) return;
            
            try {
                const inspectorData = JSON.parse(savedContent);
                
                const possibleToken = findTokenElementByInfo({
                    nodeId: inspectorData.nodeId,
                    tokenIndex: inspectorData.tokenIndex
                });
                if (possibleToken) {
                    const inspectorCollapsed = localStorage.getItem('tokenlens_inspector_collapsed') === 'true';
                    openInspector(possibleToken, inspectorCollapsed);
                    return;
                }
                
                // Create a virtual token element with the saved data
                const virtualTokenElement = document.createElement('span');
                virtualTokenElement.dataset.token = inspectorData.token;
                virtualTokenElement.dataset.probability = inspectorData.probability;
                virtualTokenElement.dataset.rank = inspectorData.rank;
                virtualTokenElement.dataset.vocabSize = inspectorData.vocabSize;
                virtualTokenElement.dataset.topAlternatives = inspectorData.topAlternatives;
                virtualTokenElement.dataset.tokenId = inspectorData.tokenId;
                virtualTokenElement.dataset.temperature = inspectorData.temperature;
                virtualTokenElement.dataset.isPrefillToken = inspectorData.isPrefillToken;
                virtualTokenElement.dataset.isInjected = inspectorData.isInjected;
                if (inspectorData.nodeId) virtualTokenElement.dataset.nodeId = inspectorData.nodeId;
                if (inspectorData.tokenIndex !== undefined && inspectorData.tokenIndex !== null) {
                    virtualTokenElement.dataset.tokenIndex = inspectorData.tokenIndex;
                }
                if (inspectorData.ruleApplied) {
                    virtualTokenElement.dataset.ruleApplied = inspectorData.ruleApplied;
                }
                
                // Add DiffLens data if available
                if (inspectorData.difflensGenProb !== undefined) {
                    virtualTokenElement.dataset.difflensGenProb = inspectorData.difflensGenProb;
                    virtualTokenElement.dataset.difflensGenRank = inspectorData.difflensGenRank;
                    virtualTokenElement.dataset.difflensGenTopAlternatives = inspectorData.difflensGenTopAlternatives;
                    virtualTokenElement.dataset.difflensAnalysisProb = inspectorData.difflensAnalysisProb;
                    virtualTokenElement.dataset.difflensAnalysisRank = inspectorData.difflensAnalysisRank;
                    virtualTokenElement.dataset.difflensAnalysisTopAlternatives = inspectorData.difflensAnalysisTopAlternatives;
                    virtualTokenElement.dataset.difflensProbDiff = inspectorData.difflensProbDiff;
                    virtualTokenElement.dataset.difflensRankDiff = inspectorData.difflensRankDiff;
                    virtualTokenElement.dataset.difflensGenModel = inspectorData.difflensGenModel;
                    virtualTokenElement.dataset.difflensAnalysisModel = inspectorData.difflensAnalysisModel;
                }
                
                // Open inspector with the restored data (without forcing it open)
                openInspector(virtualTokenElement, true);
            } catch (error) {
                // Failed to restore, clear the corrupted data
                localStorage.removeItem('tokenlens_inspector_content');
            }
        }
        
        function selectInspectorToken(token, element) {
            // Highlight selected
            document.querySelectorAll('#inspector-alternatives > div').forEach(div => {
                div.style.background = 'var(--bg-secondary)';
                div.style.borderLeft = 'none';
            });
            element.style.background = 'var(--primary-light)';
            element.style.borderLeft = '3px solid var(--text-color)';
            
            // Populate inject input with selected token
            const injectInput = document.getElementById('inspector-inject-input');
            if (injectInput) {
                injectInput.value = token;
                injectInput.focus();
            }
        }
        
        function setupInspectorButtons() {
            const injectBtn = document.getElementById('inspector-inject-btn');
            const logitLensBtn = document.getElementById('inspector-logit-lens-btn');
            
            if (injectBtn) {
                injectBtn.onclick = () => injectAndRegenerate();
            }
            
            if (logitLensBtn) {
                logitLensBtn.onclick = (event) => {
                    event.stopPropagation(); // Prevent immediate modal close
                    if (selectedTokenElement) {
                        openLogitLens(selectedTokenElement);
                    } else {
                        console.error('No token element selected!');
                    }
                };
            }
        }
        
        // Toggle prefill input visibility
        function togglePrefillInput() {
            const checkbox = document.getElementById('enable-prefill-checkbox');
            const container = document.getElementById('prefill-input-container');
            
            if (checkbox && container) {
                if (checkbox.checked) {
                    container.style.display = 'flex';
                    // Save state to localStorage
                    localStorage.setItem('tokenlens_prefill_enabled', 'true');
                } else {
                    container.style.display = 'none';
                    // Clear prefill input and save state
                    const prefillInput = document.getElementById('prefill-input');
                    if (prefillInput) {
                        prefillInput.value = '';
                        localStorage.setItem('tokenlens_prefill_text', '');
                    }
                    localStorage.setItem('tokenlens_prefill_enabled', 'false');
                }
            }
        }
        
        // Toggle DiffLens input visibility
        function toggleDiffLensInput(skipViewReset = false) {
            const checkbox = document.getElementById('enable-difflens-checkbox');
            const container = document.getElementById('difflens-input-container');
            
            if (checkbox && container) {
                if (checkbox.checked) {
                    container.style.display = 'flex';
                    localStorage.setItem('tokenlens_difflens_enabled', 'true');
                    // Don't auto-switch to diff view - wait for Apply Diff
                } else {
                    container.style.display = 'none';
                    // Clear analysis and reset
                    clearDiffLensAnalysis();
                    const analysisInput = document.getElementById('analysis-model-input');
                    if (analysisInput) {
                        analysisInput.value = '';
                    }
                    localStorage.setItem('tokenlens_difflens_enabled', 'false');
                    
                    if (!skipViewReset) {
                        // Switch back to Token view
                        const viewSelect = document.getElementById('view-select');
                        const viewSelectMenu = document.getElementById('view-select-menu');
                        if (viewSelect) viewSelect.value = 'token';
                        if (viewSelectMenu) viewSelectMenu.value = 'token';
                        currentView = 'token';
                        switchView();
                    }
                }
            }
        }
        
        // Simplified hover tooltip
        function showSimplifiedTooltip(tokenElement) {
            const tooltip = document.getElementById('token-tooltip');
            const token = tokenElement.dataset.token;
            const probability = parseFloat(tokenElement.dataset.probability) * 100;
            const rank = tokenElement.dataset.rank;
            const topAlternatives = tokenElement.dataset.topAlternatives ? JSON.parse(tokenElement.dataset.topAlternatives) : [];
            
            // Check if we're in Diff view and have DiffLens data
            const inDiffView = currentView === 'diff';
            const hasDiffLensData = tokenElement.dataset.difflensGenProb !== undefined;
            
            // Set tooltip content
            const currentTokenDiv = document.getElementById('tooltip-current-token');
            
            if (inDiffView && hasDiffLensData) {
                // Show DiffLens comparison
                const probDiff = parseFloat(tokenElement.dataset.difflensProbDiff);
                const rankDiff = parseInt(tokenElement.dataset.difflensRankDiff);
                const analysisProb = parseFloat(tokenElement.dataset.difflensAnalysisProb) * 100;
                const analysisRank = parseInt(tokenElement.dataset.difflensAnalysisRank);
                const genTopAlternatives = JSON.parse(tokenElement.dataset.difflensGenTopAlternatives || '[]');
                const analysisTopAlternatives = JSON.parse(tokenElement.dataset.difflensAnalysisTopAlternatives || '[]');
                
                currentTokenDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; font-family: var(--font-mono); margin-bottom: 6px;">
                        <span style="font-weight: 600;">${formatTokenForDisplay(token)}</span>
                    </div>
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; font-size: 0.7rem; margin-bottom: 6px;">
                        <div>
                            <div style="color: var(--text-secondary); text-transform: uppercase; font-size: 0.65rem; margin-bottom: 2px;">Generation</div>
                            <div>${probability.toFixed(1)}% · #${rank}</div>
                        </div>
                        <div>
                            <div style="color: var(--text-secondary); text-transform: uppercase; font-size: 0.65rem; margin-bottom: 2px;">Analysis</div>
                            <div>${analysisProb.toFixed(1)}% · #${analysisRank}</div>
                        </div>
                    </div>
                    <div style="font-size: 0.7rem; color: var(--text-secondary); padding-top: 4px; border-top: 1px solid var(--border-color);">
                        Diff: <span style="color: ${probDiff >= 0 ? 'green' : 'red'};">${probDiff >= 0 ? '+' : ''}${probDiff.toFixed(1)}%</span> · 
                        <span style="color: ${rankDiff <= 0 ? 'green' : 'red'};">${rankDiff >= 0 ? '+' : ''}${rankDiff}</span>
                    </div>
                `;
                
                // Show alternatives from both models
                const altDiv = document.getElementById('tooltip-alternatives');
                const genAlts = genTopAlternatives
                    .filter(alt => alt.token !== token)
                    .slice(0, 2)
                    .map(alt => 
                        `${formatTokenForDisplay(alt.token)} (${(alt.probability * 100).toFixed(1)}%)`
                    ).join(', ');
                const analysisAlts = analysisTopAlternatives
                    .filter(alt => alt.token !== token)
                    .slice(0, 2)
                    .map(alt => 
                        `${formatTokenForDisplay(alt.token)} (${(alt.probability * 100).toFixed(1)}%)`
                    ).join(', ');
                
                altDiv.innerHTML = `
                    <div style="font-size: 0.7rem; margin-bottom: 4px;">
                        <span style="color: var(--text-secondary); text-transform: uppercase; font-size: 0.65rem;">Gen:</span> ${genAlts}
                    </div>
                    <div style="font-size: 0.7rem;">
                        <span style="color: var(--text-secondary); text-transform: uppercase; font-size: 0.65rem;">Ana:</span> ${analysisAlts}
                    </div>
                `;
            } else {
                // Show normal token view
                currentTokenDiv.innerHTML = `
                    <div style="display: flex; justify-content: space-between; align-items: center; font-family: var(--font-mono); margin-bottom: 4px;">
                        <span style="font-weight: 600;">${formatTokenForDisplay(token)}</span>
                        <span style="font-size: 0.75rem; color: var(--text-secondary);">${probability.toFixed(1)}%</span>
                    </div>
                    <div style="font-size: 0.7rem; color: var(--text-secondary);">Rank: #${rank}</div>
                `;
                
                const altDiv = document.getElementById('tooltip-alternatives');
                altDiv.innerHTML = topAlternatives
                    .filter(alt => alt.token !== token)
                    .slice(0, 2)
                    .map(alt => 
                        `<span style="font-size: 0.75rem; margin-right: 8px;">${formatTokenForDisplay(alt.token)} (${(alt.probability * 100).toFixed(1)}%)</span>`
                    ).join('');
            }
            
            const existingRuleBanner = document.getElementById('tooltip-rule-banner');
            if (existingRuleBanner) {
                existingRuleBanner.remove();
            }
            if (tokenElement.dataset.ruleApplied) {
                try {
                    const ruleInfo = JSON.parse(tokenElement.dataset.ruleApplied);
                    const banner = document.createElement('div');
                    banner.id = 'tooltip-rule-banner';
                    banner.className = 'tooltip-rule-banner';
                    
                    // Build a friendly description with the actual token
                    const currentToken = formatTokenForDisplay(token);
                    const originalToken = ruleInfo.original_token ? formatTokenForDisplay(ruleInfo.original_token) : null;
                    const resamplingChain = ruleInfo.resampling_chain || [];
                    let description = '';
                    const actionType = ruleInfo.action || '';
                    const reason = ruleInfo.reason || '';
                    
                    if (actionType === 'replace_text') {
                        description = originalToken ? `"${originalToken}" → "${currentToken}"` : `Replaced → "${currentToken}"`;
                    } else if (actionType === 'resample_same') {
                        if (resamplingChain.length > 0) {
                            // Show compact chain
                            const chain = resamplingChain.map(c => formatTokenForDisplay(c.token)).join(' → ');
                            description = originalToken ? `"${originalToken}" → ${chain}` : `Chain: ${chain}`;
                        } else {
                            description = originalToken ? `"${originalToken}" → "${currentToken}"` : `Resampled → "${currentToken}"`;
                        }
                    } else if (actionType === 'resample_other_model') {
                        const modelMatch = reason.match(/from (.+)/);
                        const modelInfo = modelMatch ? ` (${modelMatch[1]})` : '';
                        description = originalToken 
                            ? `"${originalToken}" → "${currentToken}"${modelInfo}`
                            : `Borrowed → "${currentToken}"${modelInfo}`;
                    } else {
                        description = originalToken ? `"${originalToken}" → "${currentToken}"` : `Changed → "${currentToken}"`;
                    }
                    
                    banner.innerHTML = `⚙ <strong>${escapeHtml(ruleInfo.name || 'Rule')}</strong>: ${escapeHtml(description)}`;
                    currentTokenDiv.appendChild(banner);
                } catch (error) {
                    // ignore parse issues
                }
            }
            
            // Position tooltip with viewport safety
            const rect = tokenElement.getBoundingClientRect();
            
            // Show temporarily to measure
            tooltip.style.visibility = 'hidden';
            tooltip.classList.remove('hidden');
            const tooltipRect = tooltip.getBoundingClientRect();
            tooltip.style.visibility = 'visible';
            
            let left = rect.left;
            let top = rect.bottom + 8;
            
            // Keep within horizontal viewport
            if (left + tooltipRect.width > window.innerWidth - 16) {
                left = window.innerWidth - tooltipRect.width - 16;
            }
            if (left < 16) {
                left = 16;
            }
            
            // Keep within vertical viewport (flip if needed)
            if (top + tooltipRect.height > window.innerHeight - 16) {
                top = rect.top - tooltipRect.height - 8;
                if (top < 16) {
                    top = rect.bottom + 8; // fallback to below
                }
            }
            
            tooltip.style.left = `${left}px`;
            tooltip.style.top = `${top}px`;
        }
        
        function hideSimplifiedTooltip() {
            const tooltip = document.getElementById('token-tooltip');
            tooltip.classList.add('hidden');
        }
        
        // === END: Menu and Inspector Functions ===
        
        document.addEventListener('DOMContentLoaded', function() {
            loadSamplingSettings();
            loadGenerationRules();
            renderRulesModal();
            
            // Setup menu syncing
            setupMenuSyncing();
            syncMenuFields();
            
            // Restore current view from localStorage
            const savedView = localStorage.getItem('tokenlens_current_view') || 'token';
            currentView = savedView;
            const viewSelect = document.getElementById('view-select');
            const viewSelectMenu = document.getElementById('view-select-menu');
            if (viewSelect) viewSelect.value = savedView;
            if (viewSelectMenu) viewSelectMenu.value = savedView;
            switchView();
            
            // Restore highlight mode from localStorage
            const savedHighlightMode = localStorage.getItem('tokenlens_highlight_mode') || 'probability';
            const highlightSelectMenu = document.getElementById('highlight-mode-select-menu');
            const highlightSelect = document.getElementById('highlight-mode-select');
            if (highlightSelectMenu) highlightSelectMenu.value = savedHighlightMode;
            if (highlightSelect) highlightSelect.value = savedHighlightMode;
            currentHighlightMode = savedHighlightMode;
            
            // Restore prefill enabled state from localStorage
            const prefillEnabled = localStorage.getItem('tokenlens_prefill_enabled') === 'true';
            const prefillCheckbox = document.getElementById('enable-prefill-checkbox');
            if (prefillCheckbox) {
                prefillCheckbox.checked = prefillEnabled;
                togglePrefillInput(); // Apply the state
            }
            
            // Restore DiffLens enabled state from localStorage
            const difflensEnabled = localStorage.getItem('tokenlens_difflens_enabled') === 'true';
            const difflensCheckbox = document.getElementById('enable-difflens-checkbox');
            if (difflensCheckbox) {
                difflensCheckbox.checked = difflensEnabled;
                toggleDiffLensInput(true); // Apply the state without overriding view
            }
            
            // Restore diff model selection from localStorage
            const savedDiffModel = localStorage.getItem('tokenlens_diff_model');
            const diffModelSelect = document.getElementById('analysis-model-input');
            if (savedDiffModel && diffModelSelect) {
                diffModelSelect.value = savedDiffModel;
            }
            
            // Restore prefill text from localStorage
            const savedPrefillText = localStorage.getItem('tokenlens_prefill_text');
            const prefillInputRestore = document.getElementById('prefill-input');
            if (savedPrefillText && prefillInputRestore) {
                prefillInputRestore.value = savedPrefillText;
            }
            
            // Restore inspector content first (without opening)
            restoreInspectorContent();
            
            // Then restore inspector sidebar state from localStorage
            const savedInspectorState = localStorage.getItem('tokenlens_inspector_collapsed');
            setInspectorCollapsedState(savedInspectorState === 'true');
            
            // Load default system prompt
            loadDefaultSystemPrompt();
            
            // Setup tooltip handlers
            setupTooltipHandlers();
            
            // Setup token search
            setupTokenSearchListener();
            
            // Setup inspector buttons
            setupInspectorButtons();
            
            // Add event listener to save diff model selection
            const diffModelSelectInput = document.getElementById('analysis-model-input');
            if (diffModelSelectInput) {
                diffModelSelectInput.addEventListener('change', (e) => {
                    localStorage.setItem('tokenlens_diff_model', e.target.value);
                });
            }
            
            // Add event listener to save prefill text
            const prefillInputListener = document.getElementById('prefill-input');
            if (prefillInputListener) {
                prefillInputListener.addEventListener('input', (e) => {
                    localStorage.setItem('tokenlens_prefill_text', e.target.value);
                });
            }
            
            initializeSidebar();
            initializeConversations().then(() => {
                if (currentConversationId) {
                    const currentPath = window.location.pathname;
                    const expectedPath = `/chat/${currentConversationId}`;
                    
                    if (currentPath !== expectedPath) {
                        window.history.replaceState(
                            { conversationId: currentConversationId },
                            '',
                            expectedPath
                        );
                        console.log('Updated URL to match loaded conversation:', expectedPath);
                    } else {
                        window.history.replaceState(
                            { conversationId: currentConversationId },
                            '',
                            currentPath
                        );
                    }
                }
                
                // Ensure loaded tokens reflect the current view preference
                switchView();
            });
        });
        
        async function searchTokens(query) {
            const modelName = document.getElementById('model-select').value;
            const resultsDiv = document.getElementById('token-search-results');
            
            console.log('Searching tokens for:', query, 'with model:', modelName);
            
            try {
                const response = await fetch('/api/search-tokens', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({query: query, model: modelName})
                });
                
                if (!response.ok) {
                    console.error('Search request failed:', response.status);
                    resultsDiv.innerHTML = '<div class="search-error">Search failed</div>';
                    return;
                }
                
                const results = await response.json();
                console.log('Search results:', results.length, 'tokens found');
                
                resultsDiv.innerHTML = '';
                
                if (results.length === 0) {
                    resultsDiv.innerHTML = '<div class="search-no-results">No matches found</div>';
                    return;
                }
                
                results.forEach((result, idx) => {
                    const item = document.createElement('div');
                    item.className = 'search-result-item';
                    item.onclick = () => selectAlternativeToken(result.token, item);
                    
                    const displaySearchToken = formatTokenForDisplay(result.token, { useSpaceSymbol: false });
                    
                    // Build probability badge if available
                    let probHTML = '';
                    if (result.probability !== null && result.probability !== undefined) {
                        probHTML = `<span class="alt-prob">${(result.probability * 100).toFixed(1)}%</span>`;
                    }
                    
                    item.innerHTML = `
                        <span class="alt-token"></span>
                        ${probHTML}
                    `;
                    
                    // Set token text directly to preserve all characters
                    const searchTokenEl = item.querySelector('.alt-token');
                    searchTokenEl.textContent = displaySearchToken;
                    
                    resultsDiv.appendChild(item);
                    
                    console.log(`Search result ${idx}:`, result.token, result.probability);
                });
            } catch (error) {
                console.error('Token search failed:', error);
                resultsDiv.innerHTML = '<div class="search-error">Search error: ' + error.message + '</div>';
            }
        }
        
        async function injectAndRegenerate() {
            if (!selectedTokenElement) {
                alert('Please select a token first');
                return;
            }
            
            const injectInput = document.getElementById('inspector-inject-input');
            const injectedText = injectInput ? injectInput.value.trim() : '';
            
            if (!injectedText) {
                alert('Please enter text to inject');
                return;
            }
            
            const tokenIndex = parseInt(selectedTokenElement.dataset.tokenIndex);
            const nodeId = selectedTokenElement.dataset.nodeId;
            
            // Find the message node
            const node = messageTree[nodeId];
            if (!node || node.role !== 'assistant') {
                alert('Cannot inject: invalid message or not an assistant message');
                return;
            }
            
            // Get parent node (User message) to branch from
            const parentId = node.parentId;
            if (!parentId) {
                alert('Cannot inject: no parent message found');
                return;
            }
            
            console.log('=== INJECT AND REGENERATE ===');
            console.log('Clicked token index:', tokenIndex);
            console.log('Total tokens in message:', node.tokens.length);
            console.log('Injected text:', injectedText);
            
            // Build the FULL prefill text: all tokens BEFORE the clicked token + the injected text
            // This REPLACES the clicked token and everything after it
            const tokensBeforeInjection = node.tokens.slice(0, tokenIndex); // Excludes clicked token
            console.log('Keeping tokens 0 to', tokenIndex - 1, '(', tokensBeforeInjection.length, 'tokens)');
            
            let fullPrefillText = '';
            for (const tokenData of tokensBeforeInjection) {
                fullPrefillText += tokenData.token;
            }
            const prefillStartIndex = tokensBeforeInjection.length; // Where injected tokens will start
            fullPrefillText += injectedText; // Add the injected text (may be multiple tokens)
            
            console.log('Full prefill length:', fullPrefillText.length);
            console.log('Prefill ends with:', fullPrefillText.substring(Math.max(0, fullPrefillText.length - 30)));
            console.log('Prefill tokens start at index:', prefillStartIndex);
            
            // Store tokens before injection for pre-rendering (keep them visible, no gray animation)
            window.preRenderTokens = tokensBeforeInjection;
            
            // Set current leaf to parent to branch from there
            currentLeafId = parentId;
            
            // Remove the old assistant message from DOM
            const messageDiv = document.querySelector(`.message[data-node-id="${nodeId}"]`);
            if (messageDiv) {
                messageDiv.remove();
            }
            
            // Close inspector sidebar and persist state
            setInspectorCollapsedState(true);
            
            // Clear the inject input
            if (injectInput) {
                injectInput.value = '';
            }
            
            // Trigger generation with prefill
            // Backend will stream back all tokens including the prefill
            // Prefill tokens start at prefillStartIndex
            await generateResponse(fullPrefillText, prefillStartIndex);
        }

        function openLogitLensFromTooltip() {
            if (!selectedTokenElement) {
                alert('Please select a token first');
                return;
            }
            
            const tokenElement = selectedTokenElement;
            
            hideUnifiedTooltip('click');
            openLogitLens(tokenElement);
        }
        
        async function continueGenerationFromPoint(tokensContainer, prefillText, tokensBeforeInjection, injectedTokenData, startingIndex) {
            isGenerating = true;
            updateSendButton();
            const modelName = document.getElementById('model-select').value;
            const messagesContainer = document.getElementById('messages-container');
            
            let assistantResponse = prefillText;
            let allTokens = [...tokensBeforeInjection];  // Include pre-injection tokens
            
            // Add the injected token to the list with its probability data
            allTokens.push(injectedTokenData);
            
            try {
                // Create abort controller for this generation
                currentAbortController = new AbortController();
                
                const response = await fetch('/stream', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        messages: conversationHistory,
                        model: modelName,
                        prefill: prefillText,
                        rules: generationRules
                    }),
                    signal: currentAbortController.signal
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value, {stream: true});
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const jsonStr = line.substring(6);
                            try {
                                const data = JSON.parse(jsonStr);
                                
                                if (data.type === 'token') {
                                    const isPromptToken = data.is_prompt_token || false;
                                    
                                    // Skip prompt tokens
                                    if (isPromptToken) continue;
                                    
                                    assistantResponse += data.token;
                                    const tokenIdx = allTokens.length;
                                    allTokens.push({
                                        token: data.token,
                                        token_id: data.token_id,
                                        probability: data.probability,
                                        rank: data.rank,
                                        vocab_size: data.vocab_size,
                                        top_alternatives: data.top_alternatives,
                                        rule_applied: data.rule_applied || null
                                    });
                                    addToken(
                                        tokensContainer,
                                        data.token,
                                        data.probability,
                                        data.rank,
                                        data.vocab_size,
                                        data.top_alternatives,
                                        tokenIdx,
                                        null,
                                        null,
                                        null,
                                        data.token_id,
                                        data.rule_applied || null
                                    );
                                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                } else if (data.type === 'done') {
                                    // Save complete message to conversation
                                    conversationHistory.push({
                                        role: 'assistant',
                                        content: assistantResponse,
                                        tokens: allTokens
                                    });
                                    saveCurrentConversation(true);
                                    isGenerating = false;
                                    currentAbortController = null;
                                    updateSendButton();
                                    break;
                                }
                            } catch (e) {
                                // Skip invalid JSON
                            }
                        }
                    }
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('Generation stopped by user');
                    // Save partial response
                    conversationHistory.push({
                        role: 'assistant',
                        content: assistantResponse,
                        tokens: allTokens
                    });
                    saveCurrentConversation(true);
                } else {
                console.error('Continuation failed:', error);
                tokensContainer.innerHTML += `<div class="error-message">Error: ${error.message}</div>`;
                }
                isGenerating = false;
                currentAbortController = null;
                updateSendButton();
            }
        }

        // ===== CONVERSATION MANAGEMENT =====
        
        async function initializeConversations() {
            console.log('Initializing conversations...');
            console.log('URL conversation ID:', urlConversationId);
            
            // Load conversations from server
            try {
                const response = await fetch('/api/conversations');
                const serverConvs = JSON.parse(await response.text());
                conversations = serverConvs;
                console.log('Loaded conversations from server:', Object.keys(conversations));
            } catch (error) {
                console.error('Failed to load conversations from server:', error);
                // Fallback to localStorage
                const saved = localStorage.getItem('tokenlens_conversations');
                if (saved) {
                    conversations = JSON.parse(saved);
                    console.log('Loaded conversations from localStorage:', Object.keys(conversations));
                }
            }
            
            // Priority 1: Load conversation from URL if provided
            if (urlConversationId) {
                console.log('Attempting to load conversation from URL:', urlConversationId);
                if (conversations[urlConversationId]) {
                    console.log('Found conversation in loaded data, loading...');
                    loadConversation(urlConversationId, false); // false = don't update URL
                    updateSidebar();
                    return;
                } else {
                    console.warn('Conversation', urlConversationId, 'not found in loaded conversations');
                    console.log('Available conversations:', Object.keys(conversations));
                    // Show error message to user
                    alert(`Conversation not found. It may have been deleted or doesn't exist.`);
                    // Redirect to home
                    window.location.href = '/';
                    return;
                }
            }
            
            // Priority 2: Load active conversation from localStorage
            currentConversationId = localStorage.getItem('tokenlens_active_conversation');
            
            // If no conversations exist, create a new one
            if (Object.keys(conversations).length === 0) {
                console.log('No conversations found, creating new one');
                createNewChat();
            } else {
                // Load the active conversation or the most recent one
                if (!currentConversationId || !conversations[currentConversationId]) {
                    const conversationIds = Object.keys(conversations).sort((a, b) => 
                        conversations[b].timestamp - conversations[a].timestamp
                    );
                    currentConversationId = conversationIds[0];
                    console.log('Loading most recent conversation:', currentConversationId);
                } else {
                    console.log('Loading active conversation:', currentConversationId);
                }
                loadConversation(currentConversationId);
            }
            
            updateSidebar();
        }
        
        function createNewChat() {
            // Save current conversation before creating new one
            if (currentConversationId) {
                saveCurrentConversation();
            }
            
            // Create new conversation
            const id = 'conv_' + Date.now();
            conversations[id] = {
                id: id,
                title: 'New Chat',
                timestamp: Date.now(),
                messageTree: {},
                currentLeafId: null,
                model: document.getElementById('model-select').value
            };
            
            currentConversationId = id;
            messageTree = {};
            currentLeafId = null;
            // conversationHistory = []; // Removed as it's derived
            
            // Clear UI
            clearChat();
            
            // Update URL
            updateUrl(id);
            
            // Save and update sidebar
            saveConversations();
            updateSidebar();
        }
        
        function saveCurrentConversation(updateTimestamp = false) {
            if (!currentConversationId) return;
            
            const conversation = conversations[currentConversationId];
            if (!conversation) return;
            
            // Update conversation object with current tree state
            conversation.messageTree = messageTree;
            conversation.currentLeafId = currentLeafId;
            conversation.model = document.getElementById('model-select').value;
            conversation.systemPrompt = currentSystemPrompt;
            conversation.viewMode = currentView;  // Save current view mode
            
            // Also save linear messages for backwards compatibility or preview
            // conversation.messages = getActiveThread(); 
            
            // Only update timestamp when new content is added, not when just switching
            if (updateTimestamp) {
                conversation.timestamp = Date.now();
            }
            
            // Generate title from first user message
            const thread = getActiveThread();
            if (thread.length > 0 && conversation.title === 'New Chat') {
                const firstUserMsg = thread.find(msg => msg.role === 'user');
                if (firstUserMsg) {
                    conversation.title = firstUserMsg.content.substring(0, 50);
                    if (firstUserMsg.content.length > 50) {
                        conversation.title += '...';
                    }
                }
            }
            
            saveConversations();
            updateSidebar();
        }
        
        async function saveConversations() {
            // Save to server
            if (currentConversationId && conversations[currentConversationId]) {
                try {
                    await fetch(`/api/conversations/${currentConversationId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(conversations[currentConversationId])
                    });
                } catch (error) {
                    console.error('Failed to save conversation to server:', error);
                }
            }
            
            // Also save to localStorage as backup
            localStorage.setItem('tokenlens_conversations', JSON.stringify(conversations));
            localStorage.setItem('tokenlens_active_conversation', currentConversationId);
        }
        
        function loadConversation(id, updateUrlFlag = true) {
            // Save current conversation first
            if (currentConversationId && currentConversationId !== id) {
                saveCurrentConversation();
            }
            
            const conversation = conversations[id];
            if (!conversation) return;
            
            currentConversationId = id;
            
            // Handle legacy format (list of messages) vs new format (tree)
            if (conversation.messageTree) {
                messageTree = conversation.messageTree;
                currentLeafId = conversation.currentLeafId;
            } else if (conversation.messages) {
                // Migrate legacy messages to tree
                console.log('Migrating legacy conversation to tree format');
                messageTree = {};
                let prevId = null;
                
                conversation.messages.forEach(msg => {
                    const nodeId = uuidv4();
                    const node = {
                        id: nodeId,
                        parentId: prevId,
                        childrenIds: [],
                        role: msg.role,
                        content: msg.content,
                        tokens: msg.tokens || [],
                        model: msg.role === 'assistant' ? (conversation.model || 'meta-llama/Llama-3.1-8B-Instruct') : null,
                        temperature: 1.0,
                        timestamp: Date.now(),
                        difflens_data: msg.difflens_data || null
                    };
                    
                    messageTree[nodeId] = node;
                    
                    if (prevId && messageTree[prevId]) {
                        messageTree[prevId].childrenIds.push(nodeId);
                    }
                    
                    prevId = nodeId;
                });
                
                currentLeafId = prevId;
            } else {
                // Empty
                messageTree = {};
                currentLeafId = null;
            }
            
            // Set model
            document.getElementById('model-select').value = conversation.model || 'meta-llama/Llama-3.1-8B-Instruct';
            
            // Load system prompt
            currentSystemPrompt = conversation.systemPrompt || '';
            const systemPromptInput = document.getElementById('system-prompt-input');
            if (systemPromptInput) {
                systemPromptInput.value = currentSystemPrompt;
            }
            updateSystemPromptBubble();
            
            // Restore view mode for this conversation
            if (conversation.viewMode) {
                const viewSelect = document.getElementById('view-select');
                const viewSelectMenu = document.getElementById('view-select-menu');
                if (viewSelect) viewSelect.value = conversation.viewMode;
                if (viewSelectMenu) viewSelectMenu.value = conversation.viewMode;
                currentView = conversation.viewMode;
                switchView();
            }
            
            // Render messages
            renderActiveThread();
            
            // Update URL if requested
            if (updateUrlFlag) {
                updateUrl(id);
            }
            
            saveConversations();
            updateSidebar();
        }

        function renderActiveThread() {
            const messagesContainer = document.getElementById('messages-container');
            messagesContainer.innerHTML = '';
            
            // Add system prompt bubble
            messagesContainer.innerHTML = `
                <!-- System Prompt Bubble (hidden by default) -->
                <div class="system-prompt-bubble" id="system-prompt-bubble" style="display: none;">
                    <div class="system-prompt-header" onclick="toggleSystemPromptBubble()">
                        <span class="system-prompt-label">System</span>
                        <span class="system-prompt-toggle" id="system-prompt-toggle">▼</span>
                    </div>
                    <div class="system-prompt-content" id="system-prompt-content">
                        <!-- System prompt text will be inserted here -->
                    </div>
                </div>
            `;
            
            // Update system prompt bubble visibility
            updateSystemPromptBubble();
            
            const thread = getActiveThread();
            
            if (thread.length === 0) {
                const welcomeDiv = document.createElement('div');
                welcomeDiv.className = 'welcome-message';
                welcomeDiv.innerHTML = `
                        <h2>Welcome to Scope</h2>
                        <p>Chat with AI and see token probabilities in real-time</p>
                `;
                messagesContainer.appendChild(welcomeDiv);
            } else {
                thread.forEach((msg) => {
                    if (msg.role === 'user') {
                        addUserMessage(msg, false);
                    } else if (msg.role === 'assistant') {
                        addAssistantMessage(msg.content, msg.tokens || [], msg, msg.difflens_data);
                    }
                });
            }
            
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Re-apply DiffLens if active
            if (currentView === 'diff') {
                applyDiffLensView();
            }
            
            restoreSelectedTokenHighlight();
        }
        
        // Helper to navigate to a specific node (make it the active path)
        function navigateToNode(nodeId) {
            if (!messageTree[nodeId]) return;
            
            // If this node is a leaf, just set it
            if (messageTree[nodeId].childrenIds.length === 0) {
                currentLeafId = nodeId;
            } else {
                // If not a leaf, we need to find the most recently active leaf that descends from this node
                // For now, just pick the last child recursively?
                // Better: Store 'lastSelectedChild' in nodes to remember branch history.
                
                let curr = nodeId;
                while (messageTree[curr] && messageTree[curr].childrenIds.length > 0) {
                    // Prefer lastSelectedChildId if we track it, otherwise last added child
                    const children = messageTree[curr].childrenIds;
                    const preferredChild = messageTree[curr].lastSelectedChildId;
                    
                    if (preferredChild && children.includes(preferredChild)) {
                        curr = preferredChild;
                    } else {
                        // Default to the last child (most recent)
                        curr = children[children.length - 1];
                    }
                }
                currentLeafId = curr;
            }
            
            saveCurrentConversation();
            renderActiveThread();
        }
        
        function navigateSibling(nodeId, direction) {
            const node = messageTree[nodeId];
            if (!node) return;
            
            let siblings = [];
            if (node.parentId) {
                siblings = messageTree[node.parentId].childrenIds;
            } else {
                siblings = Object.values(messageTree).filter(n => !n.parentId).map(n => n.id);
            }
            
            const currentIndex = siblings.indexOf(nodeId);
            if (currentIndex === -1) return;
            
            const newIndex = currentIndex + direction;
            if (newIndex >= 0 && newIndex < siblings.length) {
                const siblingId = siblings[newIndex];
                
                // Update parent's lastSelectedChildId preference
                if (node.parentId && messageTree[node.parentId]) {
                    messageTree[node.parentId].lastSelectedChildId = siblingId;
                }
                
                navigateToNode(siblingId);
            }
        }
        
        function updateMessageControls(nodeId) {
            // Update just the controls for a specific message without full re-render
            const node = messageTree[nodeId];
            if (!node) return;
            
            const messageDiv = document.querySelector(`.message[data-node-id="${nodeId}"]`);
            if (!messageDiv) return;
            
            // Find or create the controls container
            let controlsDiv = messageDiv.querySelector('.message-controls');
            if (!controlsDiv) {
                controlsDiv = document.createElement('div');
                controlsDiv.className = 'message-controls';
                const contentDiv = messageDiv.querySelector('.message-content');
                if (contentDiv) {
                    contentDiv.appendChild(controlsDiv);
                }
            }
            
            // Build controls HTML
            let controlsHtml = '';
            
            // Check for siblings
            const parent = node.parentId ? messageTree[node.parentId] : null;
            let siblings = [];
            if (parent) {
                siblings = parent.childrenIds;
            } else {
                siblings = Object.values(messageTree).filter(n => !n.parentId).map(n => n.id);
            }
            
            const currentIndex = siblings.indexOf(node.id);
            const siblingsCount = siblings.length;
            
            // Edit button (for user messages)
            if (node.role === 'user') {
                controlsHtml += `
                    <button class="edit-msg-btn" onclick="enableEditMode('${node.id}')" title="Edit message">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                        </svg>
                    </button>
                `;
            }
            
            // Regenerate button (for assistant messages)
            if (node.role === 'assistant' && node.parentId) {
                controlsHtml += `
                    <button class="regenerate-btn" onclick="regenerateFromNode('${node.parentId}')" title="Regenerate">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="23 4 23 10 17 10"></polyline>
                            <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                        </svg>
                    </button>
                `;
            }
            
            // Navigation buttons (if multiple siblings)
            if (siblingsCount > 1) {
                controlsHtml += `
                    <div class="message-nav">
                        <button class="nav-btn prev" ${currentIndex === 0 ? 'disabled' : ''} onclick="navigateSibling('${node.id}', -1)">❮</button>
                        <span class="nav-count">${currentIndex + 1}/${siblingsCount}</span>
                        <button class="nav-btn next" ${currentIndex === siblingsCount - 1 ? 'disabled' : ''} onclick="navigateSibling('${node.id}', 1)">❯</button>
                    </div>
                `;
            }
            
            controlsDiv.innerHTML = controlsHtml;
        }
        
        async function regenerateFromNode(parentId) {
            // If parentId is null, it means we are regenerating from root? usually assistant has a parent (user msg)
            // If parentId is "null" string (from template), treat as null
            const realParentId = parentId === 'null' ? null : parentId;
            
            // Set current leaf to the parent, effectively "rewinding" to that point
            // But we want to branch, not delete. 
            // Setting currentLeafId to parentId means the next message added will be a child of parentId.
            // But wait, if we set currentLeafId to parentId, then `generateResponse` will add a NEW child to it.
            // Yes, that's what we want.
            
            currentLeafId = realParentId;
            
            // Update UI to reflect the state before generation (hides the old branch)
            renderActiveThread();
            
            await generateResponse();
            
            // After generation, the new node is the leaf.
            // renderActiveThread() is called by generateResponse implicitly via updates? 
            // No, generateResponse appends DOM. We should force a re-render to show the navigation buttons on the new message.
            // Actually generateResponse updates the DOM of the *new* message.
            // But the *sibling* (previous response) navigation buttons might need updating if they are visible?
            // Since we are on a new branch, the old response is not in the active thread anymore.
            // So we just need to ensure the View matches the new Thread.
            // generateResponse appends to the container.
            // But since we "rewound" currentLeafId, the getActiveThread() changed.
            // The existing DOM messages might be "future" messages if we were in the middle of a thread?
            // Wait. If we go back to a user message and regenerate:
            // The user message is displayed. The old assistant message is displayed after it.
            // If we regenerate, we are effectively replacing the old assistant message in the view with a new one (streaming).
            // So we should probably clear the messages *after* the parent node from the DOM before generating.
            
            renderActiveThread(); // This will show the thread up to parent.
            // Then generateResponse will append the new message.
        }
        
        function enableEditMode(nodeId) {
            const node = messageTree[nodeId];
            if (!node) return;
            
            const messageDiv = document.querySelector(`.message[data-node-id="${nodeId}"]`);
            if (!messageDiv) return;
            
            const contentDiv = messageDiv.querySelector('.message-content');
            
            // Save current HTML to restore if cancelled (optional, or just re-render)
            
            contentDiv.innerHTML = `
                <div class="edit-mode-container">
                    <textarea class="edit-message-input">${node.content}</textarea>
                    <div class="edit-actions">
                        <button class="btn-secondary" onclick="cancelEditMessage('${nodeId}')">Cancel</button>
                        <button class="btn-primary" onclick="saveEditedMessage('${nodeId}')">Save & Submit</button>
                    </div>
                </div>
            `;
            
            // Auto-resize
            const textarea = contentDiv.querySelector('textarea');
            textarea.style.height = textarea.scrollHeight + 'px';
        }
        
        function cancelEditMessage(nodeId) {
            // Just re-render the thread to restore view
            renderActiveThread();
        }
        
        function saveEditedMessage(nodeId) {
            const messageDiv = document.querySelector(`.message[data-node-id="${nodeId}"]`);
            const textarea = messageDiv.querySelector('textarea');
            const newContent = textarea.value.trim();
            
            if (!newContent) return;
            
            const oldNode = messageTree[nodeId];
            
            // If content hasn't changed, just cancel
            if (newContent === oldNode.content) {
                cancelEditMessage(nodeId);
                return;
            }
            
            // Create a NEW sibling node with the new content
            const newNodeId = uuidv4();
            const newNode = {
                ...oldNode,
                id: newNodeId,
                childrenIds: [], // New branch starts here
                content: newContent,
                timestamp: Date.now(),
                tokens: [] // Clear tokens as it's a new user message? Or re-tokenize? 
                           // For User messages, tokens are usually computed on backend for analysis, 
                           // but here we treat it as text. User nodes don't usually have 'tokens' property populated by backend in this app yet?
                           // Actually addUserMessage just displays text.
            };
            
            // Add to tree
            messageTree[newNodeId] = newNode;
            
            // Link to parent
            if (oldNode.parentId && messageTree[oldNode.parentId]) {
                messageTree[oldNode.parentId].childrenIds.push(newNodeId);
                // Set this as the preferred child
                messageTree[oldNode.parentId].lastSelectedChildId = newNodeId;
            }
            
            // Set as current leaf (temporarily, until we generate response)
            currentLeafId = newNodeId;
            
            // Re-render view to show the updated user message
            renderActiveThread();
            
            // Trigger generation for the Assistant response
            generateResponse();
        }
        
        async function deleteCurrentChat() {
            if (!currentConversationId) return;
            
            if (!confirm('Delete this conversation?')) return;
            
            const idToDelete = currentConversationId;
            
            // Delete from conversations object
            delete conversations[idToDelete];
            
            // Delete from server
            try {
                await fetch(`/api/conversations/${idToDelete}`, {
                    method: 'DELETE'
                });
            } catch (error) {
                console.error('Failed to delete conversation from server:', error);
            }
            
            // Load another conversation or create new one
            const remainingIds = Object.keys(conversations);
            if (remainingIds.length > 0) {
                loadConversation(remainingIds[0]);
            } else {
                createNewChat();
            }
            
            // Save remaining conversations
            localStorage.setItem('tokenlens_conversations', JSON.stringify(conversations));
            updateSidebar();
        }
        
        function updateSidebar() {
            const list = document.getElementById('conversations-list');
            list.innerHTML = '';
            
            // Sort conversations by timestamp (newest first)
            const sortedIds = Object.keys(conversations).sort((a, b) => 
                conversations[b].timestamp - conversations[a].timestamp
            );
            
            sortedIds.forEach(id => {
                const conv = conversations[id];
                const item = document.createElement('div');
                item.className = 'conversation-item' + (id === currentConversationId ? ' active' : '');
                item.onclick = () => loadConversation(id);
                
                item.innerHTML = `
                    <div class="conversation-title">${conv.title}</div>
                    <button class="delete-conversation-btn" onclick="event.stopPropagation(); deleteConversation('${id}')" title="Delete chat">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 6h18"></path>
                            <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                            <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
                        </svg>
                    </button>
                `;
                
                list.appendChild(item);
            });
        }
        
        async function deleteConversation(id) {
            delete conversations[id];
            
            // Delete from server
            try {
                await fetch(`/api/conversations/${id}`, {
                    method: 'DELETE'
                });
            } catch (error) {
                console.error('Failed to delete conversation from server:', error);
            }
            
            // If we deleted the current conversation, switch to another or create new
            if (id === currentConversationId) {
                const remainingIds = Object.keys(conversations);
                if (remainingIds.length > 0) {
                    loadConversation(remainingIds[0]);
                } else {
                    createNewChat();
                }
            }
            
            saveConversations();
            updateSidebar(); // Refresh the sidebar UI
        }
        
        function formatDate(date) {
            const now = new Date();
            const diff = now - date;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (minutes < 1) return 'Just now';
            if (minutes < 60) return `${minutes}m ago`;
            if (hours < 24) return `${hours}h ago`;
            if (days < 7) return `${days}d ago`;
            
            return date.toLocaleDateString();
        }
        
        function updateUrl(conversationId) {
            const newUrl = `/chat/${conversationId}`;
            window.history.pushState({ conversationId: conversationId }, '', newUrl);
        }
        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('collapsed');
            
            // Save sidebar state
            const isCollapsed = sidebar.classList.contains('collapsed');
            localStorage.setItem('tokenlens_sidebar_collapsed', isCollapsed);
        }
        
        function initializeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const savedState = localStorage.getItem('tokenlens_sidebar_collapsed');
            
            // If saved state exists and is 'true', collapse the sidebar
            if (savedState === 'true') {
                sidebar.classList.add('collapsed');
            }
        }
        
        
        // Handle browser back/forward buttons
        window.addEventListener('popstate', function(event) {
            if (event.state && event.state.conversationId) {
                // Load the conversation without updating the URL (it's already updated by popstate)
                loadConversation(event.state.conversationId, false);
            } else {
                // No state, redirect to home which will load default conversation
                window.location.href = '/';
            }
        });
        
        function addAssistantMessage(content, tokens, nodeOrIdx, difflensData = null) {
            const messagesContainer = document.getElementById('messages-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant-message';
            
            let node = null;
            if (typeof nodeOrIdx === 'object') {
                node = nodeOrIdx;
                messageDiv.dataset.nodeId = node.id;
            }
            
            // Controls
            let controlsHtml = '';
            if (node) {
                 const parent = node.parentId ? messageTree[node.parentId] : null;
                 let siblings = parent ? parent.childrenIds : [];
                 const currentIndex = siblings.indexOf(node.id);
                 const total = siblings.length;
                 
                 controlsHtml += `
                    <button class="regenerate-btn" onclick="regenerateFromNode('${node.parentId}')" title="Regenerate response">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.3"/>
                        </svg>
                    </button>
                `;
                
                 if (total > 1) {
                     controlsHtml += `
                        <div class="message-nav">
                            <button class="nav-btn prev" ${currentIndex === 0 ? 'disabled' : ''} onclick="navigateSibling('${node.id}', -1)">❮</button>
                            <span class="nav-count">${currentIndex + 1}/${total}</span>
                            <button class="nav-btn next" ${currentIndex === total - 1 ? 'disabled' : ''} onclick="navigateSibling('${node.id}', 1)">❯</button>
                        </div>
                    `;
                 }
            }
            
            const tokensContainer = document.createElement('div');
            tokensContainer.className = 'message-tokens';
            
            if (tokens && tokens.length > 0) {
                // Render with token data using the same addToken function for consistency
                tokens.forEach((tokenData, idx) => {
                    // Skip prompt tokens
                    if (tokenData.is_prompt_token) {
                        return;
                    }
                    // Note: messageIndex param in addToken is not strictly used for logic, mostly for referencing. 
                    // Passing node.id or null is better if we update addToken.
                    // For now passing idx is fine.
                    const tokenSpan = addToken(
                        tokensContainer,
                        tokenData.token,
                        tokenData.probability,
                        tokenData.rank,
                        tokenData.vocab_size,
                        tokenData.top_alternatives,
                        idx,
                        null,
                        tokenData.model,
                        tokenData.temperature,
                        tokenData.token_id,
                        tokenData.rule_applied || null
                    );
                    if (node) {
                        tokenSpan.dataset.nodeId = node.id;
                    }
                    
                    // Only apply prefill styling to injected tokens, or all prefill tokens if none are injected
                    if (tokenData.is_prefill_token) {
                        const hasInjectedToken = tokens.some(t => t.is_injected);
                        if (!hasInjectedToken || tokenData.is_injected) {
                            tokenSpan.classList.add('prefilled-token');
                        }
                    }
                    
                    // Apply DiffLens data if available AND we're in diff view
                    if (difflensData && difflensData.token_data && difflensData.token_data[idx]) {
                        const tokenInfo = difflensData.token_data[idx];
                        const diff = tokenInfo.prob_diff;
                        const rankDiff = tokenInfo.rank_diff;
                        
                        // Store DiffLens data in token element (always store, but only apply colors if in diff view)
                        tokenSpan.dataset.difflensGenProb = tokenInfo.gen_prob;
                        tokenSpan.dataset.difflensGenRank = tokenInfo.gen_rank;
                        tokenSpan.dataset.difflensGenTopAlternatives = JSON.stringify(tokenInfo.gen_top_alternatives);
                        tokenSpan.dataset.difflensAnalysisProb = tokenInfo.analysis_prob;
                        tokenSpan.dataset.difflensAnalysisRank = tokenInfo.analysis_rank;
                        tokenSpan.dataset.difflensAnalysisTopAlternatives = JSON.stringify(tokenInfo.analysis_top_alternatives);
                        tokenSpan.dataset.difflensProbDiff = tokenInfo.prob_diff;
                        tokenSpan.dataset.difflensRankDiff = tokenInfo.rank_diff;
                        tokenSpan.dataset.difflensGenModel = difflensData.generation_model;
                        tokenSpan.dataset.difflensAnalysisModel = difflensData.analysis_model;
                        
                        // Only apply DiffLens styling if currently in diff view
                        if (currentView === 'diff') {
                            const color = getDiffLensColor(diff, rankDiff);
                            tokenSpan.style.backgroundColor = color;
                            
                            // Set text color based on difference (diff is in percentage points)
                            if (Math.abs(diff) < 2) {
                                tokenSpan.style.color = 'hsl(0, 0%, 30%)';
                            } else if (diff > 0) {
                                tokenSpan.style.color = 'hsl(120, 50%, 20%)';
                            } else {
                                tokenSpan.style.color = 'hsl(0, 50%, 25%)';
                            }
                        
                        // Add class for styling
                        tokenSpan.classList.remove('difflens-gen-prefers', 'difflens-analysis-prefers', 'difflens-neutral');
                        if (Math.abs(diff) < 0.5) {
                            tokenSpan.classList.add('difflens-neutral');
                        } else if (diff > 0) {
                            tokenSpan.classList.add('difflens-gen-prefers');
                        } else {
                            tokenSpan.classList.add('difflens-analysis-prefers');
                        }
                        }
                    } else if (currentView === 'diff') {
                        // In DiffLens mode but no analysis yet - make gray
                        tokenSpan.style.backgroundColor = 'hsl(0, 0%, 75%)';
                        tokenSpan.style.color = 'hsl(0, 0%, 30%)';
                        tokenSpan.classList.add('difflens-neutral');
                    }
                });
            } else {
                // Plain text rendering
                tokensContainer.textContent = content;
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            // Add tokens container
            contentDiv.appendChild(tokensContainer);
            
            // Add controls below content
            if (controlsHtml) {
                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'message-controls';
                controlsDiv.innerHTML = controlsHtml;
                contentDiv.appendChild(controlsDiv);
            }
            
            messageDiv.appendChild(contentDiv);
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Auto-resize textarea
        const textarea = document.getElementById('user-input');
        textarea.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 200) + 'px';
        });
        
        // ============= LOGIT LENS FUNCTIONS =============
        
        let currentLogitLensData = null;
        let currentLogitLensView = 'heatmap';
        let activeChartTokens = [];
        const CHART_COLORS = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e'];
        
        async function openLogitLens(tokenElement) {
            // Get token context - find all tokens up to this one
            const messageContainer = tokenElement.closest('.message-content');
            if (!messageContainer) {
                console.error('Cannot find message container');
                return;
            }
            
            // Get all tokens in this message
            const allTokens = Array.from(messageContainer.querySelectorAll('.token'));
            const targetIndex = allTokens.indexOf(tokenElement);
            
            if (targetIndex === -1) {
                console.error('Token not found in message');
                return;
            }
            
            // Determine the window of tokens to analyze
            // Show a context window ending at the clicked token
            const windowSize = 10; // Show up to 10 tokens for a nice view
            const startIndex = Math.max(0, targetIndex - windowSize + 1);
            
            // Collect tokens for the analysis window (including the target)
            const tokensWindow = allTokens.slice(startIndex, targetIndex + 1);
            
            // Collect all tokens BEFORE the window for context
            const contextTokens = allTokens.slice(0, startIndex).map(span => ({
                token: span.dataset.token,
                probability: parseFloat(span.dataset.probability),
                rank: parseInt(span.dataset.rank),
                vocab_size: parseInt(span.dataset.vocabSize)
            }));
            
            // The tokens in the window (for display and analysis)
            const windowTokensData = tokensWindow.map(span => ({
                token: span.dataset.token,
                display: span.textContent,
                probability: parseFloat(span.dataset.probability),
                rank: parseInt(span.dataset.rank),
                vocab_size: parseInt(span.dataset.vocabSize)
            }));
            
            // Get the node ID to find context
            const nodeId = tokenElement.dataset.nodeId;
            let context = [];
            
            if (nodeId && messageTree[nodeId]) {
                // Build context from message tree
                let currentNode = messageTree[nodeId];
                const thread = [];
                
                while (currentNode && currentNode.parentId) {
                    const parent = messageTree[currentNode.parentId];
                    if (parent) {
                        thread.unshift(parent);
                    }
                    currentNode = parent;
                }
                
                // Convert to context format (all messages for context)
                context = thread.map(node => ({
                    role: node.role,
                    content: node.content
                }));
                
                // Prepend system prompt if set
                if (currentSystemPrompt) {
                    context.unshift({
                        role: 'system',
                        content: currentSystemPrompt
                    });
                }
            }
            
            // Show modal with loading state
            const modal = document.getElementById('logit-lens-modal');
            const tokenDisplay = document.getElementById('logit-lens-token');
            const loading = modal.querySelector('.logit-lens-loading');
            const viz = modal.querySelector('.logit-lens-viz');
            
            tokenDisplay.textContent = tokenElement.dataset.token;
            modal.classList.remove('hidden');
            loading.style.display = 'flex';
            viz.classList.add('hidden');
            
            try {
                // Call API
                const model = tokenElement.dataset.model || document.getElementById('model-select')?.value;
                
                const response = await fetch('/api/logit-lens', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: model,
                        context: context,
                        context_tokens: contextTokens, // All tokens before the window
                        window_tokens: windowTokensData, // The tokens in the window to analyze
                        top_k: 20 // Get top 20 for better vocab coverage in search
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to analyze token');
                }
                
                const data = await response.json();
                // Add window tokens for display
                data.window_tokens = windowTokensData;
                currentLogitLensData = data;
                
                // Reset chart tokens for new analysis
                activeChartTokens = [];
                
                // Hide loading, show viz
                loading.style.display = 'none';
                viz.classList.remove('hidden');
                
                // Render based on current view
                if (currentLogitLensView === 'heatmap') {
                    renderLogitLensHeatmap(data);
                } else {
                    renderLogitLensChart(data);
                }
                
            } catch (error) {
                console.error('Error in logit lens:', error);
                alert('Failed to analyze token: ' + error.message);
                closeLogitLensModal();
            }
        }
        
        function closeLogitLensModal() {
            const modal = document.getElementById('logit-lens-modal');
            modal.classList.add('hidden');
            currentLogitLensData = null;
            activeChartTokens = [];
            
            // Destroy chart
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }
            
            // Clear search
            const searchInput = document.getElementById('chart-token-search');
            if (searchInput) searchInput.value = '';
            const searchResults = document.getElementById('chart-search-results');
            if (searchResults) searchResults.classList.remove('active');
        }
        
        function switchLogitLensView(view) {
            currentLogitLensView = view;
            
            // Update toggle buttons
            document.querySelectorAll('.view-toggle .toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });
            
            // Update viz containers
            const heatmapContainer = document.getElementById('logit-lens-heatmap');
            const chartContainer = document.getElementById('logit-lens-chart');
            
            if (view === 'heatmap') {
                heatmapContainer.classList.add('active');
                chartContainer.classList.remove('active');
                if (currentLogitLensData) {
                    renderLogitLensHeatmap(currentLogitLensData);
                }
            } else {
                heatmapContainer.classList.remove('active');
                chartContainer.classList.add('active');
                if (currentLogitLensData) {
                    // Initialize chart with top 3 tokens on first view
                    if (activeChartTokens.length === 0) {
                        initializeChartTokens();
                    }
                    // Delay rendering to ensure container is visible
                    setTimeout(() => renderLogitLensChart(), 50);
                }
            }
        }
        
        function renderLogitLensHeatmap(data) {
            const container = document.getElementById('heatmap-canvas-container');
            const positions = data.positions; // Array of position analyses
            const windowTokens = data.window_tokens; // The actual tokens
            const numLayers = data.num_layers;
            
            // Create table with classic Logit Lens style
            // Columns: Input tokens (sequence positions)
            // Rows: Layers
            // Cells: Top predicted token at that position and layer
            
            let html = '<table class="heatmap-table">';
            
            // Header row: show the actual input tokens
            html += '<tr><th style="min-width: 100px; background: var(--bg-secondary);">Layer</th>';
            windowTokens.forEach(t => {
                const displayToken = t.display || formatTokenForDisplay(t.token, { replaceAllSpaces: false });
                html += `<th style="min-width: 80px; background: var(--bg-secondary); font-family: var(--font-mono);">${displayToken}</th>`;
            });
            html += '</tr>';
            
            // Data rows: one row per layer
            for (let layerIdx = 0; layerIdx < numLayers; layerIdx++) {
                const layerLabel = `Layer ${layerIdx}`;
                html += `<tr><td style="background: var(--bg-secondary); font-weight: 600;">${layerLabel}</td>`;
                
                // For each position in the window
                positions.forEach(posData => {
                    // Find the prediction for this layer
                    const layerPred = posData.layer_predictions.find(lp => lp.layer === layerIdx);
                    
                    if (layerPred && layerPred.predictions && layerPred.predictions.length > 0) {
                        const topPred = layerPred.predictions[0];
                        const prob = topPred.probability;
                        const token = topPred.token;
                        const displayToken = formatTokenForDisplay(token, { replaceAllSpaces: true });
                        const color = getColorForProb(prob);
                        const textColor = prob > 0.6 ? '#000' : 'var(--text-color)';
                        
                        html += `<td style="background-color: ${color}; color: ${textColor}; text-align: center; font-family: var(--font-mono); padding: 8px; font-size: 0.85em; cursor: pointer;" 
                            class="heatmap-cell-hover"
                            data-layer="${layerIdx}"
                            data-position="${posData.position}"
                            data-token="${token}"
                            data-prob="${prob}">
                            ${displayToken}
                        </td>`;
                    } else {
                        html += '<td style="background: var(--bg-secondary);">-</td>';
                    }
                });
                
                html += '</tr>';
            }
            
            html += '</table>';
            container.innerHTML = '<div class="heatmap-table-scroll">' + html + '</div>';
            
            // Add hover listeners for custom tooltips
            setTimeout(() => {
                document.querySelectorAll('.heatmap-cell-hover').forEach(cell => {
                    cell.addEventListener('mouseenter', showLogitLensTooltip);
                    cell.addEventListener('mouseleave', hideLogitLensTooltip);
                });
            }, 100);
        }
        
        function showLogitLensTooltip(e) {
            const cell = e.target;
            const layer = cell.dataset.layer;
            const position = cell.dataset.position;
            const token = cell.dataset.token;
            const prob = parseFloat(cell.dataset.prob);
            
            const tooltip = document.getElementById('logit-lens-tooltip');
            const header = document.getElementById('tooltip-header');
            const body = document.getElementById('tooltip-body');
            
            const windowTokens = currentLogitLensData.window_tokens;
            const inputToken = windowTokens[position];
            const inputDisplay = inputToken ? inputToken.display : '';
            
            const layerLabel = `Layer ${layer}`;
            
            header.textContent = `${layerLabel} → Position ${parseInt(position) + 1}`;
            
            body.innerHTML = `
                <div class="tooltip-row">
                    <span class="tooltip-label">Input Token:</span>
                    <span class="tooltip-value">"${inputDisplay}"</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Predicted:</span>
                    <span class="tooltip-value">"${formatTokenForDisplay(token, { replaceAllSpaces: true })}"</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Probability:</span>
                    <span class="tooltip-value">${(prob * 100).toFixed(2)}%</span>
                </div>
            `;
            
            tooltip.classList.add('visible');
            
            // Position tooltip smartly near cell
            const rect = cell.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();
            
            const viewportHeight = window.innerHeight;
            const viewportWidth = window.innerWidth;
            const padding = 10;
            
            // Vertical positioning: prefer below, but flip above if not enough space
            let top;
            const spaceBelow = viewportHeight - rect.bottom;
            const spaceAbove = rect.top;
            
            if (spaceBelow >= tooltipRect.height + padding || spaceBelow > spaceAbove) {
                // Position below
                top = rect.bottom + padding;
            } else {
                // Position above
                top = rect.top - tooltipRect.height - padding;
            }
            
            // Horizontal positioning: keep within viewport bounds
            let left = rect.left;
            if (left + tooltipRect.width > viewportWidth - padding) {
                left = viewportWidth - tooltipRect.width - padding;
            }
            if (left < padding) {
                left = padding;
            }
            
            tooltip.style.top = `${top}px`;
            tooltip.style.left = `${left}px`;
        }
        
        function hideLogitLensTooltip() {
            const tooltip = document.getElementById('logit-lens-tooltip');
            tooltip.classList.remove('visible');
        }
        
        function initializeChartTokens() {
            if (!currentLogitLensData || !currentLogitLensData.positions) return;
            
            // Get the last position (clicked token)
            const lastPos = currentLogitLensData.positions[currentLogitLensData.positions.length - 1];
            const finalLayer = lastPos.layer_predictions[lastPos.layer_predictions.length - 1];
            
            // Add top 3 tokens
            const top3 = finalLayer.predictions.slice(0, 3).map(p => p.token);
            activeChartTokens = top3.map((token, idx) => ({
                token,
                color: CHART_COLORS[idx]
            }));
            
            updateActiveTokensDisplay();
        }
        
        function updateActiveTokensDisplay() {
            const container = document.getElementById('active-chart-tokens');
            container.innerHTML = '';
            
            activeChartTokens.forEach((tokenData, idx) => {
                const chip = document.createElement('div');
                chip.className = 'active-token-chip';
                
                const displayToken = formatTokenForDisplay(tokenData.token, { replaceAllSpaces: false });
                
                chip.innerHTML = `
                    <div class="active-token-color" style="background-color: ${tokenData.color};"></div>
                    <span>${displayToken}</span>
                    <button class="active-token-remove" onclick="removeChartToken(${idx})">×</button>
                `;
                
                container.appendChild(chip);
            });
        }
        
        function removeChartToken(idx) {
            activeChartTokens.splice(idx, 1);
            updateActiveTokensDisplay();
            renderLogitLensChart();
        }
        
        function addChartToken(token) {
            // Don't add if already present
            if (activeChartTokens.some(t => t.token === token)) return;
            
            // Get next color
            const colorIdx = activeChartTokens.length % CHART_COLORS.length;
            activeChartTokens.push({
                token,
                color: CHART_COLORS[colorIdx]
            });
            
            updateActiveTokensDisplay();
            renderLogitLensChart();
        }
        
        // Token search for chart - search full vocab like inject feature
        const chartSearchInput = document.getElementById('chart-token-search');
        const chartSearchResults = document.getElementById('chart-search-results');
        
        if (chartSearchInput) {
            let searchTimeout;
            chartSearchInput.addEventListener('input', async (e) => {
                const query = e.target.value.trim();
                
                if (query.length < 1) {
                    chartSearchResults.classList.remove('active');
                    return;
                }
                
                // Debounce search
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(async () => {
                    try {
                        // Get model and context
                        const modelSelect = document.getElementById('model-select');
                        const modelName = modelSelect ? modelSelect.value : 'meta-llama/Llama-3.1-8B-Instruct';
                        
                        // Build context from message tree if available
                        let context = [];
                        if (currentLogitLensData && currentLogitLensData.positions) {
                            // Try to get context from the analysis
                            context = getActiveThread().map(node => ({
                                role: node.role,
                                content: node.content
                            }));
                        }
                        
                        // Search full vocabulary
                        const response = await fetch('/api/search-tokens', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                query: query,
                                model: modelName,
                                context: context,
                                prefix_tokens: []
                            })
                        });
                        
                        if (!response.ok) throw new Error('Search failed');
                        
                        const matches = await response.json();
                        
                        if (matches && matches.length > 0) {
                            chartSearchResults.innerHTML = matches.slice(0, 15).map(match => {
                                const displayToken = formatTokenForDisplay(match.token, { replaceAllSpaces: false });
                                const probText = match.probability ? ` (${(match.probability * 100).toFixed(1)}%)` : '';
                                return `<div class="token-result-item" onclick="addChartToken('${match.token.replace(/'/g, "\\'")}')">${displayToken}${probText}</div>`;
                            }).join('');
                            chartSearchResults.classList.add('active');
                        } else {
                            chartSearchResults.innerHTML = '<div class="search-no-results">No matches found</div>';
                            chartSearchResults.classList.add('active');
                        }
                    } catch (error) {
                        console.error('Token search error:', error);
                        chartSearchResults.innerHTML = '<div class="search-error">Search error</div>';
                        chartSearchResults.classList.add('active');
                    }
                }, 300);
            });
            
            // Close results when clicking outside
            document.addEventListener('click', (e) => {
                if (!chartSearchInput.contains(e.target) && !chartSearchResults.contains(e.target)) {
                    chartSearchResults.classList.remove('active');
                }
            });
        }
        
        let currentChart = null; // Store Chart.js instance
        
        function renderLogitLensChart() {
            if (!currentLogitLensData || !currentLogitLensData.positions) return;
            
            const canvas = document.getElementById('probability-chart');
            const container = canvas.parentElement;
            
            if (!container || container.offsetWidth === 0) {
                console.warn('Chart container not visible');
                return;
            }
            
            // Destroy previous chart if it exists
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }
            
            const ctx = canvas.getContext('2d');
            
            // Show message if no tokens selected
            if (activeChartTokens.length === 0) {
                canvas.width = container.offsetWidth - 40;
                canvas.height = container.offsetHeight - 40;
                ctx.fillStyle = '#666';
                ctx.font = '14px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No tokens selected. Search and add tokens to visualize.', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Get the last position (clicked token) data
            const lastPos = currentLogitLensData.positions[currentLogitLensData.positions.length - 1];
            
            // Build layer labels
            const layerLabels = lastPos.layer_predictions.map(layer => `Layer ${layer.layer}`);
            
            // Build datasets for Chart.js
            const datasets = activeChartTokens.map(tokenData => {
                const data = lastPos.layer_predictions.map(layer => {
                    const pred = layer.predictions.find(p => p.token === tokenData.token);
                    return pred ? pred.probability : 0;
                });
                
                return {
                    label: formatTokenForDisplay(tokenData.token, { replaceAllSpaces: false }),
                    data: data,
                    borderColor: tokenData.color,
                    backgroundColor: tokenData.color,
                    tension: 0.1,
                    pointRadius: 5,
                    pointHoverRadius: 7
                };
            });
            
            // Create Chart.js chart
            currentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: layerLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'nearest',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: false // We have our own legend with remove buttons
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.85)',
                            padding: 12,
                            titleFont: {
                                size: 14,
                                weight: 'bold'
                            },
                            bodyFont: {
                                size: 13
                            },
                            callbacks: {
                                title: function(context) {
                                    return context[0].label;
                                },
                                label: function(context) {
                                    const token = context.dataset.label;
                                    const prob = context.parsed.y;
                                    return `${token}: ${(prob * 100).toFixed(2)}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Layer',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: '#ddd'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Probability',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            min: 0,
                            max: 1,
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1);
                                }
                            },
                            grid: {
                                color: '#ddd'
                            }
                        }
                    }
                }
            });
        }
        
        // Close modal when clicking overlay/outside modal content
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('logit-lens-modal');
            if (modal && !modal.classList.contains('hidden')) {
                const content = modal.querySelector('.logit-lens-content');
                // Only close if click happens inside the modal container but outside content (e.g., overlay)
                if (modal.contains(e.target) && content && !content.contains(e.target)) {
                    closeLogitLensModal();
                }
            }
        });
        
    </script>
</body>
</html>


