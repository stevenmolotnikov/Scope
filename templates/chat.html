<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Scope - Chat Interface</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@500&family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="{{ url_for('static', filename='chat.css') }}">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
</head>
<body>
    <div class="app-container">
        <!-- Sidebar -->
        <aside class="sidebar" id="sidebar">
            <div class="sidebar-content">
            <div class="sidebar-header">
                    <button class="sidebar-close-btn" onclick="toggleSidebar()" title="Close sidebar">
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                            <path d="M12 5L7 10L12 15" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                        </svg>
                    </button>
                    <div class="sidebar-branding">
                        <span class="sidebar-title">Scope</span>
                        <span class="sidebar-subtitle">by NDIF</span>
                    </div>
                </div>
                
                <button class="new-chat-btn-sidebar" onclick="createNewChat()">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M8 2V14M2 8H14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                    </svg>
                    <span>New chat</span>
                </button>
            
            <div class="conversations-list" id="conversations-list">
                <!-- Conversations will be dynamically added here -->
            </div>
            </div>
            
            <button class="sidebar-toggle-collapsed" onclick="toggleSidebar()" title="Open sidebar">
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                            <path d="M3 10H17M3 5H17M3 15H17" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                    </button>
            
            <button class="new-chat-btn-collapsed" onclick="createNewChat()" title="New chat">
                        <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                    <path d="M8 2V14M2 8H14" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                    </button>
        </aside>

        <!-- Main Chat Area -->
        <div class="chat-container">
            <!-- Header -->
            <header class="main-header">
            </header>

            <!-- Messages Area -->
            <div class="messages-container" id="messages-container">
                <!-- System Prompt Bubble (hidden by default) -->
                <div class="system-prompt-bubble" id="system-prompt-bubble" style="display: none;">
                    <div class="system-prompt-header" onclick="toggleSystemPromptBubble()">
                        <span class="system-prompt-label">System</span>
                        <span class="system-prompt-toggle" id="system-prompt-toggle">▼</span>
                    </div>
                    <div class="system-prompt-content" id="system-prompt-content">
                        <!-- System prompt text will be inserted here -->
                    </div>
                </div>
                
                <div class="welcome-message">
                    <h2>Welcome to Scope</h2>
                    <p>Chat with AI and see token probabilities in real-time</p>
                </div>
            </div>
            
        <!-- Input Area -->
        <div class="input-container">
            <div class="input-wrapper">
                <textarea 
                    id="user-input" 
                    placeholder="Type your message..." 
                    rows="1"
                    onkeydown="handleKeyDown(event)"
                ></textarea>
                <button id="send-btn" onclick="handleSendButton()">
                    <svg id="send-icon" width="20" height="20" viewBox="0 0 20 20" fill="none">
                        <path d="M2 10L18 2L10 18L8 11L2 10Z" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
                    </svg>
                    <svg id="stop-icon" width="20" height="20" viewBox="0 0 20 20" fill="none" style="display: none;">
                        <rect x="5" y="5" width="10" height="10" fill="currentColor" stroke="none"/>
                    </svg>
                </button>
                <div class="model-selector-inline">
                    <select id="model-select" onchange="saveCurrentConversation()">
                            <option value="meta-llama/Llama-3.1-8B-Instruct">Llama-3.1-8B-Instruct</option>
                            <option value="google/gemma-2-2b-it">Gemma-2-2B-IT</option>
                            <option value="google/gemma-3-1b-it">Gemma-3-1B-IT</option>
                        </select>
                    <input type="number" id="temperature-input" min="0" max="2" step="0.1" value="1.0" title="Temperature">
                    </div>
                    </div>
                    </div>
                </div>

        <!-- Right Sidebar (Tools) -->
        <aside class="tools-sidebar" id="tools-sidebar">
            <div class="tools-header">
                <h3>Lens Tools</h3>
                    </div>
            
            <div class="tools-content">
                <details class="tool-section" open>
                    <summary>Conversation Settings</summary>
                    <div class="tool-section-content">
                        <div class="tool-group">
                            <label class="tool-label">System Prompt</label>
                            <textarea 
                                id="system-prompt-input" 
                                placeholder="e.g., You are a helpful assistant..."
                                class="tool-textarea"
                                rows="4"
                                oninput="updateSystemPrompt()"
                            ></textarea>
                            <button class="tool-btn" onclick="saveDefaultSystemPrompt()">Save as Default</button>
                        </div>
                    </div>
                </details>

                <details class="tool-section" open>
                    <summary>Views</summary>
                    <div class="tool-section-content">
                        <div class="tool-group">
                            <label class="tool-label">Active View</label>
                            <select id="view-select" onchange="switchView()" class="tool-select">
                                <option value="token">Token View</option>
                                <option value="diff">Diff View</option>
                            </select>
                        </div>
                        <div class="tool-group" style="margin-top: 16px;">
                            <label class="tool-label">Highlight By</label>
                            <select id="highlight-mode-select" onchange="switchHighlightMode()" class="tool-select">
                                <option value="probability">Probability</option>
                                <option value="rank">Rank</option>
                            </select>
                        </div>
                    </div>
                </details>

                <details class="tool-section" open>
                    <summary>Analysis Tools</summary>
                    <div class="tool-section-content">
                        <div class="tool-group" id="difflens-tools">
                            <label class="tool-label">Analysis Model</label>
                            <select id="analysis-model-select" class="tool-select">
                                <option value="">Select model...</option>
                                <option value="meta-llama/Llama-3.1-8B-Instruct">Llama-3.1-8B-Instruct</option>
                                <option value="google/gemma-2-2b-it">Gemma-2-2B-IT</option>
                                <option value="google/gemma-3-1b-it">Gemma-3-1B-IT</option>
                            </select>
                            <button class="tool-btn" id="apply-difflens-btn" onclick="triggerDiffLensAnalysis()">
                                Apply Analysis
                            </button>
                        </div>
                    </div>
                </details>

                <details class="tool-section" open>
                    <summary>Generation Tools</summary>
                    <div class="tool-section-content">
                        <div class="tool-group" id="force-start-tools">
                            <label class="tool-label">Force Assistant Start</label>
                            <input 
                                type="text" 
                                id="prefill-input" 
                                placeholder='e.g., "Sure, " or "I cannot..."'
                                class="tool-input"
                            />
                            <p class="tool-help">The assistant will start its response with this text</p>
                        </div>
                    </div>
                </details>
            </div>
        </aside>
    </div>

    <!-- Unified Token Tooltip -->
    <div id="token-tooltip" class="token-tooltip hidden">
        <!-- Token Info (always visible) -->
        <div class="tooltip-info-section">
            <div id="tooltip-current-token"></div>
            <div class="tooltip-alternatives" id="tooltip-alternatives">
                <!-- Top 2 alternatives will be inserted here -->
            </div>
        </div>
        
        <!-- Interactive Section (only in click mode) -->
        <div class="tooltip-interactive-section">
            <input type="text" id="token-search-input" placeholder="Search tokens..." class="token-search-input">
            <div id="token-search-results" class="token-search-results">
                <!-- Search results will appear here -->
            </div>
            <div class="tooltip-actions">
                <button class="tooltip-btn primary" id="inject-regenerate-btn">
                <svg width="14" height="14" viewBox="0 0 14 14" fill="none">
                    <path d="M7 1V7M7 7H13M7 7L2 12" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                </svg>
                Inject and Regenerate
            </button>
                <button class="tooltip-btn secondary" id="open-logit-lens-btn">
                    <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                        <path d="M2 14L2 2L14 2" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                        <path d="M4 10L6.5 7L9 9.5L12 5" stroke="currentColor" stroke-width="1.5" stroke-linecap="round"/>
                        <circle cx="12" cy="5" r="1.2" fill="currentColor"/>
                    </svg>
                    Open Logit Lens
                </button>
            </div>
        </div>
    </div>

    <!-- Logit Lens Modal -->
    <div id="logit-lens-modal" class="logit-lens-modal hidden">
        <div class="logit-lens-overlay" onclick="closeLogitLensModal()"></div>
        <div class="logit-lens-content">
            <div class="logit-lens-header">
                <h2>Logit Lens Analysis: <span id="logit-lens-token"></span></h2>
                <div class="logit-lens-controls">
                    <div class="view-toggle">
                        <button class="toggle-btn active" data-view="heatmap" onclick="switchLogitLensView('heatmap')">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <rect x="2" y="2" width="3" height="3" fill="currentColor"/>
                                <rect x="6" y="2" width="3" height="3" fill="currentColor"/>
                                <rect x="10" y="2" width="3" height="3" fill="currentColor"/>
                                <rect x="2" y="6" width="3" height="3" fill="currentColor"/>
                                <rect x="6" y="6" width="3" height="3" fill="currentColor"/>
                                <rect x="10" y="6" width="3" height="3" fill="currentColor"/>
                                <rect x="2" y="10" width="3" height="3" fill="currentColor"/>
                                <rect x="6" y="10" width="3" height="3" fill="currentColor"/>
                                <rect x="10" y="10" width="3" height="3" fill="currentColor"/>
                            </svg>
                            Heatmap
                        </button>
                        <button class="toggle-btn" data-view="chart" onclick="switchLogitLensView('chart')">
                            <svg width="16" height="16" viewBox="0 0 16 16" fill="none">
                                <path d="M2 12L5 8L8 10L14 2" stroke="currentColor" stroke-width="2" fill="none"/>
                            </svg>
                            Chart
                        </button>
                    </div>
                    <button class="close-btn" onclick="closeLogitLensModal()">
                        <svg width="20" height="20" viewBox="0 0 20 20" fill="none">
                            <path d="M5 5L15 15M5 15L15 5" stroke="currentColor" stroke-width="2" stroke-linecap="round"/>
                        </svg>
                    </button>
                </div>
            </div>
            <div class="logit-lens-body">
                <div class="logit-lens-loading">
                    <div class="spinner"></div>
                    <p>Analyzing layers...</p>
                </div>
                <div class="logit-lens-viz hidden">
                    <!-- Heatmap View -->
                    <div id="logit-lens-heatmap" class="viz-container active">
                        <div class="heatmap-scroll">
                            <div id="heatmap-canvas-container"></div>
                        </div>
                    </div>
                    <!-- Chart View -->
                    <div id="logit-lens-chart" class="viz-container">
                        <div class="chart-content-scroll">
                            <div class="chart-controls">
                                <div class="token-search-container">
                                    <input type="text" 
                                           id="chart-token-search" 
                                           class="token-search-input-chart" 
                                           placeholder="Search for tokens to add..."
                                           autocomplete="off">
                                    <div id="chart-search-results" class="token-search-results-chart"></div>
                                </div>
                                <div class="active-tokens" id="active-chart-tokens">
                                    <!-- Active token chips will be added here -->
                                </div>
                            </div>
                            <div class="chart-canvas-container">
                                <canvas id="probability-chart"></canvas>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Custom Tooltip for Logit Lens -->
    <div id="logit-lens-tooltip" class="logit-lens-tooltip">
        <div class="tooltip-header" id="tooltip-header"></div>
        <div id="tooltip-body"></div>
    </div>

    <script>
        let isGenerating = false;
        let currentAbortController = null;
        // conversationHistory is now derived from messageTree
        let messageTree = {}; 
        let currentLeafId = null;
        let currentConversationId = null;
        let conversations = {};
        let selectedTokenElement = null;
        let selectedAlternativeToken = null;
        let currentView = 'token';
        let currentHighlightMode = 'probability';  // 'probability' or 'rank'
        let currentSystemPrompt = '';  // Current conversation's system prompt
        let systemPromptExpanded = true;  // Track bubble collapse state
        
        // Helper to generate UUIDs
        function uuidv4() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                var r = Math.random() * 16 | 0, v = c == 'x' ? r : (r & 0x3 | 0x8);
                return v.toString(16);
            });
        }
        
        // System Prompt Functions
        function updateSystemPrompt() {
            const systemPromptInput = document.getElementById('system-prompt-input');
            currentSystemPrompt = systemPromptInput.value.trim();
            
            // Update the bubble display
            updateSystemPromptBubble();
            
            // Save to conversation
            saveCurrentConversation();
        }
        
        function updateSystemPromptBubble() {
            const bubble = document.getElementById('system-prompt-bubble');
            const content = document.getElementById('system-prompt-content');
            
            if (currentSystemPrompt) {
                bubble.style.display = 'block';
                content.textContent = currentSystemPrompt;
            } else {
                bubble.style.display = 'none';
            }
        }
        
        function toggleSystemPromptBubble() {
            const content = document.getElementById('system-prompt-content');
            const toggle = document.getElementById('system-prompt-toggle');
            
            systemPromptExpanded = !systemPromptExpanded;
            
            if (systemPromptExpanded) {
                content.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                toggle.textContent = '▼';
            } else {
                content.classList.add('collapsed');
                toggle.classList.add('collapsed');
                toggle.textContent = '▶';
            }
        }
        
        function saveDefaultSystemPrompt() {
            const systemPromptInput = document.getElementById('system-prompt-input');
            const prompt = systemPromptInput.value.trim();
            
            if (prompt) {
                localStorage.setItem('tokenlens_default_system_prompt', prompt);
                alert('Default system prompt saved!');
            } else {
                localStorage.removeItem('tokenlens_default_system_prompt');
                alert('Default system prompt cleared!');
            }
        }
        
        function loadDefaultSystemPrompt() {
            const defaultPrompt = localStorage.getItem('tokenlens_default_system_prompt');
            if (defaultPrompt) {
                const systemPromptInput = document.getElementById('system-prompt-input');
                systemPromptInput.value = defaultPrompt;
                currentSystemPrompt = defaultPrompt;
                updateSystemPromptBubble();
            }
        }

        // Get linear thread from root to current leaf
        function getActiveThread() {
            if (!currentLeafId || !messageTree[currentLeafId]) return [];
            
            const thread = [];
            let currentNodeId = currentLeafId;
            
            while (currentNodeId && messageTree[currentNodeId]) {
                thread.unshift(messageTree[currentNodeId]);
                currentNodeId = messageTree[currentNodeId].parentId;
            }
            
            return thread;
        }
        
        // Get conversation ID from URL path
        function getConversationIdFromUrl() {
            const path = window.location.pathname;
            const match = path.match(/\/chat\/([^\/]+)/);
            const id = match ? match[1] : null;
            console.log('Parsed conversation ID from URL:', path, '=>', id);
            return id;
        }
        
        const urlConversationId = getConversationIdFromUrl();

        function handleKeyDown(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                if (!isGenerating) {
                sendMessage();
                }
            }
        }
        
        function handleSendButton() {
            if (isGenerating) {
                stopGeneration();
            } else {
                sendMessage();
            }
        }
        
        function updateSendButton() {
            const sendIcon = document.getElementById('send-icon');
            const stopIcon = document.getElementById('stop-icon');
            
            if (isGenerating) {
                sendIcon.style.display = 'none';
                stopIcon.style.display = 'block';
            } else {
                sendIcon.style.display = 'block';
                stopIcon.style.display = 'none';
            }
        }
        
        function stopGeneration() {
            if (currentAbortController) {
                currentAbortController.abort();
                currentAbortController = null;
            }
            isGenerating = false;
            const sendBtn = document.getElementById('send-btn');
            sendBtn.disabled = false;
            updateSendButton();
        }

        function clearChat() {
            const messagesContainer = document.getElementById('messages-container');
            messagesContainer.innerHTML = `
                <!-- System Prompt Bubble (hidden by default) -->
                <div class="system-prompt-bubble" id="system-prompt-bubble" style="display: none;">
                    <div class="system-prompt-header" onclick="toggleSystemPromptBubble()">
                        <span class="system-prompt-label">System</span>
                        <span class="system-prompt-toggle" id="system-prompt-toggle">▼</span>
                    </div>
                    <div class="system-prompt-content" id="system-prompt-content">
                        <!-- System prompt text will be inserted here -->
                    </div>
                </div>
                
                <div class="welcome-message">
                    <h2>Welcome to Scope</h2>
                    <p>Chat with AI and see token probabilities in real-time</p>
                </div>
            `;
            messageTree = {};
            currentLeafId = null;
            
            // Load default system prompt for new conversation
            loadDefaultSystemPrompt();
            
            saveCurrentConversation();
        }

        function sendMessage() {
            if (isGenerating) return;
            
            const input = document.getElementById('user-input');
            const message = input.value.trim();
            
            if (!message) return;
            
            // Get force-start text if provided
            const prefillInput = document.getElementById('prefill-input');
            const prefillText = prefillInput ? (prefillInput.value.trim() || null) : null;
            
            // Clear inputs
            input.value = '';
            input.style.height = 'auto';
            
            // Clear force-start input after sending
            if (prefillInput) {
                prefillInput.value = '';
            }
            
            // Remove welcome message if present
            const welcomeMsg = document.querySelector('.welcome-message');
            if (welcomeMsg) {
                welcomeMsg.remove();
            }
            
            // Create User Node
            const nodeId = uuidv4();
            const newNode = {
                id: nodeId,
                parentId: currentLeafId,
                childrenIds: [],
                role: 'user',
                content: message,
                timestamp: Date.now()
            };
            
            // Update parent's children
            if (currentLeafId && messageTree[currentLeafId]) {
                messageTree[currentLeafId].childrenIds.push(nodeId);
            }
            
            // Add to tree and update leaf
            messageTree[nodeId] = newNode;
            currentLeafId = nodeId;
            
                // Display user message
            // We need to pass the node to enable navigation UI later
            addUserMessage(newNode);
                
                // Start generating assistant response (with prefill if provided)
                generateResponse(prefillText);
        }

        function addUserMessage(nodeOrContent, scroll = true) {
            const content = typeof nodeOrContent === 'object' ? nodeOrContent.content : nodeOrContent;
            const node = typeof nodeOrContent === 'object' ? nodeOrContent : null;
            
            const messagesContainer = document.getElementById('messages-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message user-message';
            if (node) {
                messageDiv.dataset.nodeId = node.id;
            }
            
            // Add navigation and edit controls if node exists
            let controlsHtml = '';
            if (node) {
                // Check if parent has multiple children (siblings of this node)
                const parent = node.parentId ? messageTree[node.parentId] : null;
                // If it's a root node (no parent), we check roots (we need to track roots or iterate)
                // For simplicity, let's assume we can find siblings via parent. 
                // If no parent, find all nodes with no parent.
                
                let siblings = [];
                if (parent) {
                    siblings = parent.childrenIds;
                } else {
                    // Find all root nodes
                    siblings = Object.values(messageTree).filter(n => !n.parentId).map(n => n.id);
                }
                
                const currentIndex = siblings.indexOf(node.id);
                const siblingsCount = siblings.length;
                
                // Edit button first
                controlsHtml += `
                    <button class="edit-msg-btn" onclick="enableEditMode('${node.id}')" title="Edit message">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                        </svg>
                    </button>
                `;
                
                if (siblingsCount > 1) {
                    controlsHtml += `
                        <div class="message-nav">
                            <button class="nav-btn prev" ${currentIndex === 0 ? 'disabled' : ''} onclick="navigateSibling('${node.id}', -1)">❮</button>
                            <span class="nav-count">${currentIndex + 1}/${siblingsCount}</span>
                            <button class="nav-btn next" ${currentIndex === siblingsCount - 1 ? 'disabled' : ''} onclick="navigateSibling('${node.id}', 1)">❯</button>
                </div>
            `;
            }
        }
        
            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-text">${escapeHtml(content)}</div>
                    ${controlsHtml ? `<div class="message-controls">${controlsHtml}</div>` : ''}
                </div>
            `;
            messagesContainer.appendChild(messageDiv);
            if (scroll) {
                messagesContainer.scrollTop = messagesContainer.scrollHeight;
            }
        }

        async function generateResponse(prefillText = null, injectedTokenIndex = null, preInjectionTokens = null) {
            console.log('generateResponse started', {prefillText, injectedTokenIndex, preInjectionTokens: preInjectionTokens?.length, currentLeafId});
            isGenerating = true;
            updateSendButton();
            
            const messagesContainer = document.getElementById('messages-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant-message';
            
            // Create Assistant Node
            const nodeId = uuidv4();
            messageDiv.dataset.nodeId = nodeId;
            console.log('Created new node ID:', nodeId);
            
            const newNode = {
                id: nodeId,
                parentId: currentLeafId,
                childrenIds: [],
                role: 'assistant',
                content: '',
                tokens: [],
                model: document.getElementById('model-select').value,
                temperature: parseFloat(document.getElementById('temperature-input')?.value) || 1.0,
                timestamp: Date.now()
            };
            
            // Update parent
            if (currentLeafId && messageTree[currentLeafId]) {
                messageTree[currentLeafId].childrenIds.push(nodeId);
                messageTree[currentLeafId].lastSelectedChildId = nodeId; // Make this the active path
            }
            
            // Add to tree and update leaf
            messageTree[nodeId] = newNode;
            currentLeafId = nodeId;
            
            // Add navigation controls
            const controlsHtml = `
                <div class="message-controls">
                    <button class="regenerate-btn" onclick="regenerateFromNode('${newNode.parentId}')" title="Regenerate response">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.3"/>
                        </svg>
                    </button>
                    <div class="message-nav" style="display:none">
                        <button class="nav-btn prev">❮</button>
                        <span class="nav-count">1/1</span>
                        <button class="nav-btn next">❯</button>
                    </div>
                </div>
            `;

            messageDiv.innerHTML = `
                <div class="message-content">
                    <div class="message-tokens"></div>
                    ${controlsHtml}
                </div>
            `;
            messagesContainer.appendChild(messageDiv);
            
            const tokensContainer = messageDiv.querySelector('.message-tokens');
            const modelName = newNode.model;
            
            let assistantResponse = '';
            let responseTokens = [];
            let prefillTokenCount = 0;
            
            // If we have pre-injection tokens, render them immediately (no streaming animation)
            if (preInjectionTokens && preInjectionTokens.length > 0) {
                for (const tokenData of preInjectionTokens) {
                    assistantResponse += tokenData.token;
                    responseTokens.push(tokenData);
                    
                    // Add token to UI immediately without streaming effect
                    const tokenSpan = addToken(
                        tokensContainer, 
                        tokenData.token, 
                        tokenData.probability, 
                        tokenData.rank, 
                        tokenData.vocab_size, 
                        tokenData.top_alternatives, 
                        responseTokens.length - 1, 
                        null, 
                        tokenData.model, 
                        tokenData.temperature, 
                        tokenData.token_id
                    );
                    tokenSpan.dataset.nodeId = nodeId;
                }
                
                // Now show placeholder for just the injected token
                if (prefillText) {
                    const placeholderSpan = document.createElement('span');
                    placeholderSpan.className = 'token prefill-placeholder prefilled-token';
                    placeholderSpan.textContent = prefillText;
                    placeholderSpan.style.backgroundColor = 'hsl(0, 0%, 80%)';
                    tokensContainer.appendChild(placeholderSpan);
                    assistantResponse += prefillText;
                }
            } else if (prefillText) {
                // Regular prefill (no injection) - show placeholder
                assistantResponse = prefillText;
                const placeholderSpan = document.createElement('span');
                placeholderSpan.className = 'token prefill-placeholder prefilled-token';
                placeholderSpan.textContent = prefillText;
                placeholderSpan.style.backgroundColor = 'hsl(0, 0%, 80%)';
                tokensContainer.appendChild(placeholderSpan);
            }
            
            try {
                // Create abort controller for this generation
                currentAbortController = new AbortController();
                
                // Use fetch with streaming for POST requests
                const temperature = newNode.temperature;
                
                // Get conversation history from tree
                const threadNodes = getActiveThread();
                console.log('Active thread nodes:', threadNodes.length);
                
                // The API expects [ {role, content}, ... ].
                // The last node in threadNodes is our new assistant node (empty).
                // We should send everything *before* it.
                const messagesToSend = threadNodes.slice(0, -1).map(n => ({
                    role: n.role,
                    content: n.content
                }));
                
                // Prepend system prompt if set
                if (currentSystemPrompt) {
                    messagesToSend.unshift({
                        role: 'system',
                        content: currentSystemPrompt
                    });
                }
                
                console.log('Messages to send:', messagesToSend);

                const requestBody = {
                    messages: messagesToSend,
                    model: modelName,
                    temperature: temperature
                };
                
                if (prefillText) {
                    requestBody.prefill = prefillText;
                }
                
                console.log('Sending request...', requestBody);
                const response = await fetch('/stream', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(requestBody),
                    signal: currentAbortController.signal
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    
                    // Decode the chunk
                    const chunk = decoder.decode(value, {stream: true});
                    
                    // Parse SSE format (data: {...}\n\n)
                    const lines = chunk.split('\n');
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const jsonStr = line.substring(6);
                            try {
                                const data = JSON.parse(jsonStr);
                                
                                if (data.type === 'token') {
                                    const isPromptToken = data.is_prompt_token || false;
                                    const isPrefillToken = data.is_prefill_token || false;
                                    
                                    // Skip prompt tokens entirely
                                    if (isPromptToken) {
                                        continue;
                                    }
                                    
                                    const tokenIdx = responseTokens.length;
                                    
                                    // Skip pre-injection tokens (already rendered immediately)
                                    if (preInjectionTokens && isPrefillToken && tokenIdx < preInjectionTokens.length) {
                                        continue;
                                    }
                                    
                                    // Skip the injected token text (already in assistantResponse from placeholder)
                                    const isInjectedToken = preInjectionTokens && isPrefillToken && tokenIdx === preInjectionTokens.length;
                                    if (!isInjectedToken) {
                                        assistantResponse += data.token;
                                    }
                                    
                                    const tokenData = {
                                        token: data.token,
                                        token_id: data.token_id,
                                        probability: data.probability,
                                        rank: data.rank,
                                        vocab_size: data.vocab_size,
                                        top_alternatives: data.top_alternatives,
                                        model: modelName,
                                        temperature: temperature,
                                        is_prefill_token: isPrefillToken,
                                        is_prompt_token: isPromptToken,
                                        is_injected: injectedTokenIndex !== null && tokenIdx === injectedTokenIndex
                                    };
                                    
                                    responseTokens.push(tokenData);
                                    
                                    // Update the node in real-time
                                    newNode.content = assistantResponse;
                                    newNode.tokens = responseTokens;
                                    
                                    // If this is the first streamed prefill token (after pre-injection), remove placeholder
                                    const expectedFirstPrefillIdx = preInjectionTokens ? preInjectionTokens.length : 0;
                                    if (isPrefillToken && tokenIdx === expectedFirstPrefillIdx) {
                                        const placeholder = tokensContainer.querySelector('.prefill-placeholder');
                                        if (placeholder) {
                                            placeholder.remove();
                                        }
                                    }
                                    
                                    // Add token normally
                                    const tokenSpan = addToken(tokensContainer, data.token, data.probability, data.rank, data.vocab_size, data.top_alternatives, tokenIdx, null, modelName, temperature, data.token_id);
                                    // Link token to node
                                    tokenSpan.dataset.nodeId = nodeId;
                                    
                                    // Add prefill styling if applicable
                                    // Only style the token if it matches injectedTokenIndex (for injected tokens)
                                    // or if no injectedTokenIndex is set (for regular prefill)
                                    if (isPrefillToken && tokenSpan) {
                                        if (injectedTokenIndex === null || tokenIdx === injectedTokenIndex) {
                                            tokenSpan.classList.add('prefilled-token');
                                        }
                                        prefillTokenCount++;
                                    }
                                    
                                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                } else if (data.type === 'done') {
                                    console.log('Generation done');
                                    // Finalize node update
                                    newNode.content = assistantResponse;
                                    newNode.tokens = responseTokens;
                                    
                                    saveCurrentConversation(true); // Update timestamp for new message
                                    isGenerating = false;
                                    currentAbortController = null;
                                    updateSendButton();
                                    
                                    // Update navigation controls (if this was a regeneration)
                                    updateMessageControls(nodeId);
                                    
                                } else if (data.type === 'error') {
                                    console.error('Server Error:', data.message);
                                    tokensContainer.innerHTML += `<div class="error-message">Error: ${escapeHtml(data.message)}</div>`;
                                    isGenerating = false;
                                    currentAbortController = null;
                                    updateSendButton();
                                }
                            } catch (e) {
                                // Skip invalid JSON
                                console.warn('JSON parse error in chunk:', e);
                            }
                        }
                    }
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('Generation stopped by user');
                    // Save partial response
                    newNode.content = assistantResponse;
                    newNode.tokens = responseTokens;
                    saveCurrentConversation(true);
                } else {
                console.error('Fetch/Stream error:', error);
                tokensContainer.innerHTML += `<div class="error-message">Connection error: ${error.message}. Please try again.</div>`;
                }
                isGenerating = false;
                currentAbortController = null;
                updateSendButton();
            }
        }

        function addToken(container, token, probability, rank, vocabSize, topAlternatives, tokenIndex, messageIndex = null, model = null, temperature = null, tokenId = null) {
            const tokenSpan = document.createElement('span');
            tokenSpan.className = 'token';
            
            // Store token data for context menu
            tokenSpan.dataset.token = token;
            tokenSpan.dataset.probability = probability;
            tokenSpan.dataset.rank = rank;
            tokenSpan.dataset.vocabSize = vocabSize;
            tokenSpan.dataset.topAlternatives = JSON.stringify(topAlternatives || []);
            tokenSpan.dataset.tokenIndex = tokenIndex;
            // tokenSpan.dataset.messageIndex = messageIndex !== null ? messageIndex : conversationHistory.length; // Deprecated
            tokenSpan.dataset.model = model || document.getElementById('model-select')?.value || 'Unknown';
            tokenSpan.dataset.temperature = temperature !== null ? temperature : (parseFloat(document.getElementById('temperature-input')?.value) || 1.0);
            tokenSpan.dataset.tokenId = (tokenId !== null && tokenId !== undefined) ? tokenId : '';
            
            // Color based on probability or rank (or gray if in DiffLens mode)
            if (currentView === 'diff') {
                // In DiffLens mode, new tokens should be gray until analyzed
                tokenSpan.style.backgroundColor = 'hsl(0, 0%, 75%)';
                tokenSpan.style.color = 'hsl(0, 0%, 30%)';
                tokenSpan.classList.add('difflens-neutral');
            } else {
            const color = getColorForProb(probability || 0, rank, vocabSize);
            tokenSpan.style.backgroundColor = color;
            }
            
            // Handle special tokens - check for any whitespace, not just exact matches
            let displayToken = token;
            let isWhitespace = false;
            let isSpecialToken = false;
            
            // Check for special tokens (like <end_of_turn>, <start_of_turn>, <|eot_id|>, etc.)
            if (token.startsWith('<') && token.endsWith('>')) {
                tokenSpan.classList.add('special-token');
                isSpecialToken = true;
            }
            // Also check for pipe-delimited special tokens like <|eot_id|>
            else if (token.includes('<|') || token.includes('|>')) {
                tokenSpan.classList.add('special-token');
                isSpecialToken = true;
            }
            // Check if token contains newlines
            else if (token.includes('\n')) {
                // Count newlines
                const newlineCount = (token.match(/\n/g) || []).length;
                displayToken = newlineCount === 1 ? '↵' : `↵×${newlineCount}`;
                tokenSpan.classList.add('newline-token');
                isWhitespace = true;
            } 
            // Check if token is only spaces
            else if (token === ' ' || /^\s+$/.test(token)) {
                tokenSpan.classList.add('space-token');
                isWhitespace = true;
            }
            // Check for tab characters
            else if (token.includes('\t')) {
                const tabCount = (token.match(/\t/g) || []).length;
                displayToken = tabCount === 1 ? '→' : `→×${tabCount}`;
                tokenSpan.classList.add('space-token');
                isWhitespace = true;
            }
            
            // Use textContent to prevent any HTML rendering issues
            tokenSpan.textContent = displayToken;
            
            // Add hover handler for tooltip (read-only mode)
            tokenSpan.addEventListener('mouseenter', function(e) {
                // Don't show hover tooltip if click tooltip is active
                const tooltip = document.getElementById('token-tooltip');
                if (!tooltip.classList.contains('click-mode')) {
                    showUnifiedTooltip(tokenSpan, 'hover');
                }
            });
            
            tokenSpan.addEventListener('mouseleave', function(e) {
                hideUnifiedTooltip('hover');
            });
            
            // Add click handler for tooltip (interactive mode)
            tokenSpan.addEventListener('click', function(e) {
                e.stopPropagation();
                showUnifiedTooltip(tokenSpan, 'click');
            });
            
            container.appendChild(tokenSpan);
            
            // Add actual newline break if token contains newlines
            if (token.includes('\n')) {
                const newlineCount = (token.match(/\n/g) || []).length;
                for (let i = 0; i < newlineCount; i++) {
                    container.appendChild(document.createElement('br'));
                }
            }
            
            return tokenSpan;
        }

        function getColorForProb(probability, rank = null, vocabSize = null) {
            // Color based on current highlight mode
            if (currentHighlightMode === 'rank' && rank !== null && vocabSize !== null) {
                // Rank-based coloring: lower rank (1 = best) = greener, higher rank = redder
                // Cap at rank 5 - anything worse than top 5 is red
                const cappedRank = Math.min(rank, 5);
                // Normalize rank to 0-1 scale (inverted so rank 1 = 1.0, rank 5+ = 0.0)
                const normalizedRank = 1 - (cappedRank - 1) / 4; // (5-1)/4 = 1.0, (1-1)/4 = 0.0
                const hue = 120 * normalizedRank;
                return `hsl(${hue}, 70%, 60%)`;
            } else {
                // Probability-based coloring: red (low) to green (high)
                const hue = 120 * (probability || 0);
                return `hsl(${hue}, 70%, 60%)`;
            }
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Helper function to format tokens for display consistently
        function formatTokenForDisplay(token, options = {}) {
            if (!token) return token;
            
            const { replaceAllSpaces = false, useSpaceSymbol = true } = options;
            
            // Check for newlines
            if (token.includes('\n')) {
                const newlineCount = (token.match(/\n/g) || []).length;
                return newlineCount === 1 ? '↵' : `↵×${newlineCount}`;
            }
            
            // Check for tabs
            if (token.includes('\t')) {
                const tabCount = (token.match(/\t/g) || []).length;
                return tabCount === 1 ? '→' : `→×${tabCount}`;
            }
            
            // Check if token is only whitespace (spaces, not tabs)
            if (/^\s+$/.test(token) && !token.includes('\t')) {
                if (useSpaceSymbol) {
                    const spaceCount = token.length;
                    return spaceCount === 1 ? '␣' : `␣×${spaceCount}`;
                }
                // Otherwise keep as-is
                return token;
            }
            
            // For mixed content, optionally replace spaces with middle dot
            if (replaceAllSpaces) {
                return token.replace(/ /g, '·');
            }
            
            // Return as-is for normal tokens
            return token;
        }

        // ===== VIEW SWITCHING =====
        
        function switchView() {
            const viewSelect = document.getElementById('view-select');
            const view = viewSelect ? viewSelect.value : 'token';
            currentView = view;
            
            // Save view to localStorage
            localStorage.setItem('tokenlens_view', view);
            
            const appContainer = document.querySelector('.app-container');
            if (appContainer) {
                appContainer.classList.remove('view-token', 'view-diff');
                appContainer.classList.add(view === 'diff' ? 'view-diff' : 'view-token');
            }
            
            if (view === 'diff') {
                applyDiffLensView();
            } else {
                resetDiffLensView();
            }
        }
        
        function switchHighlightMode() {
            const highlightModeSelect = document.getElementById('highlight-mode-select');
            const mode = highlightModeSelect ? highlightModeSelect.value : 'probability';
            currentHighlightMode = mode;
            
            // Save to localStorage
            localStorage.setItem('tokenlens_highlight_mode', mode);
            
            // Re-apply current view to update colors
            if (currentView === 'diff') {
                applyDiffLensView();
            } else {
                resetDiffLensView();
            }
        }
        
        function applyDiffLensView() {
            // Restore saved analysis model selection
            const savedAnalysisModel = localStorage.getItem('tokenlens_analysis_model');
            if (savedAnalysisModel) {
                const analysisSelect = document.getElementById('analysis-model-select');
                if (analysisSelect) {
                    analysisSelect.value = savedAnalysisModel;
                }
            }
            
            // Apply colors to tokens based on DiffLens data (or neutral if missing)
            const messagesContainer = document.getElementById('messages-container');
            const assistantMessages = messagesContainer.querySelectorAll('.assistant-message');
            
            assistantMessages.forEach(messageDiv => {
                const tokens = messageDiv.querySelectorAll('.token');
                tokens.forEach(token => {
                    if (token.dataset.difflensProbDiff) {
                        const diff = parseFloat(token.dataset.difflensProbDiff);
                        const rankDiff = token.dataset.difflensRankDiff ? parseFloat(token.dataset.difflensRankDiff) : null;
                        const color = getDiffLensColor(diff, rankDiff);
                        token.style.backgroundColor = color;
                        
                        if (Math.abs(diff) < 2) {
                            token.style.color = 'hsl(0, 0%, 30%)';
                            token.classList.remove('difflens-gen-prefers', 'difflens-analysis-prefers');
                            token.classList.add('difflens-neutral');
                        } else if (diff > 0) {
                            token.style.color = 'hsl(120, 50%, 20%)';
                            token.classList.remove('difflens-analysis-prefers', 'difflens-neutral');
                            token.classList.add('difflens-gen-prefers');
                        } else {
                            token.style.color = 'hsl(0, 50%, 25%)';
                            token.classList.remove('difflens-gen-prefers', 'difflens-neutral');
                            token.classList.add('difflens-analysis-prefers');
                        }
                    } else {
                        token.style.backgroundColor = 'hsl(0, 0%, 75%)';
                        token.style.color = 'hsl(0, 0%, 30%)';
                        token.classList.remove('difflens-gen-prefers', 'difflens-analysis-prefers');
                        token.classList.add('difflens-neutral');
                    }
                });
            });
        }
        
        function resetDiffLensView() {
            clearDiffLensAnalysis();
        }
        
        function clearDiffLensAnalysis() {
            // Reset all tokens to their original probability/rank-based colors
            const allTokens = document.querySelectorAll('.token');
            allTokens.forEach(token => {
                const prob = parseFloat(token.dataset.probability);
                const rank = parseInt(token.dataset.rank);
                const vocabSize = parseInt(token.dataset.vocabSize);
                if (!isNaN(prob)) {
                    const color = getColorForProb(prob, rank, vocabSize);
                    token.style.backgroundColor = color;
                }
                token.style.color = '';
                token.classList.remove('difflens-gen-prefers', 'difflens-analysis-prefers', 'difflens-neutral');
            });
        }
        
        async function triggerDiffLensAnalysis() {
            const analysisModel = document.getElementById('analysis-model-select').value;
            if (!analysisModel) {
                clearDiffLensAnalysis();
                return;
            }
            
            // Get apply button and set loading state
            const applyBtn = document.getElementById('apply-difflens-btn');
            const originalText = applyBtn.textContent;
            applyBtn.disabled = true;
            applyBtn.textContent = 'Analyzing...';
            
            try {
                // Save analysis model selection
                localStorage.setItem('tokenlens_analysis_model', analysisModel);
                
                const generationModel = document.getElementById('model-select').value;
                const messagesContainer = document.getElementById('messages-container');
                const assistantMessages = messagesContainer.querySelectorAll('.assistant-message');
                
                for (const messageDiv of assistantMessages) {
                const tokensContainer = messageDiv.querySelector('.message-tokens');
                if (!tokensContainer) continue;
                
                const tokens = tokensContainer.querySelectorAll('.token');
                if (tokens.length === 0) continue;
                
                // Build context up to this message using active thread (approximate)
                // Since we are iterating over visible messages, they correspond to active thread
                const thread = getActiveThread();
                const messageIndex = Array.from(assistantMessages).indexOf(messageDiv);
                // We need context messages. 
                // Active thread contains {role, content, ...} nodes.
                // Assistant messages in thread are at index 1, 3, 5... (assuming User-Assistant-User...)
                // Actually, we can just find the node corresponding to this message in the thread.
                const nodeId = messageDiv.dataset.nodeId;
                const nodeIndex = thread.findIndex(n => n.id === nodeId);
                
                if (nodeIndex === -1) continue;
                
                // Context is everything before this node
                const contextMessages = thread.slice(0, nodeIndex).map(n => ({
                    role: n.role,
                    content: n.content
                }));
                
                // Prepend system prompt if set
                if (currentSystemPrompt) {
                    contextMessages.unshift({
                        role: 'system',
                        content: currentSystemPrompt
                    });
                }
                
                // Get token data including rank and top alternatives
                const tokenData = Array.from(tokens).map(token => {
                    const tokenIdAttr = token.dataset.tokenId;
                    const parsedTokenId = (tokenIdAttr !== undefined && tokenIdAttr !== '') ? parseInt(tokenIdAttr, 10) : null;
                    return {
                        token: token.dataset.token,
                        token_id: Number.isNaN(parsedTokenId) ? null : parsedTokenId,
                        gen_prob: parseFloat(token.dataset.probability),
                        gen_rank: parseInt(token.dataset.rank),
                        gen_top_alternatives: JSON.parse(token.dataset.topAlternatives || '[]')
                    };
                });
                
                try {
                    // Use the temperature from generation (stored in first token)
                    const temperature = tokens.length > 0 ? parseFloat(tokens[0].dataset.temperature) || 1.0 : 1.0;
                    
                    const response = await fetch('/api/analyze-difflens', {
                        method: 'POST',
                        headers: {'Content-Type': 'application/json'},
                        body: JSON.stringify({
                            generation_model: generationModel,
                            analysis_model: analysisModel,
                            context: contextMessages,
                            tokens: tokenData,
                            temperature: temperature
                        })
                    });
                    
                    const result = await response.json();
                    
                    if (result.token_data && result.token_data.length > 0) {
                        // Store DiffLens data in node
                        const node = messageTree[nodeId];
                        if (node) {
                            node.difflens_data = {
                                generation_model: result.generation_model,
                                analysis_model: result.analysis_model,
                                token_data: result.token_data
                            };
                        }
                        
                        // Apply diff lens colors and update token data
                        tokens.forEach((token, idx) => {
                            if (result.token_data[idx]) {
                                const tokenInfo = result.token_data[idx];
                                const diff = tokenInfo.prob_diff;
                                const rankDiff = tokenInfo.rank_diff;
                                const color = getDiffLensColor(diff, rankDiff);
                                token.style.backgroundColor = color;
                                
                                // Set text color based on difference
                                if (Math.abs(diff) < 0.5) {
                                    token.style.color = 'hsl(0, 0%, 30%)';
                                } else if (diff > 0) {
                                    token.style.color = 'hsl(120, 50%, 20%)';
                                } else {
                                    token.style.color = 'hsl(0, 50%, 25%)';
                                }
                                
                                // Store DiffLens data in token element
                                token.dataset.difflensGenProb = tokenInfo.gen_prob;
                                token.dataset.difflensGenRank = tokenInfo.gen_rank;
                                token.dataset.difflensGenTopAlternatives = JSON.stringify(tokenInfo.gen_top_alternatives);
                                token.dataset.difflensAnalysisProb = tokenInfo.analysis_prob;
                                token.dataset.difflensAnalysisRank = tokenInfo.analysis_rank;
                                token.dataset.difflensAnalysisTopAlternatives = JSON.stringify(tokenInfo.analysis_top_alternatives);
                                token.dataset.difflensProbDiff = tokenInfo.prob_diff;
                                token.dataset.difflensRankDiff = tokenInfo.rank_diff;
                                token.dataset.difflensGenModel = result.generation_model;
                                token.dataset.difflensAnalysisModel = result.analysis_model;
                                
                                // Add class for styling
                                token.classList.remove('difflens-gen-prefers', 'difflens-analysis-prefers', 'difflens-neutral');
                                if (Math.abs(diff) < 0.5) {
                                    token.classList.add('difflens-neutral');
                                } else if (diff > 0) {
                                    token.classList.add('difflens-gen-prefers');
                                } else {
                                    token.classList.add('difflens-analysis-prefers');
                                }
                            }
                        });
                        
                        // Save conversation with DiffLens data
                        saveCurrentConversation();
                    }
                } catch (error) {
                    console.error('DiffLens analysis error:', error);
                }
            }
            } finally {
                // Reset button state
                applyBtn.disabled = false;
                applyBtn.textContent = originalText;
            }
        }
        
        function getDiffLensColor(percentageDiff, rankDiff = null) {
            // Color based on current highlight mode
            if (currentHighlightMode === 'rank' && rankDiff !== null) {
                // rankDiff = analysis_rank - gen_rank
                // Negative = generation model ranked higher (green)
                // Positive = analysis model ranked higher (red)
                // Near zero = similar (gray)
                
                // Clamp to reasonable range [-5, 5] (since individual ranks are capped at 5)
                const clamped = Math.max(-5, Math.min(5, rankDiff));
                const normalized = clamped / 5; // Now in [-1, 1]
                
                if (Math.abs(rankDiff) < 1) {
                    // Small rank difference (less than 1 rank) - gray
                    return 'hsl(0, 0%, 75%)';
                } else if (normalized < 0) {
                    // Generation model ranked higher (lower rank number) - green
                    const intensity = Math.abs(normalized);
                    const lightness = 85 - (intensity * 35); // 85% to 50%
                    return `hsl(120, 60%, ${lightness}%)`;
                } else {
                    // Analysis model ranked higher (lower rank number) - red
                    const intensity = Math.abs(normalized);
                    const lightness = 85 - (intensity * 35); // 85% to 50%
                    return `hsl(0, 60%, ${lightness}%)`;
                }
            } else {
                // Probability diff coloring
                // percentageDiff = (gen_prob - analysis_prob) * 100
                // Positive = generation model prefers (green)
                // Negative = analysis model prefers (red)
                // Near zero = similar (gray)
                
                // Clamp to reasonable range [-50, 50] (percentage points)
                const clamped = Math.max(-50, Math.min(50, percentageDiff));
                const normalized = clamped / 50; // Now in [-1, 1]
                
                if (Math.abs(percentageDiff) < 2) {
                    // Low difference (< 2 percentage points) - gray
                    return 'hsl(0, 0%, 75%)';
                } else if (normalized > 0) {
                    // Generation model prefers - green
                    const intensity = Math.abs(normalized);
                    const lightness = 85 - (intensity * 35); // 85% to 50%
                    return `hsl(120, 60%, ${lightness}%)`;
                } else {
                    // Analysis model prefers - red
                    const intensity = Math.abs(normalized);
                    const lightness = 85 - (intensity * 35); // 85% to 50%
                    return `hsl(0, 60%, ${lightness}%)`;
                }
            }
        }

        // ===== TOKEN CONTEXT MENU =====
        
        function showUnifiedTooltip(tokenElement, mode) {
            const tooltip = document.getElementById('token-tooltip');
            const currentTokenDiv = document.getElementById('tooltip-current-token');
            const alternativesDiv = document.getElementById('tooltip-alternatives');
            const searchInput = document.getElementById('token-search-input');
            const searchResults = document.getElementById('token-search-results');
            
            // Check if we're in DiffLens mode and have DiffLens data
            const inDiffLensMode = currentView === 'diff';
            const hasDiffLensData = tokenElement.dataset.difflensProbDiff !== undefined;
            
            // Get token data
            const token = tokenElement.dataset.token;
            const probability = parseFloat(tokenElement.dataset.probability);
            const rank = parseInt(tokenElement.dataset.rank);
            const vocabSize = parseInt(tokenElement.dataset.vocabSize);
            const topAlternatives = JSON.parse(tokenElement.dataset.topAlternatives);
            
            // Get DiffLens data if available
            let difflensData = null;
            if (inDiffLensMode && hasDiffLensData) {
                difflensData = {
                    genProb: parseFloat(tokenElement.dataset.difflensGenProb),
                    genRank: parseInt(tokenElement.dataset.difflensGenRank),
                    genTopAlternatives: JSON.parse(tokenElement.dataset.difflensGenTopAlternatives || '[]'),
                    analysisProb: parseFloat(tokenElement.dataset.difflensAnalysisProb),
                    analysisRank: parseInt(tokenElement.dataset.difflensAnalysisRank),
                    analysisTopAlternatives: JSON.parse(tokenElement.dataset.difflensAnalysisTopAlternatives || '[]'),
                    probDiff: parseFloat(tokenElement.dataset.difflensProbDiff),
                    rankDiff: parseInt(tokenElement.dataset.difflensRankDiff),
                    genModel: tokenElement.dataset.difflensGenModel,
                    analysisModel: tokenElement.dataset.difflensAnalysisModel
                };
            }
            
            const displayToken = formatTokenForDisplay(token, { useSpaceSymbol: true });
            
            // DiffLens mode: show comparison header and two-column layout
            if (inDiffLensMode) {
                // Show diff info at top if we have analysis data
                if (difflensData) {
                    currentTokenDiv.innerHTML = `
                        <div style="padding: 8px 12px; border-bottom: 1px solid var(--border-color); font-size: 0.9em;">
                            <strong>Prob Diff:</strong> ${difflensData.probDiff >= 0 ? '+' : ''}${difflensData.probDiff.toFixed(2)}% &nbsp;&nbsp;
                            <strong>Rank Diff:</strong> ${difflensData.rankDiff >= 0 ? '+' : ''}${difflensData.rankDiff}
                        </div>
                    `;
                } else {
                    currentTokenDiv.innerHTML = `
                        <div style="padding: 8px 12px; border-bottom: 1px solid var(--border-color); font-size: 0.9em; color: var(--text-secondary);">
                            Click "Apply" to analyze with analysis model
                        </div>
                    `;
                }
                
                // Two-column layout for models
                alternativesDiv.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr 1px 1fr; gap: 0; padding: 12px; min-width: 500px;">
                        <div class="model-column" style="padding-right: 12px; min-width: 0; overflow: hidden;">
                            <div style="font-weight: 600; margin-bottom: 8px; font-size: 0.875em; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${difflensData?.genModel || document.getElementById('model-select')?.value || 'Generation'}</div>
                            <div class="tooltip-current-token" style="margin-bottom: 8px; min-width: 0;">
                                <div class="current-left" style="min-width: 0; overflow: hidden;">
                                    ${rank ? `<span class="current-rank" style="flex-shrink: 0;">#${rank}</span>` : ''}
                                    <span class="current-token-text" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></span>
                                </div>
                                ${probability ? `<span class="current-prob" style="flex-shrink: 0;">${(probability * 100).toFixed(1)}%</span>` : ''}
                            </div>
                            <div class="alternatives-list">
                                ${topAlternatives && topAlternatives.length > 0 ? 
                                    topAlternatives
                                        .map((alt, i) => ({...alt, originalRank: i + 1}))
                                        .filter(alt => alt.token !== token)
                                        .slice(0, 2)
                                        .map((alt) => {
                                        const displayAlt = formatTokenForDisplay(alt.token, { useSpaceSymbol: true });
                                        return `
                                            <div class="tooltip-alternative-item" style="margin-bottom: 4px; min-width: 0;">
                                                <div class="alt-left" style="min-width: 0; overflow: hidden;">
                                                    <span class="alt-rank">#${alt.originalRank}</span>
                                                    <span class="alt-token" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${displayAlt}</span>
                                                </div>
                                                <span class="alt-prob" style="flex-shrink: 0;">${(alt.probability * 100).toFixed(1)}%</span>
                                            </div>
                                        `;
                                    }).join('') : '<div style="color: var(--text-secondary); font-size: 0.85em;">No alternatives</div>'}
                            </div>
                        </div>
                        <div style="background: var(--border-color); width: 1px;"></div>
                        <div class="model-column" style="padding-left: 12px; min-width: 0; overflow: hidden;">
                            <div style="font-weight: 600; margin-bottom: 8px; font-size: 0.875em; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${difflensData?.analysisModel || document.getElementById('analysis-model-select')?.value || 'Analysis'}</div>
                            ${difflensData ? `
                                <div class="tooltip-current-token" style="margin-bottom: 8px; min-width: 0;">
                                    <div class="current-left" style="min-width: 0; overflow: hidden;">
                                        ${difflensData.analysisRank ? `<span class="current-rank" style="flex-shrink: 0;">#${difflensData.analysisRank}</span>` : ''}
                                        <span class="current-token-text" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;"></span>
                                    </div>
                                    ${difflensData.analysisProb ? `<span class="current-prob" style="flex-shrink: 0;">${(difflensData.analysisProb * 100).toFixed(1)}%</span>` : ''}
                                </div>
                                <div class="alternatives-list">
                                    ${difflensData.analysisTopAlternatives && difflensData.analysisTopAlternatives.length > 0 ? 
                                        difflensData.analysisTopAlternatives
                                            .map((alt, i) => ({...alt, originalRank: i + 1}))
                                            .filter(alt => alt.token !== token)
                                            .slice(0, 2)
                                            .map((alt) => {
                                            const displayAlt = formatTokenForDisplay(alt.token, { useSpaceSymbol: true });
                                            return `
                                                <div class="tooltip-alternative-item" style="margin-bottom: 4px; min-width: 0;">
                                                    <div class="alt-left" style="min-width: 0; overflow: hidden;">
                                                        <span class="alt-rank">#${alt.originalRank}</span>
                                                        <span class="alt-token" style="overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${displayAlt}</span>
                                                    </div>
                                                    <span class="alt-prob" style="flex-shrink: 0;">${(alt.probability * 100).toFixed(1)}%</span>
                                                </div>
                                            `;
                                        }).join('') : '<div style="color: var(--text-secondary); font-size: 0.85em;">No alternatives</div>'}
                                </div>
                            ` : '<div style="color: var(--text-secondary); font-size: 0.85em; padding: 8px;">Not analyzed yet</div>'}
                        </div>
                    </div>
                `;
                
                // Set token text for both columns
                const tokenTextEls = alternativesDiv.querySelectorAll('.current-token-text');
                tokenTextEls.forEach(el => el.textContent = displayToken);
                
            } else {
                // Normal mode tooltip (existing implementation)
                const modelName = tokenElement.dataset.model || 'Unknown';
                const temperature = parseFloat(tokenElement.dataset.temperature) || 1.0;
                
                currentTokenDiv.innerHTML = `
                    <div style="padding: 8px 12px; border-bottom: 1px solid var(--border-color); font-size: 0.85em; color: var(--text-secondary);">
                        <strong>Model:</strong> ${modelName} &nbsp;&nbsp; <strong>Temp:</strong> ${temperature.toFixed(1)}
                    </div>
                    <div class="tooltip-current-token ${mode === 'click' ? 'clickable' : ''}">
                    <div class="current-left">
                        ${rank !== null && rank !== undefined && vocabSize ? `<span class="current-rank">#${rank}</span>` : '<span class="current-rank"></span>'}
                        <span class="current-token-text"></span>
                    </div>
                    ${probability !== null && probability !== undefined && !isNaN(probability) ? `<span class="current-prob">${(probability * 100).toFixed(1)}%</span>` : '<span class="current-prob"></span>'}
                </div>`;
                
                // Set token text directly to preserve all characters (including special tokens)
                const tokenTextEl = currentTokenDiv.querySelector('.current-token-text');
                tokenTextEl.textContent = displayToken;
                
                // Make current token clickable in click mode
                if (mode === 'click') {
                    const currentTokenRow = currentTokenDiv.querySelector('.tooltip-current-token');
                    currentTokenRow.onclick = () => selectAlternativeToken(token, currentTokenRow);
                }
                
                // Build alternatives list (exclude current token and show next 3)
                alternativesDiv.innerHTML = '';
                if (topAlternatives && topAlternatives.length > 0 && topAlternatives[0].probability !== null) {
                    // Filter out the current token, preserve original indices for rank calculation
                    const filteredAlts = topAlternatives
                        .map((alt, originalIdx) => ({ ...alt, originalRank: originalIdx + 1 }))
                        .filter(alt => alt.token !== token)
                        .slice(0, 2);
                    
                    filteredAlts.forEach((alt) => {
                const altItem = document.createElement('div');
                        altItem.className = 'tooltip-alternative-item';
                        
                        // Only clickable in click mode
                        if (mode === 'click') {
                            altItem.classList.add('clickable');
                altItem.onclick = () => selectAlternativeToken(alt.token, altItem);
                        }
                
                        const altRank = alt.originalRank;
                        const displayAltToken = formatTokenForDisplay(alt.token, { useSpaceSymbol: true });
                
                altItem.innerHTML = `
                            <div class="alt-left">
                                <span class="alt-rank">#${altRank}</span>
                                <span class="alt-token"></span>
                            </div>
                    <span class="alt-prob">${(alt.probability * 100).toFixed(1)}%</span>
                `;
                        
                        // Set token text directly to preserve all characters
                        const altTokenEl = altItem.querySelector('.alt-token');
                        altTokenEl.textContent = displayAltToken;
                        
                        alternativesDiv.appendChild(altItem);
                    });
                }
            }
            
            // Set mode FIRST so dimensions are correct
            tooltip.className = 'token-tooltip';
            if (mode === 'hover') {
                tooltip.classList.add('hover-mode');
            } else if (mode === 'click') {
                tooltip.classList.add('click-mode');
                selectedTokenElement = tokenElement;
                selectedAlternativeToken = token; // Select current token by default
                
                // Highlight current token row
                const currentTokenRow = tooltip.querySelector('.tooltip-current-token');
                if (currentTokenRow) {
                    currentTokenRow.classList.add('selected');
                }
            
                // Clear search
                searchInput.value = '';
                searchResults.innerHTML = '';
            }
            
            // Position tooltip smartly (after mode is set so dimensions are accurate)
            const rect = tokenElement.getBoundingClientRect();
            
            // Show tooltip temporarily to get its dimensions
            tooltip.style.visibility = 'hidden';
            tooltip.classList.remove('hidden');
            const tooltipRect = tooltip.getBoundingClientRect();
            tooltip.classList.add('hidden');
            tooltip.style.visibility = 'visible';
            
            const viewportHeight = window.innerHeight;
            const viewportWidth = window.innerWidth;
            const padding = 8;
            
            // Vertical positioning: prefer below, but flip above if not enough space
            let top;
            const spaceBelow = viewportHeight - rect.bottom;
            const spaceAbove = rect.top;
            
            if (spaceBelow >= tooltipRect.height + padding || spaceBelow > spaceAbove) {
                // Position below
                top = rect.bottom + padding;
            } else {
                // Position above
                top = rect.top - tooltipRect.height - padding;
            }
            
            // Horizontal positioning: keep within viewport bounds
            let left = rect.left;
            if (left + tooltipRect.width > viewportWidth - padding) {
                left = viewportWidth - tooltipRect.width - padding;
            }
            if (left < padding) {
                left = padding;
            }
            
            tooltip.style.top = `${top}px`;
            tooltip.style.left = `${left}px`;
            
            // Show tooltip
            tooltip.classList.remove('hidden');
            
            // Focus search input if in click mode
            if (mode === 'click') {
                setTimeout(() => searchInput.focus(), 0);
            }
        }
        
        function hideUnifiedTooltip(mode) {
            const tooltip = document.getElementById('token-tooltip');
            
            // Only hide if in the specified mode
            if (mode === 'hover' && tooltip.classList.contains('hover-mode')) {
                tooltip.classList.add('hidden');
                tooltip.classList.remove('hover-mode');
            } else if (mode === 'click' && tooltip.classList.contains('click-mode')) {
                // Clear all selections
                const currentTokenRow = tooltip.querySelector('.tooltip-current-token');
                if (currentTokenRow) {
                    currentTokenRow.classList.remove('selected');
                }
                tooltip.querySelectorAll('.tooltip-alternative-item').forEach(item => {
                    item.classList.remove('selected');
                });
                tooltip.querySelectorAll('.search-result-item').forEach(item => {
                    item.classList.remove('selected');
                });
                
                tooltip.classList.add('hidden');
                tooltip.classList.remove('click-mode');
                selectedTokenElement = null;
                selectedAlternativeToken = null;
            }
        }
        
        let searchListenerSetup = false;
        function setupTokenSearchListener() {
            if (searchListenerSetup) return;
            
            const searchInput = document.getElementById('token-search-input');
            if (!searchInput) return;
            
            searchInput.addEventListener('input', function() {
                clearTimeout(searchTimeout);
                const query = this.value.trim();
                
                console.log('Search input changed:', query);
                
                const resultsDiv = document.getElementById('token-search-results');
                
                if (query.length < 1) {
                    resultsDiv.innerHTML = '';
                    return;
                }
                
                // Show searching indicator
                resultsDiv.innerHTML = '<div class="search-no-results">Searching...</div>';
                
                searchTimeout = setTimeout(() => searchTokens(query), 300);
            });
            
            searchListenerSetup = true;
            console.log('Token search listener set up');
        }
        
        function selectAlternativeToken(token, element) {
            selectedAlternativeToken = token;
            
            // Update UI to show selection
            const tooltip = document.getElementById('token-tooltip');
            const currentTokenRow = tooltip.querySelector('.tooltip-current-token');
            if (currentTokenRow) {
                currentTokenRow.classList.remove('selected');
            }
            tooltip.querySelectorAll('.tooltip-alternative-item').forEach(item => {
                item.classList.remove('selected');
            });
            tooltip.querySelectorAll('.search-result-item').forEach(item => {
                item.classList.remove('selected');
            });
            element.classList.add('selected');
        }
        
        // Setup unified tooltip handlers
        function setupTooltipHandlers() {
            // Close click tooltip when clicking outside
            document.addEventListener('click', function(e) {
                const tooltip = document.getElementById('token-tooltip');
                if (tooltip && tooltip.classList.contains('click-mode') && !tooltip.contains(e.target) && !e.target.classList.contains('token')) {
                    hideUnifiedTooltip('click');
                }
            });
            
            // Prevent tooltip from closing when clicking inside it
            const tooltip = document.getElementById('token-tooltip');
            if (tooltip) {
                tooltip.addEventListener('click', function(e) {
                    e.stopPropagation();
                });
            }
            
            // Close on Escape key
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape') {
                    hideUnifiedTooltip('click');
                }
            });
        }
        
        // Token search with debouncing
        let searchTimeout = null;
        
        document.addEventListener('DOMContentLoaded', function() {
            // Restore view from localStorage
            const viewSelect = document.getElementById('view-select');
            const legacyMode = localStorage.getItem('tokenlens_mode');
            const savedView = localStorage.getItem('tokenlens_view') || (legacyMode === 'difflens' ? 'diff' : 'token');
            if (viewSelect) {
                viewSelect.value = savedView || 'token';
            }
            currentView = viewSelect ? viewSelect.value : 'token';
            switchView();
            
            // Restore highlight mode from localStorage
            const highlightModeSelect = document.getElementById('highlight-mode-select');
            const savedHighlightMode = localStorage.getItem('tokenlens_highlight_mode') || 'probability';
            if (highlightModeSelect) {
                highlightModeSelect.value = savedHighlightMode;
            }
            currentHighlightMode = savedHighlightMode;
            
            // Load default system prompt
            loadDefaultSystemPrompt();
            
            // Setup tooltip handlers
            setupTooltipHandlers();
            
            // Setup token search
            setupTokenSearchListener();
            
            // Setup button handlers
            const injectBtn = document.getElementById('inject-regenerate-btn');
            if (injectBtn) {
                injectBtn.onclick = () => injectAndRegenerate();
            }
            
            const logitLensBtn = document.getElementById('open-logit-lens-btn');
            if (logitLensBtn) {
                logitLensBtn.onclick = () => openLogitLensFromTooltip();
            }
        });
        
        async function searchTokens(query) {
            const modelName = document.getElementById('model-select').value;
            const resultsDiv = document.getElementById('token-search-results');
            
            console.log('Searching tokens for:', query, 'with model:', modelName);
            
            try {
                const response = await fetch('/api/search-tokens', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({query: query, model: modelName})
                });
                
                if (!response.ok) {
                    console.error('Search request failed:', response.status);
                    resultsDiv.innerHTML = '<div class="search-error">Search failed</div>';
                    return;
                }
                
                const results = await response.json();
                console.log('Search results:', results.length, 'tokens found');
                
                resultsDiv.innerHTML = '';
                
                if (results.length === 0) {
                    resultsDiv.innerHTML = '<div class="search-no-results">No matches found</div>';
                    return;
                }
                
                results.forEach((result, idx) => {
                    const item = document.createElement('div');
                    item.className = 'search-result-item';
                    item.onclick = () => selectAlternativeToken(result.token, item);
                    
                    const displaySearchToken = formatTokenForDisplay(result.token, { useSpaceSymbol: false });
                    
                    // Build probability badge if available
                    let probHTML = '';
                    if (result.probability !== null && result.probability !== undefined) {
                        probHTML = `<span class="alt-prob">${(result.probability * 100).toFixed(1)}%</span>`;
                    }
                    
                    item.innerHTML = `
                        <span class="alt-token"></span>
                        ${probHTML}
                    `;
                    
                    // Set token text directly to preserve all characters
                    const searchTokenEl = item.querySelector('.alt-token');
                    searchTokenEl.textContent = displaySearchToken;
                    
                    resultsDiv.appendChild(item);
                    
                    console.log(`Search result ${idx}:`, result.token, result.probability);
                });
            } catch (error) {
                console.error('Token search failed:', error);
                resultsDiv.innerHTML = '<div class="search-error">Search error: ' + error.message + '</div>';
            }
        }
        
        async function injectAndRegenerate() {
            if (!selectedTokenElement || !selectedAlternativeToken) {
                alert('Please select a token first');
                return;
            }
            
            const tokenIndex = parseInt(selectedTokenElement.dataset.tokenIndex);
            const nodeId = selectedTokenElement.dataset.nodeId;
            
            // Find the message node
            const node = messageTree[nodeId];
            if (!node || node.role !== 'assistant') {
                alert('Cannot inject: invalid message or not an assistant message');
                return;
            }
            
            // Get parent node (User message) to branch from
            const parentId = node.parentId;
            if (!parentId) {
                alert('Cannot inject: no parent message found');
                return;
            }
            
            // Get the tokens before injection point
            const tokensBeforeInjection = node.tokens.slice(0, tokenIndex);
            
            // Only the injected token should be prefilled (streamed)
            const prefillText = selectedAlternativeToken;
            
            // Calculate which token index is the injected one (for styling)
            const injectedTokenIndex = tokensBeforeInjection.length;
            
            // Set current leaf to parent to branch from there
            currentLeafId = parentId;
            
            // Remove the old assistant message from DOM (the one we're branching away from)
            const messageDiv = document.querySelector(`.message[data-node-id="${nodeId}"]`);
            if (messageDiv) {
                messageDiv.remove();
            }
            
            // Hide tooltip before starting generation
            hideUnifiedTooltip('click');
            
            // Trigger generation with just the injected token as prefill
            // Pass the pre-injection tokens so they can be rendered immediately
            await generateResponse(prefillText, injectedTokenIndex, tokensBeforeInjection);
        }

        function openLogitLensFromTooltip() {
            if (!selectedTokenElement) {
                alert('Please select a token first');
                return;
            }
            
            const tokenElement = selectedTokenElement;
            
            hideUnifiedTooltip('click');
            openLogitLens(tokenElement);
        }
        
        async function continueGenerationFromPoint(tokensContainer, prefillText, tokensBeforeInjection, injectedTokenData, startingIndex) {
            isGenerating = true;
            updateSendButton();
            const modelName = document.getElementById('model-select').value;
            const messagesContainer = document.getElementById('messages-container');
            
            let assistantResponse = prefillText;
            let allTokens = [...tokensBeforeInjection];  // Include pre-injection tokens
            
            // Add the injected token to the list with its probability data
            allTokens.push(injectedTokenData);
            
            try {
                // Create abort controller for this generation
                currentAbortController = new AbortController();
                
                const response = await fetch('/stream', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({
                        messages: conversationHistory,
                        model: modelName,
                        prefill: prefillText
                    }),
                    signal: currentAbortController.signal
                });
                
                const reader = response.body.getReader();
                const decoder = new TextDecoder();
                
                while (true) {
                    const {done, value} = await reader.read();
                    if (done) break;
                    
                    const chunk = decoder.decode(value, {stream: true});
                    const lines = chunk.split('\n');
                    
                    for (const line of lines) {
                        if (line.startsWith('data: ')) {
                            const jsonStr = line.substring(6);
                            try {
                                const data = JSON.parse(jsonStr);
                                
                                if (data.type === 'token') {
                                    const isPromptToken = data.is_prompt_token || false;
                                    
                                    // Skip prompt tokens
                                    if (isPromptToken) continue;
                                    
                                    assistantResponse += data.token;
                                    const tokenIdx = allTokens.length;
                                    allTokens.push({
                                        token: data.token,
                                        token_id: data.token_id,
                                        probability: data.probability,
                                        rank: data.rank,
                                        vocab_size: data.vocab_size,
                                        top_alternatives: data.top_alternatives
                                    });
                                    addToken(tokensContainer, data.token, data.probability, data.rank, data.vocab_size, data.top_alternatives, tokenIdx, null, null, null, data.token_id);
                                    messagesContainer.scrollTop = messagesContainer.scrollHeight;
                                } else if (data.type === 'done') {
                                    // Save complete message to conversation
                                    conversationHistory.push({
                                        role: 'assistant',
                                        content: assistantResponse,
                                        tokens: allTokens
                                    });
                                    saveCurrentConversation(true);
                                    isGenerating = false;
                                    currentAbortController = null;
                                    updateSendButton();
                                    break;
                                }
                            } catch (e) {
                                // Skip invalid JSON
                            }
                        }
                    }
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    console.log('Generation stopped by user');
                    // Save partial response
                    conversationHistory.push({
                        role: 'assistant',
                        content: assistantResponse,
                        tokens: allTokens
                    });
                    saveCurrentConversation(true);
                } else {
                console.error('Continuation failed:', error);
                tokensContainer.innerHTML += `<div class="error-message">Error: ${error.message}</div>`;
                }
                isGenerating = false;
                currentAbortController = null;
                updateSendButton();
            }
        }

        // ===== CONVERSATION MANAGEMENT =====
        
        async function initializeConversations() {
            console.log('Initializing conversations...');
            console.log('URL conversation ID:', urlConversationId);
            
            // Load conversations from server
            try {
                const response = await fetch('/api/conversations');
                const serverConvs = JSON.parse(await response.text());
                conversations = serverConvs;
                console.log('Loaded conversations from server:', Object.keys(conversations));
            } catch (error) {
                console.error('Failed to load conversations from server:', error);
                // Fallback to localStorage
                const saved = localStorage.getItem('tokenlens_conversations');
                if (saved) {
                    conversations = JSON.parse(saved);
                    console.log('Loaded conversations from localStorage:', Object.keys(conversations));
                }
            }
            
            // Priority 1: Load conversation from URL if provided
            if (urlConversationId) {
                console.log('Attempting to load conversation from URL:', urlConversationId);
                if (conversations[urlConversationId]) {
                    console.log('Found conversation in loaded data, loading...');
                    loadConversation(urlConversationId, false); // false = don't update URL
                    updateSidebar();
                    return;
                } else {
                    console.warn('Conversation', urlConversationId, 'not found in loaded conversations');
                    console.log('Available conversations:', Object.keys(conversations));
                    // Show error message to user
                    alert(`Conversation not found. It may have been deleted or doesn't exist.`);
                    // Redirect to home
                    window.location.href = '/';
                    return;
                }
            }
            
            // Priority 2: Load active conversation from localStorage
            currentConversationId = localStorage.getItem('tokenlens_active_conversation');
            
            // If no conversations exist, create a new one
            if (Object.keys(conversations).length === 0) {
                console.log('No conversations found, creating new one');
                createNewChat();
            } else {
                // Load the active conversation or the most recent one
                if (!currentConversationId || !conversations[currentConversationId]) {
                    const conversationIds = Object.keys(conversations).sort((a, b) => 
                        conversations[b].timestamp - conversations[a].timestamp
                    );
                    currentConversationId = conversationIds[0];
                    console.log('Loading most recent conversation:', currentConversationId);
                } else {
                    console.log('Loading active conversation:', currentConversationId);
                }
                loadConversation(currentConversationId);
            }
            
            updateSidebar();
        }
        
        function createNewChat() {
            // Save current conversation before creating new one
            if (currentConversationId) {
                saveCurrentConversation();
            }
            
            // Create new conversation
            const id = 'conv_' + Date.now();
            conversations[id] = {
                id: id,
                title: 'New Chat',
                timestamp: Date.now(),
                messageTree: {},
                currentLeafId: null,
                model: document.getElementById('model-select').value
            };
            
            currentConversationId = id;
            messageTree = {};
            currentLeafId = null;
            // conversationHistory = []; // Removed as it's derived
            
            // Clear UI
            clearChat();
            
            // Update URL
            updateUrl(id);
            
            // Save and update sidebar
            saveConversations();
            updateSidebar();
        }
        
        function saveCurrentConversation(updateTimestamp = false) {
            if (!currentConversationId) return;
            
            const conversation = conversations[currentConversationId];
            if (!conversation) return;
            
            // Update conversation object with current tree state
            conversation.messageTree = messageTree;
            conversation.currentLeafId = currentLeafId;
            conversation.model = document.getElementById('model-select').value;
            conversation.systemPrompt = currentSystemPrompt;
            
            // Also save linear messages for backwards compatibility or preview
            // conversation.messages = getActiveThread(); 
            
            // Only update timestamp when new content is added, not when just switching
            if (updateTimestamp) {
                conversation.timestamp = Date.now();
            }
            
            // Generate title from first user message
            const thread = getActiveThread();
            if (thread.length > 0 && conversation.title === 'New Chat') {
                const firstUserMsg = thread.find(msg => msg.role === 'user');
                if (firstUserMsg) {
                    conversation.title = firstUserMsg.content.substring(0, 50);
                    if (firstUserMsg.content.length > 50) {
                        conversation.title += '...';
                    }
                }
            }
            
            saveConversations();
            updateSidebar();
        }
        
        async function saveConversations() {
            // Save to server
            if (currentConversationId && conversations[currentConversationId]) {
                try {
                    await fetch(`/api/conversations/${currentConversationId}`, {
                        method: 'PUT',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                        body: JSON.stringify(conversations[currentConversationId])
                    });
                } catch (error) {
                    console.error('Failed to save conversation to server:', error);
                }
            }
            
            // Also save to localStorage as backup
            localStorage.setItem('tokenlens_conversations', JSON.stringify(conversations));
            localStorage.setItem('tokenlens_active_conversation', currentConversationId);
        }
        
        function loadConversation(id, updateUrlFlag = true) {
            // Save current conversation first
            if (currentConversationId && currentConversationId !== id) {
                saveCurrentConversation();
            }
            
            const conversation = conversations[id];
            if (!conversation) return;
            
            currentConversationId = id;
            
            // Handle legacy format (list of messages) vs new format (tree)
            if (conversation.messageTree) {
                messageTree = conversation.messageTree;
                currentLeafId = conversation.currentLeafId;
            } else if (conversation.messages) {
                // Migrate legacy messages to tree
                console.log('Migrating legacy conversation to tree format');
                messageTree = {};
                let prevId = null;
                
                conversation.messages.forEach(msg => {
                    const nodeId = uuidv4();
                    const node = {
                        id: nodeId,
                        parentId: prevId,
                        childrenIds: [],
                        role: msg.role,
                        content: msg.content,
                        tokens: msg.tokens || [],
                        model: msg.role === 'assistant' ? (conversation.model || 'meta-llama/Llama-3.1-8B-Instruct') : null,
                        temperature: 1.0,
                        timestamp: Date.now(),
                        difflens_data: msg.difflens_data || null
                    };
                    
                    messageTree[nodeId] = node;
                    
                    if (prevId && messageTree[prevId]) {
                        messageTree[prevId].childrenIds.push(nodeId);
                    }
                    
                    prevId = nodeId;
                });
                
                currentLeafId = prevId;
            } else {
                // Empty
                messageTree = {};
                currentLeafId = null;
            }
            
            // Set model
            document.getElementById('model-select').value = conversation.model || 'meta-llama/Llama-3.1-8B-Instruct';
            
            // Load system prompt
            currentSystemPrompt = conversation.systemPrompt || '';
            const systemPromptInput = document.getElementById('system-prompt-input');
            if (systemPromptInput) {
                systemPromptInput.value = currentSystemPrompt;
            }
            updateSystemPromptBubble();
            
            // Render messages
            renderActiveThread();
            
            // Update URL if requested
            if (updateUrlFlag) {
                updateUrl(id);
            }
            
            saveConversations();
            updateSidebar();
        }

        function renderActiveThread() {
            const messagesContainer = document.getElementById('messages-container');
            messagesContainer.innerHTML = '';
            
            // Add system prompt bubble
            messagesContainer.innerHTML = `
                <!-- System Prompt Bubble (hidden by default) -->
                <div class="system-prompt-bubble" id="system-prompt-bubble" style="display: none;">
                    <div class="system-prompt-header" onclick="toggleSystemPromptBubble()">
                        <span class="system-prompt-label">System</span>
                        <span class="system-prompt-toggle" id="system-prompt-toggle">▼</span>
                    </div>
                    <div class="system-prompt-content" id="system-prompt-content">
                        <!-- System prompt text will be inserted here -->
                    </div>
                </div>
            `;
            
            // Update system prompt bubble visibility
            updateSystemPromptBubble();
            
            const thread = getActiveThread();
            
            if (thread.length === 0) {
                const welcomeDiv = document.createElement('div');
                welcomeDiv.className = 'welcome-message';
                welcomeDiv.innerHTML = `
                    <h2>Welcome to Scope</h2>
                    <p>Chat with AI and see token probabilities in real-time</p>
                `;
                messagesContainer.appendChild(welcomeDiv);
            } else {
                thread.forEach((msg) => {
                    if (msg.role === 'user') {
                        addUserMessage(msg, false);
                    } else if (msg.role === 'assistant') {
                        addAssistantMessage(msg.content, msg.tokens || [], msg, msg.difflens_data);
                    }
                });
            }
            
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
            
            // Re-apply DiffLens if active
            if (currentView === 'diff') {
                applyDiffLensView();
            }
        }
        
        // Helper to navigate to a specific node (make it the active path)
        function navigateToNode(nodeId) {
            if (!messageTree[nodeId]) return;
            
            // If this node is a leaf, just set it
            if (messageTree[nodeId].childrenIds.length === 0) {
                currentLeafId = nodeId;
            } else {
                // If not a leaf, we need to find the most recently active leaf that descends from this node
                // For now, just pick the last child recursively?
                // Better: Store 'lastSelectedChild' in nodes to remember branch history.
                
                let curr = nodeId;
                while (messageTree[curr] && messageTree[curr].childrenIds.length > 0) {
                    // Prefer lastSelectedChildId if we track it, otherwise last added child
                    const children = messageTree[curr].childrenIds;
                    const preferredChild = messageTree[curr].lastSelectedChildId;
                    
                    if (preferredChild && children.includes(preferredChild)) {
                        curr = preferredChild;
                    } else {
                        // Default to the last child (most recent)
                        curr = children[children.length - 1];
                    }
                }
                currentLeafId = curr;
            }
            
            saveCurrentConversation();
            renderActiveThread();
        }
        
        function navigateSibling(nodeId, direction) {
            const node = messageTree[nodeId];
            if (!node) return;
            
            let siblings = [];
            if (node.parentId) {
                siblings = messageTree[node.parentId].childrenIds;
            } else {
                siblings = Object.values(messageTree).filter(n => !n.parentId).map(n => n.id);
            }
            
            const currentIndex = siblings.indexOf(nodeId);
            if (currentIndex === -1) return;
            
            const newIndex = currentIndex + direction;
            if (newIndex >= 0 && newIndex < siblings.length) {
                const siblingId = siblings[newIndex];
                
                // Update parent's lastSelectedChildId preference
                if (node.parentId && messageTree[node.parentId]) {
                    messageTree[node.parentId].lastSelectedChildId = siblingId;
                }
                
                navigateToNode(siblingId);
            }
        }
        
        function updateMessageControls(nodeId) {
            // Update just the controls for a specific message without full re-render
            const node = messageTree[nodeId];
            if (!node) return;
            
            const messageDiv = document.querySelector(`.message[data-node-id="${nodeId}"]`);
            if (!messageDiv) return;
            
            // Find or create the controls container
            let controlsDiv = messageDiv.querySelector('.message-controls');
            if (!controlsDiv) {
                controlsDiv = document.createElement('div');
                controlsDiv.className = 'message-controls';
                const contentDiv = messageDiv.querySelector('.message-content');
                if (contentDiv) {
                    contentDiv.appendChild(controlsDiv);
                }
            }
            
            // Build controls HTML
            let controlsHtml = '';
            
            // Check for siblings
            const parent = node.parentId ? messageTree[node.parentId] : null;
            let siblings = [];
            if (parent) {
                siblings = parent.childrenIds;
            } else {
                siblings = Object.values(messageTree).filter(n => !n.parentId).map(n => n.id);
            }
            
            const currentIndex = siblings.indexOf(node.id);
            const siblingsCount = siblings.length;
            
            // Edit button (for user messages)
            if (node.role === 'user') {
                controlsHtml += `
                    <button class="edit-msg-btn" onclick="enableEditMode('${node.id}')" title="Edit message">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M11 4H4a2 2 0 0 0-2 2v14a2 2 0 0 0 2 2h14a2 2 0 0 0 2-2v-7"></path>
                            <path d="M18.5 2.5a2.121 2.121 0 0 1 3 3L12 15l-4 1 1-4 9.5-9.5z"></path>
                        </svg>
                    </button>
                `;
            }
            
            // Regenerate button (for assistant messages)
            if (node.role === 'assistant' && node.parentId) {
                controlsHtml += `
                    <button class="regenerate-btn" onclick="regenerateFromNode('${node.parentId}')" title="Regenerate">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="23 4 23 10 17 10"></polyline>
                            <path d="M20.49 15a9 9 0 1 1-2.12-9.36L23 10"></path>
                        </svg>
                    </button>
                `;
            }
            
            // Navigation buttons (if multiple siblings)
            if (siblingsCount > 1) {
                controlsHtml += `
                    <div class="message-nav">
                        <button class="nav-btn prev" ${currentIndex === 0 ? 'disabled' : ''} onclick="navigateSibling('${node.id}', -1)">❮</button>
                        <span class="nav-count">${currentIndex + 1}/${siblingsCount}</span>
                        <button class="nav-btn next" ${currentIndex === siblingsCount - 1 ? 'disabled' : ''} onclick="navigateSibling('${node.id}', 1)">❯</button>
                    </div>
                `;
            }
            
            controlsDiv.innerHTML = controlsHtml;
        }
        
        async function regenerateFromNode(parentId) {
            // If parentId is null, it means we are regenerating from root? usually assistant has a parent (user msg)
            // If parentId is "null" string (from template), treat as null
            const realParentId = parentId === 'null' ? null : parentId;
            
            // Set current leaf to the parent, effectively "rewinding" to that point
            // But we want to branch, not delete. 
            // Setting currentLeafId to parentId means the next message added will be a child of parentId.
            // But wait, if we set currentLeafId to parentId, then `generateResponse` will add a NEW child to it.
            // Yes, that's what we want.
            
            currentLeafId = realParentId;
            
            // Update UI to reflect the state before generation (hides the old branch)
            renderActiveThread();
            
            await generateResponse();
            
            // After generation, the new node is the leaf.
            // renderActiveThread() is called by generateResponse implicitly via updates? 
            // No, generateResponse appends DOM. We should force a re-render to show the navigation buttons on the new message.
            // Actually generateResponse updates the DOM of the *new* message.
            // But the *sibling* (previous response) navigation buttons might need updating if they are visible?
            // Since we are on a new branch, the old response is not in the active thread anymore.
            // So we just need to ensure the View matches the new Thread.
            // generateResponse appends to the container.
            // But since we "rewound" currentLeafId, the getActiveThread() changed.
            // The existing DOM messages might be "future" messages if we were in the middle of a thread?
            // Wait. If we go back to a user message and regenerate:
            // The user message is displayed. The old assistant message is displayed after it.
            // If we regenerate, we are effectively replacing the old assistant message in the view with a new one (streaming).
            // So we should probably clear the messages *after* the parent node from the DOM before generating.
            
            renderActiveThread(); // This will show the thread up to parent.
            // Then generateResponse will append the new message.
        }
        
        function enableEditMode(nodeId) {
            const node = messageTree[nodeId];
            if (!node) return;
            
            const messageDiv = document.querySelector(`.message[data-node-id="${nodeId}"]`);
            if (!messageDiv) return;
            
            const contentDiv = messageDiv.querySelector('.message-content');
            
            // Save current HTML to restore if cancelled (optional, or just re-render)
            
            contentDiv.innerHTML = `
                <div class="edit-mode-container">
                    <textarea class="edit-message-input">${node.content}</textarea>
                    <div class="edit-actions">
                        <button class="btn-secondary" onclick="cancelEditMessage('${nodeId}')">Cancel</button>
                        <button class="btn-primary" onclick="saveEditedMessage('${nodeId}')">Save & Submit</button>
                    </div>
                </div>
            `;
            
            // Auto-resize
            const textarea = contentDiv.querySelector('textarea');
            textarea.style.height = textarea.scrollHeight + 'px';
        }
        
        function cancelEditMessage(nodeId) {
            // Just re-render the thread to restore view
            renderActiveThread();
        }
        
        function saveEditedMessage(nodeId) {
            const messageDiv = document.querySelector(`.message[data-node-id="${nodeId}"]`);
            const textarea = messageDiv.querySelector('textarea');
            const newContent = textarea.value.trim();
            
            if (!newContent) return;
            
            const oldNode = messageTree[nodeId];
            
            // If content hasn't changed, just cancel
            if (newContent === oldNode.content) {
                cancelEditMessage(nodeId);
                return;
            }
            
            // Create a NEW sibling node with the new content
            const newNodeId = uuidv4();
            const newNode = {
                ...oldNode,
                id: newNodeId,
                childrenIds: [], // New branch starts here
                content: newContent,
                timestamp: Date.now(),
                tokens: [] // Clear tokens as it's a new user message? Or re-tokenize? 
                           // For User messages, tokens are usually computed on backend for analysis, 
                           // but here we treat it as text. User nodes don't usually have 'tokens' property populated by backend in this app yet?
                           // Actually addUserMessage just displays text.
            };
            
            // Add to tree
            messageTree[newNodeId] = newNode;
            
            // Link to parent
            if (oldNode.parentId && messageTree[oldNode.parentId]) {
                messageTree[oldNode.parentId].childrenIds.push(newNodeId);
                // Set this as the preferred child
                messageTree[oldNode.parentId].lastSelectedChildId = newNodeId;
            }
            
            // Set as current leaf (temporarily, until we generate response)
            currentLeafId = newNodeId;
            
            // Re-render view to show the updated user message
            renderActiveThread();
            
            // Trigger generation for the Assistant response
            generateResponse();
        }
        
        async function deleteCurrentChat() {
            if (!currentConversationId) return;
            
            if (!confirm('Delete this conversation?')) return;
            
            const idToDelete = currentConversationId;
            
            // Delete from conversations object
            delete conversations[idToDelete];
            
            // Delete from server
            try {
                await fetch(`/api/conversations/${idToDelete}`, {
                    method: 'DELETE'
                });
            } catch (error) {
                console.error('Failed to delete conversation from server:', error);
            }
            
            // Load another conversation or create new one
            const remainingIds = Object.keys(conversations);
            if (remainingIds.length > 0) {
                loadConversation(remainingIds[0]);
            } else {
                createNewChat();
            }
            
            // Save remaining conversations
            localStorage.setItem('tokenlens_conversations', JSON.stringify(conversations));
            updateSidebar();
        }
        
        function updateSidebar() {
            const list = document.getElementById('conversations-list');
            list.innerHTML = '';
            
            // Sort conversations by timestamp (newest first)
            const sortedIds = Object.keys(conversations).sort((a, b) => 
                conversations[b].timestamp - conversations[a].timestamp
            );
            
            sortedIds.forEach(id => {
                const conv = conversations[id];
                const item = document.createElement('div');
                item.className = 'conversation-item' + (id === currentConversationId ? ' active' : '');
                item.onclick = () => loadConversation(id);
                
                item.innerHTML = `
                    <div class="conversation-title">${conv.title}</div>
                    <button class="delete-conversation-btn" onclick="event.stopPropagation(); deleteConversation('${id}')" title="Delete chat">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M3 6h18"></path>
                            <path d="M19 6v14c0 1-1 2-2 2H7c-1 0-2-1-2-2V6"></path>
                            <path d="M8 6V4c0-1 1-2 2-2h4c1 0 2 1 2 2v2"></path>
                        </svg>
                    </button>
                `;
                
                list.appendChild(item);
            });
        }
        
        async function deleteConversation(id) {
            delete conversations[id];
            
            // Delete from server
            try {
                await fetch(`/api/conversations/${id}`, {
                    method: 'DELETE'
                });
            } catch (error) {
                console.error('Failed to delete conversation from server:', error);
            }
            
            // If we deleted the current conversation, switch to another or create new
            if (id === currentConversationId) {
                const remainingIds = Object.keys(conversations);
                if (remainingIds.length > 0) {
                    loadConversation(remainingIds[0]);
                } else {
                    createNewChat();
                }
            }
            
            saveConversations();
            updateSidebar(); // Refresh the sidebar UI
        }
        
        function formatDate(date) {
            const now = new Date();
            const diff = now - date;
            const minutes = Math.floor(diff / 60000);
            const hours = Math.floor(diff / 3600000);
            const days = Math.floor(diff / 86400000);
            
            if (minutes < 1) return 'Just now';
            if (minutes < 60) return `${minutes}m ago`;
            if (hours < 24) return `${hours}h ago`;
            if (days < 7) return `${days}d ago`;
            
            return date.toLocaleDateString();
        }
        
        function updateUrl(conversationId) {
            const newUrl = `/chat/${conversationId}`;
            window.history.pushState({ conversationId: conversationId }, '', newUrl);
        }
        
        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            sidebar.classList.toggle('collapsed');
            
            // Save sidebar state
            const isCollapsed = sidebar.classList.contains('collapsed');
            localStorage.setItem('tokenlens_sidebar_collapsed', isCollapsed);
        }
        
        function initializeSidebar() {
            const sidebar = document.getElementById('sidebar');
            const savedState = localStorage.getItem('tokenlens_sidebar_collapsed');
            
            // If saved state exists and is 'true', collapse the sidebar
            if (savedState === 'true') {
                sidebar.classList.add('collapsed');
            }
        }
        
        
        // Handle browser back/forward buttons
        window.addEventListener('popstate', function(event) {
            if (event.state && event.state.conversationId) {
                // Load the conversation without updating the URL (it's already updated by popstate)
                loadConversation(event.state.conversationId, false);
            } else {
                // No state, redirect to home which will load default conversation
                window.location.href = '/';
            }
        });
        
        function addAssistantMessage(content, tokens, nodeOrIdx, difflensData = null) {
            const messagesContainer = document.getElementById('messages-container');
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message assistant-message';
            
            let node = null;
            if (typeof nodeOrIdx === 'object') {
                node = nodeOrIdx;
                messageDiv.dataset.nodeId = node.id;
            }
            
            // Controls
            let controlsHtml = '';
            if (node) {
                 const parent = node.parentId ? messageTree[node.parentId] : null;
                 let siblings = parent ? parent.childrenIds : [];
                 const currentIndex = siblings.indexOf(node.id);
                 const total = siblings.length;
                 
                 controlsHtml += `
                    <button class="regenerate-btn" onclick="regenerateFromNode('${node.parentId}')" title="Regenerate response">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <path d="M21.5 2v6h-6M2.5 22v-6h6M2 11.5a10 10 0 0 1 18.8-4.3M22 12.5a10 10 0 0 1-18.8 4.3"/>
                        </svg>
                    </button>
                `;
                
                 if (total > 1) {
                     controlsHtml += `
                        <div class="message-nav">
                            <button class="nav-btn prev" ${currentIndex === 0 ? 'disabled' : ''} onclick="navigateSibling('${node.id}', -1)">❮</button>
                            <span class="nav-count">${currentIndex + 1}/${total}</span>
                            <button class="nav-btn next" ${currentIndex === total - 1 ? 'disabled' : ''} onclick="navigateSibling('${node.id}', 1)">❯</button>
                        </div>
                    `;
                 }
            }
            
            const tokensContainer = document.createElement('div');
            tokensContainer.className = 'message-tokens';
            
            if (tokens && tokens.length > 0) {
                // Render with token data using the same addToken function for consistency
                tokens.forEach((tokenData, idx) => {
                    // Skip prompt tokens
                    if (tokenData.is_prompt_token) {
                        return;
                    }
                    // Note: messageIndex param in addToken is not strictly used for logic, mostly for referencing. 
                    // Passing node.id or null is better if we update addToken.
                    // For now passing idx is fine.
                    const tokenSpan = addToken(tokensContainer, tokenData.token, tokenData.probability, tokenData.rank, tokenData.vocab_size, tokenData.top_alternatives, idx, null, tokenData.model, tokenData.temperature, tokenData.token_id);
                    if (node) {
                        tokenSpan.dataset.nodeId = node.id;
                    }
                    
                    // Only apply prefill styling to injected tokens, or all prefill tokens if none are injected
                    if (tokenData.is_prefill_token) {
                        const hasInjectedToken = tokens.some(t => t.is_injected);
                        if (!hasInjectedToken || tokenData.is_injected) {
                            tokenSpan.classList.add('prefilled-token');
                        }
                    }
                    
                    // Apply DiffLens data if available AND we're in diff view
                    if (difflensData && difflensData.token_data && difflensData.token_data[idx]) {
                        const tokenInfo = difflensData.token_data[idx];
                        const diff = tokenInfo.prob_diff;
                        const rankDiff = tokenInfo.rank_diff;
                        
                        // Store DiffLens data in token element (always store, but only apply colors if in diff view)
                        tokenSpan.dataset.difflensGenProb = tokenInfo.gen_prob;
                        tokenSpan.dataset.difflensGenRank = tokenInfo.gen_rank;
                        tokenSpan.dataset.difflensGenTopAlternatives = JSON.stringify(tokenInfo.gen_top_alternatives);
                        tokenSpan.dataset.difflensAnalysisProb = tokenInfo.analysis_prob;
                        tokenSpan.dataset.difflensAnalysisRank = tokenInfo.analysis_rank;
                        tokenSpan.dataset.difflensAnalysisTopAlternatives = JSON.stringify(tokenInfo.analysis_top_alternatives);
                        tokenSpan.dataset.difflensProbDiff = tokenInfo.prob_diff;
                        tokenSpan.dataset.difflensRankDiff = tokenInfo.rank_diff;
                        tokenSpan.dataset.difflensGenModel = difflensData.generation_model;
                        tokenSpan.dataset.difflensAnalysisModel = difflensData.analysis_model;
                        
                        // Only apply DiffLens styling if currently in diff view
                        if (currentView === 'diff') {
                            const color = getDiffLensColor(diff, rankDiff);
                            tokenSpan.style.backgroundColor = color;
                            
                            // Set text color based on difference (diff is in percentage points)
                            if (Math.abs(diff) < 2) {
                                tokenSpan.style.color = 'hsl(0, 0%, 30%)';
                            } else if (diff > 0) {
                                tokenSpan.style.color = 'hsl(120, 50%, 20%)';
                            } else {
                                tokenSpan.style.color = 'hsl(0, 50%, 25%)';
                            }
                            
                            // Add class for styling
                            tokenSpan.classList.remove('difflens-gen-prefers', 'difflens-analysis-prefers', 'difflens-neutral');
                            if (Math.abs(diff) < 0.5) {
                                tokenSpan.classList.add('difflens-neutral');
                            } else if (diff > 0) {
                                tokenSpan.classList.add('difflens-gen-prefers');
                            } else {
                                tokenSpan.classList.add('difflens-analysis-prefers');
                            }
                        }
                    } else if (currentView === 'diff') {
                        // In DiffLens mode but no analysis yet - make gray
                        tokenSpan.style.backgroundColor = 'hsl(0, 0%, 75%)';
                        tokenSpan.style.color = 'hsl(0, 0%, 30%)';
                        tokenSpan.classList.add('difflens-neutral');
                    }
                });
            } else {
                // Plain text rendering
                tokensContainer.textContent = content;
            }
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'message-content';
            
            // Add tokens container
            contentDiv.appendChild(tokensContainer);
            
            // Add controls below content
            if (controlsHtml) {
                const controlsDiv = document.createElement('div');
                controlsDiv.className = 'message-controls';
                controlsDiv.innerHTML = controlsHtml;
                contentDiv.appendChild(controlsDiv);
            }
            
            messageDiv.appendChild(contentDiv);
            
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Auto-resize textarea
        const textarea = document.getElementById('user-input');
        textarea.addEventListener('input', function() {
            this.style.height = 'auto';
            this.style.height = Math.min(this.scrollHeight, 200) + 'px';
        });
        
        // Initialize on page load
        initializeSidebar();
        initializeConversations().then(() => {
            // Set initial history state after conversations are loaded
            if (currentConversationId) {
                const currentPath = window.location.pathname;
                const expectedPath = `/chat/${currentConversationId}`;
                
                // Only update if paths don't match
                if (currentPath !== expectedPath) {
                    window.history.replaceState(
                        { conversationId: currentConversationId }, 
                        '', 
                        expectedPath
                    );
                    console.log('Updated URL to match loaded conversation:', expectedPath);
                } else {
                    // Just set the state without changing URL
                    window.history.replaceState(
                        { conversationId: currentConversationId }, 
                        '', 
                        currentPath
                    );
                }
            }
        });
        
        // ============= LOGIT LENS FUNCTIONS =============
        
        let currentLogitLensData = null;
        let currentLogitLensView = 'heatmap';
        let activeChartTokens = [];
        const CHART_COLORS = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e'];
        
        async function openLogitLens(tokenElement) {
            // Get token context - find all tokens up to this one
            const messageContainer = tokenElement.closest('.message-content');
            if (!messageContainer) {
                console.error('Cannot find message container');
                return;
            }
            
            // Get all tokens in this message
            const allTokens = Array.from(messageContainer.querySelectorAll('.token'));
            const targetIndex = allTokens.indexOf(tokenElement);
            
            if (targetIndex === -1) {
                console.error('Token not found in message');
                return;
            }
            
            // Determine the window of tokens to analyze
            // Show a context window ending at the clicked token
            const windowSize = 10; // Show up to 10 tokens for a nice view
            const startIndex = Math.max(0, targetIndex - windowSize + 1);
            
            // Collect tokens for the analysis window (including the target)
            const tokensWindow = allTokens.slice(startIndex, targetIndex + 1);
            
            // Collect all tokens BEFORE the window for context
            const contextTokens = allTokens.slice(0, startIndex).map(span => ({
                token: span.dataset.token,
                probability: parseFloat(span.dataset.probability),
                rank: parseInt(span.dataset.rank),
                vocab_size: parseInt(span.dataset.vocabSize)
            }));
            
            // The tokens in the window (for display and analysis)
            const windowTokensData = tokensWindow.map(span => ({
                token: span.dataset.token,
                display: span.textContent,
                probability: parseFloat(span.dataset.probability),
                rank: parseInt(span.dataset.rank),
                vocab_size: parseInt(span.dataset.vocabSize)
            }));
            
            // Get the node ID to find context
            const nodeId = tokenElement.dataset.nodeId;
            let context = [];
            
            if (nodeId && messageTree[nodeId]) {
                // Build context from message tree
                let currentNode = messageTree[nodeId];
                const thread = [];
                
                while (currentNode && currentNode.parentId) {
                    const parent = messageTree[currentNode.parentId];
                    if (parent) {
                        thread.unshift(parent);
                    }
                    currentNode = parent;
                }
                
                // Convert to context format (all messages for context)
                context = thread.map(node => ({
                    role: node.role,
                    content: node.content
                }));
                
                // Prepend system prompt if set
                if (currentSystemPrompt) {
                    context.unshift({
                        role: 'system',
                        content: currentSystemPrompt
                    });
                }
            }
            
            // Show modal with loading state
            const modal = document.getElementById('logit-lens-modal');
            const tokenDisplay = document.getElementById('logit-lens-token');
            const loading = modal.querySelector('.logit-lens-loading');
            const viz = modal.querySelector('.logit-lens-viz');
            
            tokenDisplay.textContent = tokenElement.dataset.token;
            modal.classList.remove('hidden');
            loading.style.display = 'flex';
            viz.classList.add('hidden');
            
            try {
                // Call API
                const model = tokenElement.dataset.model || document.getElementById('model-select')?.value;
                
                const response = await fetch('/api/logit-lens', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: model,
                        context: context,
                        context_tokens: contextTokens, // All tokens before the window
                        window_tokens: windowTokensData, // The tokens in the window to analyze
                        top_k: 20 // Get top 20 for better vocab coverage in search
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to analyze token');
                }
                
                const data = await response.json();
                // Add window tokens for display
                data.window_tokens = windowTokensData;
                currentLogitLensData = data;
                
                // Reset chart tokens for new analysis
                activeChartTokens = [];
                
                // Hide loading, show viz
                loading.style.display = 'none';
                viz.classList.remove('hidden');
                
                // Render based on current view
                if (currentLogitLensView === 'heatmap') {
                    renderLogitLensHeatmap(data);
                } else {
                    renderLogitLensChart(data);
                }
                
            } catch (error) {
                console.error('Error in logit lens:', error);
                alert('Failed to analyze token: ' + error.message);
                closeLogitLensModal();
            }
        }
        
        function closeLogitLensModal() {
            const modal = document.getElementById('logit-lens-modal');
            modal.classList.add('hidden');
            currentLogitLensData = null;
            activeChartTokens = [];
            
            // Destroy chart
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }
            
            // Clear search
            const searchInput = document.getElementById('chart-token-search');
            if (searchInput) searchInput.value = '';
            const searchResults = document.getElementById('chart-search-results');
            if (searchResults) searchResults.classList.remove('active');
        }
        
        function switchLogitLensView(view) {
            currentLogitLensView = view;
            
            // Update toggle buttons
            document.querySelectorAll('.view-toggle .toggle-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.view === view);
            });
            
            // Update viz containers
            const heatmapContainer = document.getElementById('logit-lens-heatmap');
            const chartContainer = document.getElementById('logit-lens-chart');
            
            if (view === 'heatmap') {
                heatmapContainer.classList.add('active');
                chartContainer.classList.remove('active');
                if (currentLogitLensData) {
                    renderLogitLensHeatmap(currentLogitLensData);
                }
            } else {
                heatmapContainer.classList.remove('active');
                chartContainer.classList.add('active');
                if (currentLogitLensData) {
                    // Initialize chart with top 2 tokens on first view
                    if (activeChartTokens.length === 0) {
                        initializeChartTokens();
                    }
                    // Delay rendering to ensure container is visible
                    setTimeout(() => renderLogitLensChart(), 50);
                }
            }
        }
        
        function renderLogitLensHeatmap(data) {
            const container = document.getElementById('heatmap-canvas-container');
            const positions = data.positions; // Array of position analyses
            const windowTokens = data.window_tokens; // The actual tokens
            const numLayers = data.num_layers;
            
            // Create table with classic Logit Lens style
            // Columns: Input tokens (sequence positions)
            // Rows: Layers
            // Cells: Top predicted token at that position and layer
            
            let html = '<table class="heatmap-table">';
            
            // Header row: show the actual input tokens
            html += '<tr><th style="min-width: 100px; background: var(--bg-secondary);">Layer</th>';
            windowTokens.forEach(t => {
                const displayToken = t.display || formatTokenForDisplay(t.token, { replaceAllSpaces: false });
                html += `<th style="min-width: 80px; background: var(--bg-secondary); font-family: var(--font-mono);">${displayToken}</th>`;
            });
            html += '</tr>';
            
            // Data rows: one row per layer
            for (let layerIdx = 0; layerIdx < numLayers; layerIdx++) {
                const layerLabel = `Layer ${layerIdx}`;
                html += `<tr><td style="background: var(--bg-secondary); font-weight: 600;">${layerLabel}</td>`;
                
                // For each position in the window
                positions.forEach(posData => {
                    // Find the prediction for this layer
                    const layerPred = posData.layer_predictions.find(lp => lp.layer === layerIdx);
                    
                    if (layerPred && layerPred.predictions && layerPred.predictions.length > 0) {
                        const topPred = layerPred.predictions[0];
                        const prob = topPred.probability;
                        const token = topPred.token;
                        const displayToken = formatTokenForDisplay(token, { replaceAllSpaces: true });
                        const color = getColorForProb(prob);
                        const textColor = prob > 0.6 ? '#000' : 'var(--text-color)';
                        
                        html += `<td style="background-color: ${color}; color: ${textColor}; text-align: center; font-family: var(--font-mono); padding: 8px; font-size: 0.85em; cursor: pointer;" 
                            class="heatmap-cell-hover"
                            data-layer="${layerIdx}"
                            data-position="${posData.position}"
                            data-token="${token}"
                            data-prob="${prob}">
                            ${displayToken}
                        </td>`;
                    } else {
                        html += '<td style="background: var(--bg-secondary);">-</td>';
                    }
                });
                
                html += '</tr>';
            }
            
            html += '</table>';
            container.innerHTML = '<div class="heatmap-table-scroll">' + html + '</div>';
            
            // Add hover listeners for custom tooltips
            setTimeout(() => {
                document.querySelectorAll('.heatmap-cell-hover').forEach(cell => {
                    cell.addEventListener('mouseenter', showLogitLensTooltip);
                    cell.addEventListener('mouseleave', hideLogitLensTooltip);
                });
            }, 100);
        }
        
        function showLogitLensTooltip(e) {
            const cell = e.target;
            const layer = cell.dataset.layer;
            const position = cell.dataset.position;
            const token = cell.dataset.token;
            const prob = parseFloat(cell.dataset.prob);
            
            const tooltip = document.getElementById('logit-lens-tooltip');
            const header = document.getElementById('tooltip-header');
            const body = document.getElementById('tooltip-body');
            
            const windowTokens = currentLogitLensData.window_tokens;
            const inputToken = windowTokens[position];
            const inputDisplay = inputToken ? inputToken.display : '';
            
            const layerLabel = `Layer ${layer}`;
            
            header.textContent = `${layerLabel} → Position ${parseInt(position) + 1}`;
            
            body.innerHTML = `
                <div class="tooltip-row">
                    <span class="tooltip-label">Input Token:</span>
                    <span class="tooltip-value">"${inputDisplay}"</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Predicted:</span>
                    <span class="tooltip-value">"${formatTokenForDisplay(token, { replaceAllSpaces: true })}"</span>
                </div>
                <div class="tooltip-row">
                    <span class="tooltip-label">Probability:</span>
                    <span class="tooltip-value">${(prob * 100).toFixed(2)}%</span>
                </div>
            `;
            
            tooltip.classList.add('visible');
            
            // Position tooltip smartly near cell
            const rect = cell.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();
            
            const viewportHeight = window.innerHeight;
            const viewportWidth = window.innerWidth;
            const padding = 10;
            
            // Vertical positioning: prefer below, but flip above if not enough space
            let top;
            const spaceBelow = viewportHeight - rect.bottom;
            const spaceAbove = rect.top;
            
            if (spaceBelow >= tooltipRect.height + padding || spaceBelow > spaceAbove) {
                // Position below
                top = rect.bottom + padding;
            } else {
                // Position above
                top = rect.top - tooltipRect.height - padding;
            }
            
            // Horizontal positioning: keep within viewport bounds
            let left = rect.left;
            if (left + tooltipRect.width > viewportWidth - padding) {
                left = viewportWidth - tooltipRect.width - padding;
            }
            if (left < padding) {
                left = padding;
            }
            
            tooltip.style.top = `${top}px`;
            tooltip.style.left = `${left}px`;
        }
        
        function hideLogitLensTooltip() {
            const tooltip = document.getElementById('logit-lens-tooltip');
            tooltip.classList.remove('visible');
        }
        
        function initializeChartTokens() {
            if (!currentLogitLensData || !currentLogitLensData.positions) return;
            
            // Get the last position (clicked token)
            const lastPos = currentLogitLensData.positions[currentLogitLensData.positions.length - 1];
            const finalLayer = lastPos.layer_predictions[lastPos.layer_predictions.length - 1];
            
            // Add top 2 tokens
            const top2 = finalLayer.predictions.slice(0, 2).map(p => p.token);
            activeChartTokens = top2.map((token, idx) => ({
                token,
                color: CHART_COLORS[idx]
            }));
            
            updateActiveTokensDisplay();
        }
        
        function updateActiveTokensDisplay() {
            const container = document.getElementById('active-chart-tokens');
            container.innerHTML = '';
            
            activeChartTokens.forEach((tokenData, idx) => {
                const chip = document.createElement('div');
                chip.className = 'active-token-chip';
                
                const displayToken = formatTokenForDisplay(tokenData.token, { replaceAllSpaces: false });
                
                chip.innerHTML = `
                    <div class="active-token-color" style="background-color: ${tokenData.color};"></div>
                    <span>${displayToken}</span>
                    <button class="active-token-remove" onclick="removeChartToken(${idx})">×</button>
                `;
                
                container.appendChild(chip);
            });
        }
        
        function removeChartToken(idx) {
            activeChartTokens.splice(idx, 1);
            updateActiveTokensDisplay();
            renderLogitLensChart();
        }
        
        function addChartToken(token) {
            // Don't add if already present
            if (activeChartTokens.some(t => t.token === token)) return;
            
            // Get next color
            const colorIdx = activeChartTokens.length % CHART_COLORS.length;
            activeChartTokens.push({
                token,
                color: CHART_COLORS[colorIdx]
            });
            
            updateActiveTokensDisplay();
            renderLogitLensChart();
        }
        
        // Token search for chart - search full vocab like inject feature
        const chartSearchInput = document.getElementById('chart-token-search');
        const chartSearchResults = document.getElementById('chart-search-results');
        
        if (chartSearchInput) {
            let searchTimeout;
            chartSearchInput.addEventListener('input', async (e) => {
                const query = e.target.value.trim();
                
                if (query.length < 1) {
                    chartSearchResults.classList.remove('active');
                    return;
                }
                
                // Debounce search
                clearTimeout(searchTimeout);
                searchTimeout = setTimeout(async () => {
                    try {
                        // Get model and context
                        const modelSelect = document.getElementById('model-select');
                        const modelName = modelSelect ? modelSelect.value : 'meta-llama/Llama-3.1-8B-Instruct';
                        
                        // Build context from message tree if available
                        let context = [];
                        if (currentLogitLensData && currentLogitLensData.positions) {
                            // Try to get context from the analysis
                            context = getActiveThread().map(node => ({
                                role: node.role,
                                content: node.content
                            }));
                        }
                        
                        // Search full vocabulary
                        const response = await fetch('/api/search-tokens', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                query: query,
                                model: modelName,
                                context: context,
                                prefix_tokens: []
                            })
                        });
                        
                        if (!response.ok) throw new Error('Search failed');
                        
                        const matches = await response.json();
                        
                        if (matches && matches.length > 0) {
                            chartSearchResults.innerHTML = matches.slice(0, 15).map(match => {
                                const displayToken = formatTokenForDisplay(match.token, { replaceAllSpaces: false });
                                const probText = match.probability ? ` (${(match.probability * 100).toFixed(1)}%)` : '';
                                return `<div class="token-result-item" onclick="addChartToken('${match.token.replace(/'/g, "\\'")}')">${displayToken}${probText}</div>`;
                            }).join('');
                            chartSearchResults.classList.add('active');
                        } else {
                            chartSearchResults.innerHTML = '<div class="search-no-results">No matches found</div>';
                            chartSearchResults.classList.add('active');
                        }
                    } catch (error) {
                        console.error('Token search error:', error);
                        chartSearchResults.innerHTML = '<div class="search-error">Search error</div>';
                        chartSearchResults.classList.add('active');
                    }
                }, 300);
            });
            
            // Close results when clicking outside
            document.addEventListener('click', (e) => {
                if (!chartSearchInput.contains(e.target) && !chartSearchResults.contains(e.target)) {
                    chartSearchResults.classList.remove('active');
                }
            });
        }
        
        let currentChart = null; // Store Chart.js instance
        
        function renderLogitLensChart() {
            if (!currentLogitLensData || !currentLogitLensData.positions) return;
            
            const canvas = document.getElementById('probability-chart');
            const container = canvas.parentElement;
            
            if (!container || container.offsetWidth === 0) {
                console.warn('Chart container not visible');
                return;
            }
            
            // Destroy previous chart if it exists
            if (currentChart) {
                currentChart.destroy();
                currentChart = null;
            }
            
            const ctx = canvas.getContext('2d');
            
            // Show message if no tokens selected
            if (activeChartTokens.length === 0) {
                canvas.width = container.offsetWidth - 40;
                canvas.height = container.offsetHeight - 40;
                ctx.fillStyle = '#666';
                ctx.font = '14px Inter, sans-serif';
                ctx.textAlign = 'center';
                ctx.fillText('No tokens selected. Search and add tokens to visualize.', canvas.width / 2, canvas.height / 2);
                return;
            }
            
            // Get the last position (clicked token) data
            const lastPos = currentLogitLensData.positions[currentLogitLensData.positions.length - 1];
            
            // Build layer labels
            const layerLabels = lastPos.layer_predictions.map(layer => `Layer ${layer.layer}`);
            
            // Build datasets for Chart.js
            const datasets = activeChartTokens.map(tokenData => {
                const data = lastPos.layer_predictions.map(layer => {
                    const pred = layer.predictions.find(p => p.token === tokenData.token);
                    return pred ? pred.probability : 0;
                });
                
                return {
                    label: formatTokenForDisplay(tokenData.token, { replaceAllSpaces: false }),
                    data: data,
                    borderColor: tokenData.color,
                    backgroundColor: tokenData.color,
                    tension: 0.1,
                    pointRadius: 5,
                    pointHoverRadius: 7
                };
            });
            
            // Create Chart.js chart
            currentChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: layerLabels,
                    datasets: datasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    interaction: {
                        mode: 'nearest',
                        intersect: false
                    },
                    plugins: {
                        legend: {
                            display: false // We have our own legend with remove buttons
                        },
                        tooltip: {
                            backgroundColor: 'rgba(0, 0, 0, 0.85)',
                            padding: 12,
                            titleFont: {
                                size: 14,
                                weight: 'bold'
                            },
                            bodyFont: {
                                size: 13
                            },
                            callbacks: {
                                title: function(context) {
                                    return context[0].label;
                                },
                                label: function(context) {
                                    const token = context.dataset.label;
                                    const prob = context.parsed.y;
                                    return `${token}: ${(prob * 100).toFixed(2)}%`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Layer',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            grid: {
                                color: '#ddd'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Probability',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            min: 0,
                            max: 1,
                            ticks: {
                                callback: function(value) {
                                    return value.toFixed(1);
                                }
                            },
                            grid: {
                                color: '#ddd'
                            }
                        }
                    }
                }
            });
        }
        
        // Close modal when clicking outside
        document.addEventListener('click', function(e) {
            const modal = document.getElementById('logit-lens-modal');
            if (modal && !modal.classList.contains('hidden')) {
                const content = modal.querySelector('.logit-lens-content');
                if (content && !content.contains(e.target)) {
                    // Don't close if clicking on a token (to allow double-click)
                    if (!e.target.classList.contains('token')) {
                        closeLogitLensModal();
                    }
                }
            }
        });
    </script>
</body>
</html>

